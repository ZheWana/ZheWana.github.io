<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的第一篇文章</title>
    <url>/2021/05/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>这是我的第一篇文章。</p>
<span id="more"></span>

<p>这确实是我的第一篇文章，我怎么会骗你呢？</p>
<p>当然，这个第一篇是博客意义上的。</p>
<p>本人，大一废物一个（写下这篇文章的时候），绩点废物，还在坚强的努力学习，技术不精通，除了一颗喜欢玩的心之外一无所有。特别喜欢听音乐，无线耳机重度依赖症，纯音乐、填词音乐、中文音乐、英文音乐只要是好听的音乐都喜欢听。喜欢看电影和看番，但是不是那种会追溯番剧历史和文化的人，最喜欢的类型应该是温馨画风的番剧，以及烧脑电影。重度Warma粉，最近刚画了一块满是Warma的板子。偶尔会自己一个人多愁善感感叹人生，但是清醒过来还是会觉得自己当时是个智障。</p>
<p>我很讨厌文科，但是讽刺的是某一天突然发现自己似乎特别喜欢写一些自己学习技术的时候的技术笔记来作为教程帮助一些初学者（虽然我自己也是初学者），于是在社团里面投稿了很多学习笔记。但是一次重装系统让我意识到<del>爱</del>知识的确是会消失的，最终决定把自己之前的笔记以及以后的笔记全部上传在这个博客。此外，可能还会有一些平时的小吐槽发在里面。</p>
<p>希望自己能在技术的道路上越走越远，最后真的能成为一个软硬兼修的全栈工程师</p>
<p>…….吧？</p>
<p>最后，虽然有点突兀，但是还是要说的：</p>
<p>我已经完全爱上Warma啦！！！</p>
<p><img src="../images/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/437011d3d5437f6e2f534038626ec6c00ff9accf.jpg" alt="437011d3d5437f6e2f534038626ec6c00ff9accf"></p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>废话</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>VL53L0X模块笔记</title>
    <url>/2021/07/22/VL53L0X%E6%A8%A1%E5%9D%97%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近几天学习了激光测距模块，现将过程记录下来以便以后浏览。</p>
<span id="more"></span>

<blockquote>
<p>有关模块学习的资料已经整理后上传了：</p>
<p><a href="https://wws.lanzoui.com/izIHArp85pa">https://wws.lanzoui.com/izIHArp85pa</a></p>
<p>密码:ayr4</p>
</blockquote>
<h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><p><del>VL53L0是一款意法半导体推出的激光测距模块</del></p>
<p>果然还是复制官方的说法比较靠谱：</p>
<blockquote>
<p>以下内容来自数据手册“Description”和某翻译</p>
<p>The VL53L0X is a new generation Time-of-Flight (ToF) laser-ranging module housed in the smallest package on the market today, providing accurate distance measurement whatever the target reflectances unlike conventional technologies. It can measure absolute distances up to 2m, setting a new benchmark in ranging performance levels, opening the door to various new applications.</p>
<p>VL53L0X是新一代的飞行时间（ToF）激光测距模块，采用当今市场上最小的封装，与传统技术不同，无论目标反射如何，都能提供精确的距离测量。它可以测量高达2米的绝对距离，为性能水平的范围设定了新的基准，为各种新的应用打开了大门。</p>
<p>The VL53L0X integrates a leading-edge SPAD array (Single Photon Avalanche Diodes) and embeds ST’s second generation FlightSenseTM patented technology.</p>
<p>VL53L0X集成了先进的SPAD阵列（单光子雪崩二极管），并嵌入ST的第二代FlightSenseTM专利技术。</p>
<p>The VL53L0X’s 940nm VCSEL emitter (Vertical Cavity Surface-Emitting Laser), is totally invisible to the human eye, coupled with internal physical infrared filters, it enables longer ranging distance, higher immunity to ambient light and better robustness to cover-glass optical cross-talk.  </p>
<p>VL53L0X的940nm VCSEL发射器（垂直腔面发射激光器）对人眼完全不可见，再加上内部物理红外滤光片，它可以实现更长的测距距离、更高的环境光免疫力和更好的鲁棒性，以覆盖玻璃光学串扰。</p>
</blockquote>
<p>附模块原理图如下：</p>
<p><img src="/images/53l0x_SCH-1626938571782.jpg" alt="53l0x_SCH"></p>
<h3 id="通信接口及引脚定义"><a href="#通信接口及引脚定义" class="headerlink" title="通信接口及引脚定义"></a>通信接口及引脚定义</h3><p>模块采用IIC通信，故：</p>
<p><strong>SCL：IIC时钟线</strong></p>
<p><strong>SDA：IIC数据线</strong></p>
<p>此外：</p>
<p><strong>VIN：电源</strong></p>
<p><strong>GND：接地</strong></p>
<p><strong>XShut：设备唤醒引脚</strong></p>
<blockquote>
<p>PS：XShut的接线方法决定了设备的测量模式，引用手册中的说法如下：</p>
<p>There are two options available for device power up/boot.</p>
<p>Option 1: </p>
<p>**XSHUT pin connected and controlled from host.**This option helps to optimize power consumption as the VL53L0X can be completely powered off when not used, and then woken up through host GPIO (using XSHUT pin).</p>
<p>HW Standby mode is defined as the period when AVDD is present and XSHUT is low.  </p>
<p>Option 2: </p>
<p><strong>XSHUT pin not controlled by host, and tied to AVDD through pull-up resistor.</strong></p>
<p>In case XSHUT pin is not controlled, the power up sequence is presented in Figure 11. In this case, the device is going automatically in SW STANDBY after FW BOOT, without entering HW STANDBY.  </p>
</blockquote>
<p><strong>GPIO1：中断输出</strong></p>
<blockquote>
<p>PS：GPIO1为中断输出，在手册中可以看出，当采用中断测量模式的时候，每次当设备准备就绪进行新的测量时，中断引脚就会进行输出来触发主机的中断，手册中说法如下：</p>
<p>Interrupt mode: An interrupt pin (GPIO1) sends an interrupt to the host when a new measurement is available.  </p>
</blockquote>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>对于该模块，不得不提的事情就是官方为其写了一个API库可以方便我们的应用层开发，而我们的任务就是进行该库的移植。</p>
<p>本来这个库的最大难点就在于移植，但是在网上我找到了有人做过了HAL库的移植版本，因此我们自己就不再做HAL移植了。但是为了方便自己以后在其他的平台上进行开发，我还是会对比已经移植完的函数库进行一次移植，这段内容就放在后面了。</p>
<p>我们首先来说API函数库：</p>
<h4 id="测量数据结构体"><a href="#测量数据结构体" class="headerlink" title="测量数据结构体"></a>测量数据结构体</h4><p>结构体源码如下，各个变量的含义均在库函数中有所提及：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> TimeStamp;		<span class="comment">/*!&lt; 32-bit time stamp. */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> MeasurementTimeUsec;</span><br><span class="line">		<span class="comment">/*!&lt; Give the Measurement time needed by the device to do the</span></span><br><span class="line"><span class="comment">		 * measurement.*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint16_t</span> RangeMilliMeter;	<span class="comment">/*!&lt; range distance in millimeter. */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint16_t</span> RangeDMaxMilliMeter;</span><br><span class="line">		<span class="comment">/*!&lt; Tells what is the maximum detection distance of the device</span></span><br><span class="line"><span class="comment">		 * in current setup and environment conditions (Filled when</span></span><br><span class="line"><span class="comment">		 *	applicable) */</span></span><br><span class="line"></span><br><span class="line">	FixPoint1616_t SignalRateRtnMegaCps;</span><br><span class="line">		<span class="comment">/*!&lt; Return signal rate (MCPS)\n these is a 16.16 fix point</span></span><br><span class="line"><span class="comment">		 *	value, which is effectively a measure of target</span></span><br><span class="line"><span class="comment">		 *	 reflectance.*/</span></span><br><span class="line">	FixPoint1616_t AmbientRateRtnMegaCps;</span><br><span class="line">		<span class="comment">/*!&lt; Return ambient rate (MCPS)\n these is a 16.16 fix point</span></span><br><span class="line"><span class="comment">		 *	value, which is effectively a measure of the ambien</span></span><br><span class="line"><span class="comment">		 *	t light.*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint16_t</span> EffectiveSpadRtnCount;</span><br><span class="line">		<span class="comment">/*!&lt; Return the effective SPAD count for the return signal.</span></span><br><span class="line"><span class="comment">		 *	To obtain Real value it should be divided by 256 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint8_t</span> ZoneId;</span><br><span class="line">		<span class="comment">/*!&lt; Denotes which zone and range scheduler stage the range</span></span><br><span class="line"><span class="comment">		 *	data relates to. */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> RangeFractionalPart;</span><br><span class="line">		<span class="comment">/*!&lt; Fractional part of range distance. Final value is a</span></span><br><span class="line"><span class="comment">		 *	FixPoint168 value. */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> RangeStatus;</span><br><span class="line">		<span class="comment">/*!&lt; Range Status for the current measurement. This is device</span></span><br><span class="line"><span class="comment">		 *	dependent. Value = 0 means value is valid.</span></span><br><span class="line"><span class="comment">		 *	See \ref RangeStatusPage */</span></span><br><span class="line">&#125; VL53L0X_RangingMeasurementData_t;</span><br></pre></td></tr></table></figure>

<p>在使用之前应该定义一个用于测量数据存储的结构体变量以供后续函数使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VL53L0X_RangingMeasurementData_t RangingData;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中RangeMilliMeter为我们期望的测量距离值，单位：mm</p>
</blockquote>
<h4 id="设备结构体"><a href="#设备结构体" class="headerlink" title="设备结构体"></a>设备结构体</h4><p>设备结构体是API函数库和所用平台之间连接的纽带<del>（反正手册是这么说的）</del>，结构体源码如下，变量含义已经在源码中给出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VL53L0X_DevData_t Data;               <span class="comment">/*!&lt; embed ST Ewok Dev  data as &quot;Data&quot;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!&lt; user specific field */</span></span><br><span class="line"></span><br><span class="line">    I2C_HandleTypeDef *I2cHandle;</span><br><span class="line">    <span class="keyword">uint8_t</span>   I2cDevAddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>    DevLetter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>     Id;</span><br><span class="line">    <span class="keyword">int</span>     Present;</span><br><span class="line">    <span class="keyword">int</span> 	Enabled;</span><br><span class="line">    <span class="keyword">int</span>		Ready;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span>   comms_type;</span><br><span class="line">    <span class="keyword">uint16_t</span>  comms_speed_khz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> LeakyRange;</span><br><span class="line">    <span class="keyword">int</span> LeakyFirst;</span><br><span class="line">    <span class="keyword">uint8_t</span> RangeStatus;</span><br><span class="line">    <span class="keyword">uint8_t</span> PreviousRangeStatus;</span><br><span class="line">    FixPoint1616_t SignalRateRtnMegaCps;</span><br><span class="line">    <span class="keyword">uint16_t</span> EffectiveSpadRtnCount;</span><br><span class="line">    <span class="keyword">uint32_t</span> StartTime;</span><br><span class="line"></span><br><span class="line">&#125; VL53L0X_Dev_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在使用之前，我们需要定义一个设备结构体变量以供后续函数使用，同时要在定义时将I2C句柄（&amp;hi2c1）以及I2C设备地址（0x52）赋值:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VL53L0X_Dev_t Dev = &#123;</span><br><span class="line">        .I2cHandle=&amp;hi2c1,</span><br><span class="line">        .I2cDevAddr=<span class="number">0x52</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PS:众所周知，HAL库使用的是8位地址，因此手册中的7位地址需要左移一位才能被正确读取，但是为什么0x52没有左移呢？</p>
<p><img src="/../../images/image-20210722112409582.png" alt="image-20210722112409582"></p>
<p>因为显然它在手册中使用的就是8位地址格式（最后一位为读写位）。</p>
</blockquote>
<h4 id="重命名的变量"><a href="#重命名的变量" class="headerlink" title="重命名的变量"></a>重命名的变量</h4><p>API中大部分函数返回值均为VL53L0X_Error类型，这个类型其实是对于有符号字符型的重命名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int8_t</span> VL53L0X_Error;</span><br></pre></td></tr></table></figure>

<p>为了保证类型的一致性，所以在调试看返回值的时候可以同样用这个类型来定义变量来存储返回的错误信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VL53L0X_Error re = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="API常用函数"><a href="#API常用函数" class="headerlink" title="API常用函数"></a>API常用函数</h4><h5 id="设备初始化阶段"><a href="#设备初始化阶段" class="headerlink" title="设备初始化阶段"></a>设备初始化阶段</h5><p>API函数库里面的应用函数很全，但是我们其实也只会用到其中的很小一部分，下面根据调用顺序一一列举：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Wait for device booted after chip enable (hardware standby)</span></span><br><span class="line"><span class="comment"> * This function can be run only when VL53L0X_State is VL53L0X_STATE_POWERDOWN.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function is not Implemented</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Dev      Device Handle</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NOT_IMPLEMENTED Not implemented</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_WaitDeviceBooted</span><span class="params">(VL53L0X_DEV Dev)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>等待设备启动</p>
</blockquote>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief One time device initialization</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To be called once and only once after device is brought out of reset</span></span><br><span class="line"><span class="comment"> * (Chip enable) and booted see @a VL53L0X_WaitDeviceBooted()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @par Function Description</span></span><br><span class="line"><span class="comment"> * When not used after a fresh device &quot;power up&quot; or reset, it may return</span></span><br><span class="line"><span class="comment"> * @a #VL53L0X_ERROR_CALIBRATION_WARNING meaning wrong calibration data</span></span><br><span class="line"><span class="comment"> * may have been fetched from device that can result in ranging offset error\n</span></span><br><span class="line"><span class="comment"> * If application cannot execute device reset or need to run VL53L0X_DataInit</span></span><br><span class="line"><span class="comment"> * multiple time then it  must ensure proper offset calibration saving and</span></span><br><span class="line"><span class="comment"> * restore on its own by using @a VL53L0X_GetOffsetCalibrationData() on first</span></span><br><span class="line"><span class="comment"> * power up and then @a VL53L0X_SetOffsetCalibrationData() in all subsequent init</span></span><br><span class="line"><span class="comment"> * This function will change the VL53L0X_State from VL53L0X_STATE_POWERDOWN to</span></span><br><span class="line"><span class="comment"> * VL53L0X_STATE_WAIT_STATICINIT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function Access to the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Dev                   Device Handle</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NONE     Success</span></span><br><span class="line"><span class="comment"> * @return  &quot;Other error code&quot;    See ::VL53L0X_Error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_DataInit</span><span class="params">(VL53L0X_DEV Dev)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设备初始化函数</p>
<p>注意：只能被调用一次！</p>
</blockquote>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Do basic device init (and eventually patch loading)</span></span><br><span class="line"><span class="comment"> * This function will change the VL53L0X_State from</span></span><br><span class="line"><span class="comment"> * VL53L0X_STATE_WAIT_STATICINIT to VL53L0X_STATE_IDLE.</span></span><br><span class="line"><span class="comment"> * In this stage all default setting will be applied.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function Access to the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Dev                   Device Handle</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NONE     Success</span></span><br><span class="line"><span class="comment"> * @return  &quot;Other error code&quot;    See ::VL53L0X_Error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_StaticInit</span><span class="params">(VL53L0X_DEV Dev)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进行基础设备初始化</p>
</blockquote>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Perform Reference Calibration</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @details Perform a reference calibration of the Device.</span></span><br><span class="line"><span class="comment"> * This function should be run from time to time before doing</span></span><br><span class="line"><span class="comment"> * a ranging measurement.</span></span><br><span class="line"><span class="comment"> * This function will launch a special ranging measurement, so</span></span><br><span class="line"><span class="comment"> * if interrupt are enable an interrupt will be done.</span></span><br><span class="line"><span class="comment"> * This function will clear the interrupt generated automatically.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @warning This function is a blocking function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function Access to the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Dev                  Device Handle</span></span><br><span class="line"><span class="comment"> * @param   pVhvSettings         Pointer to vhv settings parameter.</span></span><br><span class="line"><span class="comment"> * @param   pPhaseCal            Pointer to PhaseCal parameter.</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NONE    Success</span></span><br><span class="line"><span class="comment"> * @return  &quot;Other error code&quot;   See ::VL53L0X_Error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_PerformRefCalibration</span><span class="params">(VL53L0X_DEV Dev,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">uint8_t</span> *pVhvSettings, <span class="keyword">uint8_t</span> *pPhaseCal)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对设备执行校准</p>
</blockquote>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Set Reference Calibration Parameters</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @par Function Description</span></span><br><span class="line"><span class="comment"> * Set Reference Calibration Parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function Access to the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Dev                            Device Handle</span></span><br><span class="line"><span class="comment"> * @param   VhvSettings                    Parameter for VHV</span></span><br><span class="line"><span class="comment"> * @param   PhaseCal                       Parameter for PhaseCal</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NONE              Success</span></span><br><span class="line"><span class="comment"> * @return  &quot;Other error code&quot;             See ::VL53L0X_Error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_SetRefCalibration</span><span class="params">(VL53L0X_DEV Dev,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">uint8_t</span> VhvSettings, <span class="keyword">uint8_t</span> PhaseCal)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对校准中获得的参数进行设置以完成设备的校准</p>
</blockquote>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Performs Reference Spad Management</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @par Function Description</span></span><br><span class="line"><span class="comment"> * The reference SPAD initialization procedure determines the minimum amount</span></span><br><span class="line"><span class="comment"> * of reference spads to be enables to achieve a target reference signal rate</span></span><br><span class="line"><span class="comment"> * and should be performed once during initialization.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function Access to the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function change the device mode to</span></span><br><span class="line"><span class="comment"> * VL53L0X_DEVICEMODE_SINGLE_RANGING</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Dev                          Device Handle</span></span><br><span class="line"><span class="comment"> * @param   refSpadCount                 Reports ref Spad Count</span></span><br><span class="line"><span class="comment"> * @param   isApertureSpads              Reports if spads are of type</span></span><br><span class="line"><span class="comment"> *                                       aperture or non-aperture.</span></span><br><span class="line"><span class="comment"> *                                       1:=aperture, 0:=Non-Aperture</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NONE            Success</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_REF_SPAD_INIT   Error in the Ref Spad procedure.</span></span><br><span class="line"><span class="comment"> * @return  &quot;Other error code&quot;           See ::VL53L0X_Error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_PerformRefSpadManagement</span><span class="params">(VL53L0X_DEV Dev,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">uint32_t</span> *refSpadCount, <span class="keyword">uint8_t</span> *isApertureSpads)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  Set a new device mode</span></span><br><span class="line"><span class="comment"> * @par Function Description</span></span><br><span class="line"><span class="comment"> * Set device to a new mode (ranging, histogram ...)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function doesn&#x27;t Access to the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Dev                   Device Handle</span></span><br><span class="line"><span class="comment"> * @param   DeviceMode            New device mode to apply</span></span><br><span class="line"><span class="comment"> *                                Valid values are:</span></span><br><span class="line"><span class="comment"> *                                VL53L0X_DEVICEMODE_SINGLE_RANGING</span></span><br><span class="line"><span class="comment"> *                                VL53L0X_DEVICEMODE_CONTINUOUS_RANGING</span></span><br><span class="line"><span class="comment"> *                                VL53L0X_DEVICEMODE_CONTINUOUS_TIMED_RANGING</span></span><br><span class="line"><span class="comment"> *                                VL53L0X_DEVICEMODE_SINGLE_HISTOGRAM</span></span><br><span class="line"><span class="comment"> *                                VL53L0X_HISTOGRAMMODE_REFERENCE_ONLY</span></span><br><span class="line"><span class="comment"> *                                VL53L0X_HISTOGRAMMODE_RETURN_ONLY</span></span><br><span class="line"><span class="comment"> *                                VL53L0X_HISTOGRAMMODE_BOTH</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NONE               Success</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_MODE_NOT_SUPPORTED This error occurs when DeviceMode is</span></span><br><span class="line"><span class="comment"> *                                          not in the supported list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_SetDeviceMode</span><span class="params">(VL53L0X_DEV Dev,</span></span></span><br><span class="line"><span class="params"><span class="function">	VL53L0X_DeviceModes DeviceMode)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设定设备工作模式</p>
</blockquote>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Start device measurement</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @details Started measurement will depend on device parameters set through</span></span><br><span class="line"><span class="comment"> * @a VL53L0X_SetParameters()</span></span><br><span class="line"><span class="comment"> * This is a non-blocking function.</span></span><br><span class="line"><span class="comment"> * This function will change the VL53L0X_State from VL53L0X_STATE_IDLE to</span></span><br><span class="line"><span class="comment"> * VL53L0X_STATE_RUNNING.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function Access to the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param   Dev                  Device Handle</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NONE                  Success</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_MODE_NOT_SUPPORTED    This error occurs when</span></span><br><span class="line"><span class="comment"> * DeviceMode programmed with @a VL53L0X_SetDeviceMode is not in the supported</span></span><br><span class="line"><span class="comment"> * list:</span></span><br><span class="line"><span class="comment"> *                                   Supported mode are:</span></span><br><span class="line"><span class="comment"> *                                   VL53L0X_DEVICEMODE_SINGLE_RANGING,</span></span><br><span class="line"><span class="comment"> *                                   VL53L0X_DEVICEMODE_CONTINUOUS_RANGING,</span></span><br><span class="line"><span class="comment"> *                                   VL53L0X_DEVICEMODE_CONTINUOUS_TIMED_RANGING</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_TIME_OUT    Time out on start measurement</span></span><br><span class="line"><span class="comment"> * @return  &quot;Other error code&quot;   See ::VL53L0X_Error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_StartMeasurement</span><span class="params">(VL53L0X_DEV Dev)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>开始执行测量</p>
</blockquote>
<hr>
<h5 id="测量阶段"><a href="#测量阶段" class="headerlink" title="测量阶段"></a>测量阶段</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Retrieve the measurements from device for a given setup</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @par Function Description</span></span><br><span class="line"><span class="comment"> * Get data from last successful Ranging measurement</span></span><br><span class="line"><span class="comment"> * @warning USER should take care about  @a VL53L0X_GetNumberOfROIZones()</span></span><br><span class="line"><span class="comment"> * before get data.</span></span><br><span class="line"><span class="comment"> * PAL will fill a NumberOfROIZones times the corresponding data</span></span><br><span class="line"><span class="comment"> * structure used in the measurement function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function Access to the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Dev                      Device Handle</span></span><br><span class="line"><span class="comment"> * @param   pRangingMeasurementData  Pointer to the data structure to fill up.</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NONE        Success</span></span><br><span class="line"><span class="comment"> * @return  &quot;Other error code&quot;       See ::VL53L0X_Error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_GetRangingMeasurementData</span><span class="params">(VL53L0X_DEV Dev,</span></span></span><br><span class="line"><span class="params"><span class="function">	VL53L0X_RangingMeasurementData_t *pRangingMeasurementData)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取测量值</p>
</blockquote>
<h4 id="模块工作流程"><a href="#模块工作流程" class="headerlink" title="模块工作流程"></a>模块工作流程</h4><p>在数据手册中其实结合API函数库给出了模块推荐的工作流程，如下：</p>
<p>首先是初始化流程：</p>
<p><img src="/images/%E6%BF%80%E5%85%89%E6%B5%8B%E8%B7%9D%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B-1626938862721.png" alt="激光测距初始化流程"></p>
<p>接下来是测量流程：</p>
<p><img src="/images/%E6%BF%80%E5%85%89%E6%B5%8B%E8%B7%9D%E6%B5%8B%E9%87%8F%E6%B5%81%E7%A8%8B-1626938867288.png" alt="激光测距测量流程"></p>
<p>API使用举例（main.c）：</p>
<p><strong>环境：STM32F401CCU6+CubeMX+HAL</strong></p>
<p>在100Hz定时器中进行测量，并将测量标志位置一，然后在主循环中将获得的测量数据使用串口打印出来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN Header */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file           : main.c</span></span><br><span class="line"><span class="comment">  * @brief          : Main program body</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @attention</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2021 STMicroelectronics.</span></span><br><span class="line"><span class="comment">  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * This software component is licensed by ST under BSD 3-Clause license,</span></span><br><span class="line"><span class="comment">  * the &quot;License&quot;; You may not use this file except in compliance with the</span></span><br><span class="line"><span class="comment">  * License. You may obtain a copy of the License at:</span></span><br><span class="line"><span class="comment">  *                        opensource.org/licenses/BSD-3-Clause</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">/* USER CODE END Header */</span></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;i2c.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private includes ----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdarg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vl53l0x_api.h&quot;</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private typedef -----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PTD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END PTD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private define ------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PD */</span></span><br><span class="line"><span class="comment">/* USER CODE END PD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private macro -------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PM */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log UART_printf</span></span><br><span class="line"><span class="comment">/* USER CODE END PM */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables ---------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line">VL53L0X_RangingMeasurementData_t RangingData;</span><br><span class="line">VL53L0X_Dev_t Dev = &#123;</span><br><span class="line">        .I2cHandle=&amp;hi2c1,</span><br><span class="line">        .I2cDevAddr=<span class="number">0x52</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint8_t</span> TofDataRead;</span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes -----------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SystemClock_Config</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PFP */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART_printf</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">VL53L0X_Error re = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* USER CODE END PFP */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private user code ---------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  The application entry point.</span></span><br><span class="line"><span class="comment">  * @retval int</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 1 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> refSpadCount;</span><br><span class="line">    <span class="keyword">uint8_t</span> isApertureSpads;</span><br><span class="line">    <span class="keyword">uint8_t</span> VhvSettings;</span><br><span class="line">    <span class="keyword">uint8_t</span> PhaseCal;</span><br><span class="line">    <span class="comment">/* USER CODE END 1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MCU Configuration--------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span></span><br><span class="line">    HAL_Init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN Init */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE END Init */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Configure the system clock */</span></span><br><span class="line">    SystemClock_Config();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN SysInit */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE END SysInit */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line">    MX_GPIO_Init();</span><br><span class="line">    MX_I2C1_Init();</span><br><span class="line">    MX_TIM3_Init();</span><br><span class="line">    MX_USART1_UART_Init();</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_15, GPIO_PIN_RESET); <span class="comment">// Disable XSHUT</span></span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_15, GPIO_PIN_SET); <span class="comment">// Enable XSHUT</span></span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    HAL_NVIC_DisableIRQ(TIM3_IRQn);</span><br><span class="line"></span><br><span class="line">    re = VL53L0X_WaitDeviceBooted(&amp;Dev);</span><br><span class="line">    <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;%d\n&quot;</span>, re);</span><br><span class="line">    re = VL53L0X_DataInit(&amp;Dev);</span><br><span class="line">    <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;%d\n&quot;</span>, re);</span><br><span class="line">    re = VL53L0X_StaticInit(&amp;Dev);</span><br><span class="line">    <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;%d\n&quot;</span>, re);</span><br><span class="line">    re = VL53L0X_PerformRefCalibration(&amp;Dev, &amp;VhvSettings, &amp;PhaseCal);</span><br><span class="line">    <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;%d\n&quot;</span>, re);</span><br><span class="line">    re = VL53L0X_SetRefCalibration(&amp;Dev, VhvSettings, PhaseCal);</span><br><span class="line">    <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;%d\n&quot;</span>, re);</span><br><span class="line">    re = VL53L0X_PerformRefSpadManagement(&amp;Dev, &amp;refSpadCount, &amp;isApertureSpads);</span><br><span class="line">    <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;%d\n&quot;</span>, re);</span><br><span class="line">    re = VL53L0X_SetDeviceMode(&amp;Dev, VL53L0X_DEVICEMODE_CONTINUOUS_RANGING);</span><br><span class="line">    <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;%d\n&quot;</span>, re);</span><br><span class="line">    re = VL53L0X_StartMeasurement(&amp;Dev);</span><br><span class="line">    <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;%d\n\n&quot;</span>, re);</span><br><span class="line"></span><br><span class="line">    HAL_NVIC_EnableIRQ(TIM3_IRQn);</span><br><span class="line">    <span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Infinite loop */</span></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">    HAL_TIM_Base_Start_IT(&amp;htim3);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TofDataRead == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;Measured distance: %i\n\r&quot;</span>, RangingData.RangeMilliMeter);</span><br><span class="line">            TofDataRead = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief System Clock Configuration</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SystemClock_Config</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    RCC_OscInitTypeDef RCC_OscInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    RCC_ClkInitTypeDef RCC_ClkInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Configure the main internal regulator output voltage</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    __HAL_RCC_PWR_CLK_ENABLE();</span><br><span class="line">    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);</span><br><span class="line">    <span class="comment">/** Initializes the RCC Oscillators according to the specified parameters</span></span><br><span class="line"><span class="comment">    * in the RCC_OscInitTypeDef structure.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;</span><br><span class="line">    RCC_OscInitStruct.HSEState = RCC_HSE_ON;</span><br><span class="line">    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;</span><br><span class="line">    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;</span><br><span class="line">    RCC_OscInitStruct.PLL.PLLM = <span class="number">25</span>;</span><br><span class="line">    RCC_OscInitStruct.PLL.PLLN = <span class="number">168</span>;</span><br><span class="line">    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;</span><br><span class="line">    RCC_OscInitStruct.PLL.PLLQ = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) &#123;</span><br><span class="line">        Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Initializes the CPU, AHB and APB buses clocks</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK</span><br><span class="line">                                  | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;</span><br><span class="line">    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;</span><br><span class="line">    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;</span><br><span class="line">    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;</span><br><span class="line">    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) &#123;</span><br><span class="line">        Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 4 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (htim3.Instance == TIM3) &#123;</span><br><span class="line">        VL53L0X_GetRangingMeasurementData(&amp;Dev, &amp;RangingData);</span><br><span class="line"><span class="comment">//        VL53L0X_ClearInterruptMask(&amp;Dev, VL53L0X_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY);</span></span><br><span class="line">        TofDataRead = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART_printf</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    length = vsnprintf(buffer, <span class="number">128</span>, fmt, ap);</span><br><span class="line"></span><br><span class="line">    HAL_UART_Transmit(huart, (<span class="keyword">uint8_t</span> *) buffer, length, HAL_MAX_DELAY);</span><br><span class="line"></span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 4 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  This function is executed in case of error occurrence.</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Error_Handler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN Error_Handler_Debug */</span></span><br><span class="line">    <span class="comment">/* User can add his own implementation to report the HAL error return state */</span></span><br><span class="line">    __disable_irq();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* USER CODE END Error_Handler_Debug */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  USE_FULL_ASSERT</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Reports the name of the source file and the source line number</span></span><br><span class="line"><span class="comment">  *         where the assert_param error has occurred.</span></span><br><span class="line"><span class="comment">  * @param  file: pointer to the source file name</span></span><br><span class="line"><span class="comment">  * @param  line: assert_param error line source number</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert_failed</span><span class="params">(<span class="keyword">uint8_t</span> *file, <span class="keyword">uint32_t</span> line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 6 */</span></span><br><span class="line">  <span class="comment">/* User can add his own implementation to report the file name and line number,</span></span><br><span class="line"><span class="comment">     ex: printf(&quot;Wrong parameters value: file %s on line %d\r\n&quot;, file, line) */</span></span><br><span class="line">  <span class="comment">/* USER CODE END 6 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_FULL_ASSERT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>设备初始化的时候不要开中断！！！</li>
<li>注意XShut的连接方式，如果和主设备连接了，则需要在测量之前进行唤醒操作。</li>
</ul>
<h2 id="关于API的移植"><a href="#关于API的移植" class="headerlink" title="关于API的移植"></a>关于API的移植</h2><p>挖坑，以后填……</p>
]]></content>
      <categories>
        <category>硬件</category>
        <category>模块</category>
      </categories>
      <tags>
        <tag>VL53L0X</tag>
      </tags>
  </entry>
  <entry>
    <title>记我与机械键盘的一次斗争</title>
    <url>/2021/06/16/%E8%AE%B0%E6%88%91%E4%B8%8E%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E6%AC%A1%E6%96%97%E4%BA%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参加了一个DIY机械键盘的活动，虽然很想自己做一个机械键盘，但是奈何我已经有了一把键盘，再加上经费有限，最终还是没有做。不过我看上凯华的BOX白好久了，于是便借着这次机会换一波轴体。</p>
<span id="more"></span>

<h2 id="一个有趣的小故事"><a href="#一个有趣的小故事" class="headerlink" title="一个有趣的小故事"></a>一个有趣的小故事</h2><p>首先有了换轴的想法之后当然是首先关心一下自己的轴能不能热插拔，于是到当初买轴的地方看了看：</p>
<p><img src="/images/%E8%AE%B0%E6%88%91%E4%B8%8E%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E6%AC%A1%E6%96%97%E4%BA%89/Screenshot_2021-06-16-18-04-46-628_com.taobao.tao-1623901120401.jpg" alt="Screenshot_2021-06-16-18-04-46-628_com.taobao.tao"></p>
<p>好家伙！我直接狂喜！</p>
<p>于是了解了一下拔轴的方法之后就开始自己操作了。</p>
<p>首先是<strong>拔下键帽</strong>：</p>
<p>我使出上古洪荒之力，终于在不借助任何工具的情况下拔下了所有键帽：</p>
<p><img src="/images/%E8%AE%B0%E6%88%91%E4%B8%8E%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E6%AC%A1%E6%96%97%E4%BA%89/1623837920254-1623901133530.jpg" alt="1623837920254"></p>
<p>接着开始拔轴：</p>
<p><strong>用拔轴器分别对准轴体上面和下面的两个卡口，将卡口按下后用力即可将轴体拔出。</strong></p>
<p>念叨着拔轴的诀窍，我拔下了一个又一个轴。</p>
<p>看这拔完轴后剩下的“轴座”，果然是极致的省钱了啊：</p>
<p><img src="/images/%E8%AE%B0%E6%88%91%E4%B8%8E%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E6%AC%A1%E6%96%97%E4%BA%89/65a29b1cacae971c.-1623901149985.jpg" alt="65a29b1cacae971c."></p>
<blockquote>
<ul>
<li>1mm的鸡铜眼作为轴座，可谓是将可拓展空间降低到了极致，这种方案也算是热插拔方案里面最不能热插拔了。</li>
<li>灯用的就是最普通的反贴白色二极管，也是省钱首选。</li>
<li>没有做任何的其他轴体的适应孔位，真就铁了心用这个省钱的方案。</li>
</ul>
</blockquote>
<p>后来拔着拔着发现：<strong>居然有的轴是拔不下来的！！！</strong></p>
<p><img src="/images/%E8%AE%B0%E6%88%91%E4%B8%8E%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E6%AC%A1%E6%96%97%E4%BA%89/Cache_-1eec80bc2896130a.-1623901159717.jpg" alt="Cache_-1eec80bc2896130a."></p>
<p>开始我天真的以为是因为轴体卡的太紧导致无法拔出。</p>
<p>于是我开始期待大力出奇迹，可是无论我如何大力都没有奇迹出现。</p>
<p>后来我就抱着破罐子破摔的心态直接用钳子对其中的一个轴体做了毁灭性的拔除，结果发现了个惊天大秘密！</p>
<p><img src="/images/%E8%AE%B0%E6%88%91%E4%B8%8E%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E6%AC%A1%E6%96%97%E4%BA%89/Cache_-65a29b1cacae971c.-1623901168601.jpg" alt="Cache_-65a29b1cacae971c."></p>
<p>轴下面的电路板上面根本就连鸡铜眼都没有，轴上面断掉的引脚还在焊盘上留着。当然我也考虑过会不会是鸡铜眼被我带掉了的情况，因此抱着严谨的态度我拆掉了键盘，打算看一下背面PCB的焊点。</p>
<p>结果果然和我想得一模一样：这把键盘不但轴座上采用了最省钱的鸡铜眼方案，而且<strong>甚至连鸡铜眼都没有完全的采用</strong>，而是反人类的“半热插拔”（就是<strong>一半轴下面有鸡铜眼，另一半轴下方则是将引脚直接焊接上去的</strong>）</p>
<p>只需要看一下焊盘就可以看得出来：</p>
<p><img src="/images/%E8%AE%B0%E6%88%91%E4%B8%8E%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E6%AC%A1%E6%96%97%E4%BA%89/1623837911991-1623901177190.jpg" alt="1623837911991"></p>
<p>鸡铜眼下方的<strong>焊点头部圆润饱满</strong>，这是由于鸡铜眼本身比较粗的缘故，但是引脚焊接是绝对焊不出这种头部的。</p>
<p>下面我们来看看拔不下来的轴下面的焊点：</p>
<p><img src="/images/%E8%AE%B0%E6%88%91%E4%B8%8E%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E6%AC%A1%E6%96%97%E4%BA%89/1623837905852-1623901184851.jpg" alt="1623837905852"></p>
<p>焊点头部明显是<strong>尖的</strong>，仔细看还能看出引脚的形状。后续用烙铁融化焊盘上的锡浆之后用吸锡器将它吸干净，<strong>可以清楚的看到轴体引脚上面的锡浆。</strong></p>
<p>好了无良商家实锤了。</p>
<p>但是该换的轴还是要换的，最后我还是花了半个下午的时间将原本的轴体拆焊了下来并且将原本的鸡铜眼拆焊下来（主要是由于原本1mm的鸡铜眼小于凯华的轴座引脚直径，导致凯华轴座没法完美的插进去，想着反正都要焊接的，就直接一次性全部解决了吧。），最后将轴体焊接上去，最终完成了轴体的更换。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>机械键盘这东西和很多东西一样，一分钱一分货。大家一定不要像我一样图便宜最终买到了虚假宣传的产品，虽然问题的解决很简单，但是其中浪费的时间成本终究还是得不偿失的。</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>DIY</tag>
      </tags>
  </entry>
  <entry>
    <title>HAL库基本函数</title>
    <url>/2021/05/17/HAL%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知道写啥了，但还是要有一个前言的。</p>
<p><del>摸鱼的时候不知道该干点啥，那就写一篇博客吧！</del></p>
<p>大概就是记录一下自己用的时候遇到的坑吧（正经脸）？</p>
<span id="more"></span>

<p>坑已留，摸鱼时填。</p>
<h2 id="GPIO函数"><a href="#GPIO函数" class="headerlink" title="GPIO函数"></a>GPIO函数</h2><h2 id="定时器函数"><a href="#定时器函数" class="headerlink" title="定时器函数"></a>定时器函数</h2><h2 id="UART函数"><a href="#UART函数" class="headerlink" title="UART函数"></a>UART函数</h2><h2 id="IIC函数"><a href="#IIC函数" class="headerlink" title="IIC函数"></a>IIC函数</h2><h2 id="SPI函数"><a href="#SPI函数" class="headerlink" title="SPI函数"></a>SPI函数</h2>]]></content>
      <categories>
        <category>单片机</category>
        <category>STM32</category>
        <category>函数库</category>
      </categories>
      <tags>
        <tag>函数库</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP432学习笔记</title>
    <url>/2021/05/13/MSP432%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于积分赛限制了控制器，因此不能使用我们熟悉的STM32来进行开发，所以选择了MSP432作为控制器，并且也将从头学习一下MSP432。</p>
<blockquote>
<p>附完成的工程地址：</p>
<p><a href="https://wws.lanzoui.com/iseTCpmf4kb">https://wws.lanzoui.com/iseTCpmf4kb</a> </p>
</blockquote>
<span id="more"></span>

<p>这里是后期的我自己，文章的正文是在学习过程中随着进度一点一点写出来的，现在作品完成的接近尾声了，但是我觉得自己的了解并不够多，先说说自己的感受吧。</p>
<p>首先最大的感受就是使用TI的SDK库函数的时候的陌生感。这里就不得不对比一下HAL库和SDK了：</p>
<p>首先HAL给人最直观的感受就是封装度高，更适合新手上手，上手起来也很快。但是这也同样是HAL库的缺点。</p>
<p>在使用HAL库的时候，让人真的觉得就是在“使用”。因为你不知道里面干了什么，怎么干的，HAL的封装在你的面前就是一个巨大的黑盒子，使用的时候他在刻意的引导着我们让我们只关心“能用就行”，却忽略了背后的一些机制和原理。这不是HAL的问题，HAL的初心就是让程序员能脱离在机械化的初始化中浪费的时间，但是有一个巨大的前提—-这个程序员懂得其中的原理。而向我们这样的新手在用的时候就真的只会关心“能用就行”。</p>
<p>SDK则不一样，很多东西在不摸懂其中的原理之前是没办法调通的，这就逼迫着你去不断地翻阅参考手册、翻阅库函数手册、查资料等等，无形中增加了学习的深度以及对于原理的理解。</p>
<p>懂得不多，感受大概就这些，下面是正文。 </p>
<h2 id="系统时钟树以及滴答时钟"><a href="#系统时钟树以及滴答时钟" class="headerlink" title="系统时钟树以及滴答时钟"></a>系统时钟树以及滴答时钟</h2><h3 id="System-Timer-SysTick-—-系统滴答时钟"><a href="#System-Timer-SysTick-—-系统滴答时钟" class="headerlink" title="System Timer (SysTick)—-系统滴答时钟"></a>System Timer (SysTick)—-系统滴答时钟</h3><blockquote>
<p><strong>需要知道的内容：</strong></p>
<ul>
<li><p>Systick内部含有一个24位计数器，计数器最大值为1&lt;&lt;24</p>
</li>
<li><p>Systick计数频率等于系统主频（MCLK）</p>
</li>
<li><p>Systick计数器的计数方式为递减计数</p>
</li>
<li><p>Systick共含有三个寄存器功能分别如下：</p>
<ul>
<li>SysTick Control and Status Register (STCSR): A control and status register to configure its clock,enable the counter, enable the SysTick interrupt, and determine counter status.</li>
</ul>
<p>（系统设置寄存器即SysTick-&gt;CTRL）</p>
<ul>
<li>SysTick Reload Value Register (STRVR): The reload value for the counter, used to provide the counter’s wrap value.</li>
</ul>
<p>（计数周期寄存器即SysTick-&gt;LOAD，LOAD值等于period-1）</p>
<ul>
<li>SysTick Current Value Register (STCVR): The current value of the counter.  </li>
</ul>
<p>（当前计数值寄存器即SysTick-&gt;VAL）</p>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暂停看门狗</span></span><br><span class="line">WDT_A_holdTimer( <span class="keyword">void</span> );</span><br><span class="line"><span class="comment">//使能浮点运算单元</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FPU_enableModule</span> <span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*常用Systick相关函数*/</span></span><br><span class="line"><span class="comment">//SysTick使失能函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_enableModule</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_disableModule</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//SysTick中断使失能函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_enableInterrupt</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_disableInterrupt</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//获取Counter周期、当前值函数</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">SysTick_getPeriod</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">SysTick_getValue</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//设定Counter周期函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_setPeriod</span> <span class="params">(<span class="keyword">uint32_t</span> period)</span></span>;</span><br><span class="line"><span class="comment">//注册注销SysTick中断向量函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_registerInterrupt</span> <span class="params">(<span class="keyword">void</span>(∗intHandler)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_unregisterInterrupt</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="系统时钟树"><a href="#系统时钟树" class="headerlink" title="系统时钟树"></a>系统时钟树</h3><blockquote>
<p>  <strong>需要知道的内容：</strong></p>
<p>  **clock resources（时钟源）:  **</p>
<p>  • LFXTCLK: <strong>Low-frequency oscillator</strong> (LFXT) that can be used either with low-frequency 32768-Hz watch crystals, standard crystals, resonators, or external clock sources in the 32-kHz or below range. When in bypass mode, LFXTCLK can be driven with an external square wave signal in the 32-kHz or below range.</p>
<p>  （ <strong>低频振荡器</strong>（LFXT）可以与32kHz或以下范围的低频32768-Hz手表晶体，标准晶体，谐振器或外部时钟源一起使用。 在旁路模式下，可以使用32kHz或更低范围内的外部方波信号来驱动LFXTCLK。 ）</p>
<p>  • HFXTCLK: **High-frequency oscillator **(HFXT) that can be used with standard crystals or resonators in the 1-MHz to 48-MHz range. When in bypass mode, HFXTCLK can be driven with an external square wave signal.</p>
<p>  （ <strong>高频振荡器</strong>（HFXT），可与1MHz至48MHz范围内的标准晶体或谐振器一起使用。 在旁路模式下，可以使用外部方波信号驱动HFXTCLK。 ）</p>
<p>  • DCOCLK: <strong>Internal digitally controlled oscillator</strong> (DCO) with programmable frequencies and 3-MHz frequency by default</p>
<p>  （ <strong>内部数控振荡器</strong>（DCO），默认情况下具有可编程频率和3 MHz频率 ）</p>
<p>  • VLOCLK: <strong>Internal very-low-power low-frequency oscillator</strong> (VLO) with 9.4-kHz typical frequency</p>
<p>  （ <strong>内部超低功耗低频振荡器</strong>（VLO），典型频率为9.4kHz ）</p>
<p>  • REFOCLK : <strong>Internal, low-power low-frequency oscillator</strong> (REFO) with selectable 32.768-kHz or 128-kHz typical frequencies</p>
<p>  （ <strong>内部低功耗低频振荡器</strong>（REFO），具有可选的32.768 kHz或128 kHz典型频率 ）</p>
<p>  • MODCLK: <strong>Internal low-power oscillator</strong> with 25-MHz typical frequency</p>
<p>  （ <strong>内部低功耗振荡器</strong>，典型频率为25MHz ）</p>
<p>  • SYSOSC: <strong>Internal oscillator</strong> with 5-MHz typical frequency  </p>
<p>  （ <strong>内部振荡器</strong>，具有5-MHz典型频率 ）</p>
<p>  <strong>system clock signals（时钟信号）:</strong>    </p>
<p>  •ACLK: <strong>Auxiliary clock</strong>. ACLK is software selectable as LFXTCLK, VLOCLK, or REFOCLK. ACLK can be divided by 1, 2, 4, 8, 16, 32, 64, or 128. ACLK is software selectable by individual peripheral modules. ACLK is restricted to maximum frequency of operation of 128 kHz.</p>
<p>  ( <strong>辅助时钟</strong>。 ACLK可通过软件选择为LFXTCLK，VLOCLK或REFOCLK。 ACLK可以除以1、2、4、8、16、32、64或128。ACLK是可由各个外围模块选择的软件。 ACLK的最大工作频率限制为128 kHz。 )</p>
<p>  • MCLK: <strong>Master clock</strong>. MCLK is software selectable as LFXTCLK, VLOCLK, REFOCLK, DCOCLK,MODCLK, or HFXTCLK. MCLK can be divided by 1, 2, 4, 8, 16, 32, 64, or 128. MCLK is used by the CPU and peripheral module interfaces, as well as, used directly by some peripheral modules.</p>
<p>  ( <strong>主时钟</strong>。 MCLK可通过软件选择为LFXTCLK，VLOCLK，REFOCLK，DCOCLK，MODCLK或HFXTCLK。 MCLK可以除以1、2、4、8、16、32、64或128。MCLK由CPU和外围模块接口使用，以及直接由某些外围模块使用。 )</p>
<p>  • HSMCLK: <strong>Subsystem master clock</strong>. HSMCLK is software selectable as LFXTCLK, VLOCLK,REFOCLK, DCOCLK, MODCLK, HFXTCLK. HSMCLK can be divided by 1, 2, 4, 8, 16, 32, 64, or 128.HSMCLK is software selectable by individual peripheral modules.</p>
<p>  ( <strong>子系统主时钟</strong>。 HSMCLK可以选择为LFXTCLK，VLOCLK，REFOCLK，DCOCLK，MODCLK，HFXTCLK。 HSMCLK可以被1、2、4、8、16、32、64或128分频。HSMCLK是可由各个外围模块选择的软件。 )</p>
<p>  • SMCLK: <strong>Low-speed subsystem master clock</strong>. SMCLK uses the HSMCLK clock resource selection for its clock resource. SMCLK can be divided independently from HSMCLK by 1, 2, 4, 8, 16, 32, 64, or 128. SMCLK is limited in frequency to half of the rated maximum frequency of HSMCLK. SMCLK is software selectable by individual peripheral modules.</p>
<p>  (<strong>低速子系统主时钟</strong>。 SMCLK将HSMCLK时钟资源选择用于其时钟资源。 可以将SMCLK与HSMCLK分别分频为1、2、4、8、16、32、64或128。SMCLK的频率限制为HSMCLK额定最大频率的一半。 SMCLK是可由各个外围模块选择的软件。)    </p>
<p>  • BCLK:<strong>Low-speed backup domain clock</strong>. BCLK is software selectable as LFXTCLK and REFOCLK and is used primarily in the backup domain. BCLK is restricted to a maximum frequency of 32.768 kHz.  </p>
<p>  ( <strong>低速备份域时钟</strong>。 BCLK是软件可选的LFXTCLK和REFOCLK，主要用于备份域。 BCLK的最大频率限制为32.768 kHz。 )<img src="/images/MSP432%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1622276050150.png" alt="1622276050150"></p>
</blockquote>
<p>上述为MSP432时钟系统介绍的截图，为了便于区分已经利用不同的颜色标出了不同的时钟总线。</p>
<p>根据上图可总结出如下时钟信号和时钟源的关系：</p>
<table>
<thead>
<tr>
<th align="center">时钟源\时钟信号</th>
<th align="center">ACLK</th>
<th align="center">MCLK</th>
<th align="center">HSMCLK</th>
<th align="center">SMCLK</th>
<th align="center">BCLK</th>
<th align="center">能否直接被其他外设使用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>LFXTCLK</strong></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><strong>VLO</strong></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">-</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><strong>REFO</strong></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><strong>DCOCLK</strong></td>
<td align="center">-</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><strong>MODOSC</strong></td>
<td align="center">-</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">-</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><strong>HFXTCLK</strong></td>
<td align="center">-</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><strong>SYSOSC</strong></td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h3 id="常用系统时钟函数"><a href="#常用系统时钟函数" class="headerlink" title="常用系统时钟函数"></a>常用系统时钟函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*常用时钟树相关函数*/</span></span><br><span class="line"><span class="comment">//获取各种外部时钟源的频率（用于调试时钟树很方便）</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">CS_getACLK</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">CS_getBCLK</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">CS_getHSMCLK</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">CS_getMCLK</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">CS_getSMCLK</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//时钟信号初始化（用于设置时钟分频）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CS_initClockSignal</span><span class="params">(<span class="keyword">uint32_t</span> selectedClockSignal, <span class="keyword">uint32_t</span> clockSource, <span class="keyword">uint32_t</span> clockSourceDivider)</span></span>;</span><br><span class="line"><span class="comment">//设置DCOCLK频率范围中心（简单确定DCOCLK频率范围，后面需要加上一个频率设置函数确定具体频率）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CS_setDCOCenteredFrequency</span> <span class="params">(<span class="keyword">uint32_t</span> dcoFreq)</span></span>;</span><br><span class="line"><span class="comment">//设置DCOCLK频率值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CS_setDCOFrequency</span> <span class="params">(<span class="keyword">uint32_t</span> dcoFrequency)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="Digital-I-O（数字输入输出）"><a href="#Digital-I-O（数字输入输出）" class="headerlink" title="Digital I/O（数字输入输出）"></a>Digital I/O（数字输入输出）</h2><h3 id="Digital-I-O介绍"><a href="#Digital-I-O介绍" class="headerlink" title="Digital I/O介绍"></a>Digital I/O介绍</h3><p>虽然名字不同，但是和STM中的GPIO几乎完全相同。</p>
<p>甚至在DriverLib库的手册中直接用了GPIO的写法<del>（诶，我们不装了，摊牌了，就是一样的！）</del></p>
<p>不过有一点值得注意的是一个叫做外设GPIO的东西，它其实和GPIO完全不是一个东西。通俗的讲其实它是为其他的需要引脚来进行输入输出的外设选择了其需要的引脚并配置为相应的模式。例如IIC、SPI、PWM等等。</p>
<p>正是因此所以前面我说的内容其实并不严谨。应该是说：在<strong>通用输入输出功能</strong>上，他们虽然名字不同，但是和STM中的GPIO几乎完全相同。</p>
<p>但是仔细想一下，这两个手册中表现出的理解似乎并不一样：GPIO更像是<strong>功能性的叙述</strong>，说明该功能为通用输入输出；Digital I/O更像是<strong>硬件上的描述</strong>，只要是需要进行“数字输入输出“的功能都需要用到Digital I/O。</p>
<p>至于DriverLib中的相关函数，我对它们的评价是：通俗易懂。</p>
<p>真的就通俗易懂到只要翻译一下名字就知道是干什么的程度。</p>
<h3 id="常用GPIO函数汇总"><a href="#常用GPIO函数汇总" class="headerlink" title="常用GPIO函数汇总"></a>常用GPIO函数汇总</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GPIO模式设置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_setAsOutputPin</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort,<span class="keyword">uint_fast16_t</span> selectedPins)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_setAsInputPin</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span> selectedPins)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_setAsInputPinWithPullDownResistor</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">uint_fast16_t</span> selectedPins)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_setAsInputPinWithPullUpResistor</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">uint_fast16_t</span> selectedPins)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外设GPIO设置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_setAsPeripheralModuleFunctionInputPin</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort,<span class="keyword">uint_fast16_t</span> selectedPins,<span class="keyword">uint_fast8_t</span> mode)</span></span>;<span class="comment">//模式参数：GPIO_PRIMARY_MODULE_FUNCTION/GPIO_SECONDARY_MODULE_FUNCTION/GPIO_TERTIARY_MODULE_FUNCTION</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_setAsPeripheralModuleFunctionOutputPin</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort,<span class="keyword">uint_fast16_t</span> selectedPins,<span class="keyword">uint_fast8_t</span> mode)</span></span>;<span class="comment">//模式参数：GPIO_PRIMARY_MODULE_FUNCTION/GPIO_SECONDARY_MODULE_FUNCTION/GPIO_TERTIARY_MODULE_FUNCTION</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO输出设置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_setOutputHighOnPin</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">selectedPins)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_setOutputLowOnPin</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">selectedPins)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_toggleOutputOnPin</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">selectedPins)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO输入读取</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">GPIO_getInputPinValue</span> <span class="params">( <span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">selectedPins )</span></span>;<span class="comment">//返回：GPIO_INPUT_PIN_HIGH/GPIO_INPUT_PIN_LOW</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//GPIO中断设置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_clearInterruptFlag</span> <span class="params">( <span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">selectedPins )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_disableInterrupt</span> <span class="params">( <span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">selectedPins )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_enableInterrupt</span> <span class="params">( <span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">selectedPins )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_interruptEdgeSelect</span> <span class="params">( <span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">selectedPins, <span class="keyword">uint_fast8_t</span> edgeSelect )</span></span>;<span class="comment">//模式参数：GPIO_HIGH_TO_LOW_TRANSITION/GPIO_LOW_TO_HIGH_TRANSITION</span></span><br><span class="line"><span class="function"><span class="keyword">uint_fast16_t</span> <span class="title">GPIO_getEnabledInterruptStatus</span> <span class="params">( <span class="keyword">uint_fast8_t</span> selectedPort )</span></span>;<span class="comment">//返回端口引脚的逻辑或结果</span></span><br><span class="line"><span class="comment">//中断向量处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_registerInterrupt</span> <span class="params">( <span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">void</span>(∗)(<span class="keyword">void</span>) intHandler )</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_unregisterInterrupt</span> <span class="params">( <span class="keyword">uint_fast8_t</span> selectedPort )</span></span>;<span class="comment">//注销中断向量</span></span><br></pre></td></tr></table></figure>

<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="定时器介绍"><a href="#定时器介绍" class="headerlink" title="定时器介绍"></a>定时器介绍</h3><p>我认为MSP432与ST的定时器区别最大的地方在于它将32位定时器和16位定时器分开来，将PWM的功能仅仅赋予16位定时器。</p>
<p>本次比赛并未用到过32位定时器，因此我也不好多说，此处介绍我们用到的16位定时器的部分功能。</p>
<blockquote>
<p><strong>需要知道的东西：</strong></p>
<ul>
<li>定时器模块图：</li>
</ul>
<p><img src="/images/MSP432%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1622468114640.png" alt="1622468114640"></p>
<ul>
<li><p>UPMODE是从0计数到CCR0</p>
</li>
<li><p>UPDOWNMODE是先递增计数到CCR0再递减计数到0，其中CCR0=period*1/2</p>
</li>
<li><p>CONTINOUSMODE是从0计数到0xFFFF</p>
</li>
<li><p>定时器中并没有影子寄存器的说法，但是其实官方默认是具有类似ST中影子寄存器的功能的：</p>
<ul>
<li>UPMODE中的说明：</li>
</ul>
</li>
</ul>
<p> <img src="/images/MSP432%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1622467994167.png" alt="1622467994167"></p>
<ul>
<li>UPDOWNMODE中的说明：</li>
</ul>
<p> <img src="/images/MSP432%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1622468221716.png" alt="1622468221716"></p>
</blockquote>
<h3 id="定时器函数"><a href="#定时器函数" class="headerlink" title="定时器函数"></a>定时器函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*相关结构体*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Timer_A_ContinuousModeConfig</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockSource;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockSourceDivider;</span><br><span class="line">    <span class="comment">//注意：此处的分频是指在主频经过分频后得到的对应时钟频率的基础上进行分频</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerInterruptEnable_TAIE;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerClear;</span><br><span class="line">&#125; Timer_A_ContinuousModeConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Timer_A_UpDownModeConfig</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockSource;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockSourceDivider;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerPeriod;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerInterruptEnable_TAIE;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> captureCompareInterruptEnable_CCR0_CCIE;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerClear;</span><br><span class="line">&#125; Timer_A_UpDownModeConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Timer_A_UpModeConfig</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockSource;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockSourceDivider;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerPeriod;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerInterruptEnable_TAIE;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> captureCompareInterruptEnable_CCR0_CCIE;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerClear;</span><br><span class="line">&#125; Timer_A_UpModeConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Timer_A_PWMConfig</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockSource;</span><br><span class="line">    <span class="comment">//TIMER_A_CLOCKSOURCE_EXTERNAL_TXCLK</span></span><br><span class="line">    <span class="comment">//TIMER_A_CLOCKSOURCE_ACLK</span></span><br><span class="line">    <span class="comment">//TIMER_A_CLOCKSOURCE_SMCLK</span></span><br><span class="line">	<span class="comment">//TIMER_A_CLOCKSOURCE_INVERTED_EXTERNAL_TXCLK</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockSourceDivider;</span><br><span class="line">    <span class="comment">//TIMER_A_CLOCKSOURCE_DIVIDER_1，2，3，4，5，6，7，8，10，12，14</span></span><br><span class="line">    <span class="comment">//TIMER_A_CLOCKSOURCE_DIVIDER_16，20，24，28，32，40，48，56，64</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerPeriod;</span><br><span class="line">    <span class="comment">//selects the desired timer period</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> compareRegister;</span><br><span class="line">    <span class="comment">//TIMER_A_CAPTURECOMPARE_REGISTER_0，1，2，3，4，5，6</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> compareOutputMode;</span><br><span class="line">    <span class="comment">//TIMER_A_OUTPUTMODE_OUTBITVALUE,</span></span><br><span class="line">    <span class="comment">//TIMER_A_OUTPUTMODE_SET,</span></span><br><span class="line">    <span class="comment">//TIMER_A_OUTPUTMODE_TOGGLE_RESET,</span></span><br><span class="line">    <span class="comment">//TIMER_A_OUTPUTMODE_SET_RESET</span></span><br><span class="line">    <span class="comment">//TIMER_A_OUTPUTMODE_TOGGLE,</span></span><br><span class="line">    <span class="comment">//TIMER_A_OUTPUTMODE_RESET,</span></span><br><span class="line">    <span class="comment">//TIMER_A_OUTPUTMODE_TOGGLE_SET,</span></span><br><span class="line">    <span class="comment">//TIMER_A_OUTPUTMODE_RESET_SET</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> dutyCycle;</span><br><span class="line">    <span class="comment">//specifies the dutycycle for the generated waveform</span></span><br><span class="line">&#125; Timer_A_PWMConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*相关函数*/</span></span><br><span class="line"><span class="comment">//三种计数模式配置函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_configureContinuousMode</span> <span class="params">(<span class="keyword">uint32_t</span> timer, <span class="keyword">const</span> Timer_A_ContinuousModeConfig ∗config)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_configureUpDownMode</span> <span class="params">(<span class="keyword">uint32_t</span> timer, <span class="keyword">const</span> Timer_A_UpDownModeConfig　∗config)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_configureUpMode</span> <span class="params">(<span class="keyword">uint32_t</span> timer, <span class="keyword">const</span> Timer_A_UpModeConfig ∗config)</span></span>;</span><br><span class="line"><span class="comment">//PWM相关函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_generatePWM</span> <span class="params">(<span class="keyword">uint32_t</span> timer, <span class="keyword">const</span> Timer_A_PWMConfig ∗config)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_setCompareValue</span> <span class="params">(<span class="keyword">uint32_t</span> timer, <span class="keyword">uint_fast16_t</span> compareRegister,<span class="keyword">uint_fast16_t</span> compareValue)</span></span>;</span><br><span class="line"><span class="comment">//中断相关函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_enableInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> timer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_disableInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> timer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_clearInterruptFlag</span> <span class="params">(<span class="keyword">uint32_t</span> timer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_registerInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> timer, <span class="keyword">uint_fast8_t</span> interruptSelect, <span class="keyword">void</span>(∗intHandler)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_unregisterInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> timer, <span class="keyword">uint_fast8_t</span> interruptSelect)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="系统中断（NVIC）"><a href="#系统中断（NVIC）" class="headerlink" title="系统中断（NVIC）"></a>系统中断（NVIC）</h2><h3 id="一点小小想法"><a href="#一点小小想法" class="headerlink" title="一点小小想法"></a>一点小小想法</h3><p><strong>PS:暂且将Interrupt开头的函数称为系统中断函数，而各个外设中的中断函数成为外设中断函数。</strong></p>
<p>学习中断函数的时候能感受到这个库的逻辑和HAL库最大的差别在于对中断向量的处理：</p>
<p>HAL库将中断处理函数全部写好了，给用户保留了中断回调函数作为接口，开机载入中断向量表的时候会将所有的中断处理函数都作为中断向量加载好，接着在中断处理函数中调用回调函数进而实现将用户代码加入中断中的目的。而SDK的中断向量表从一开始就是空的，用户需要自行编写中断处理函数，并且自行注册中断向量，进而实现发生中断时对中断内部代码的调用。</p>
<p>说简单点就是HAL库棒用户填好了中断向量表，而SDK则需要用户自行填写中断向量表，两种方式自然各有利弊。</p>
<p>HAL库最大的好处就是它简单，使用的时候很简单，只需要写一个回调函数就能完成中断内部函数的书写，对新手友好。但是我个人认为最大的缺点在于没有给新手一个好的引导，这也是我用了SDK的中断部分以后最大的感受：受益匪浅。这种函数的组织方式能让人更好的感受到有一个叫做“中断向量表”的东西一直在指引着程序，让程序知道发生了中断以后该执行什么函数。</p>
<h3 id="常用系统中断函数"><a href="#常用系统中断函数" class="headerlink" title="常用系统中断函数"></a>常用系统中断函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*中断相关函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Interrupt_disableInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> interruptNumber)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Interrupt_enableInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> interruptNumber)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Interrupt_registerInterrupt</span><span class="params">(<span class="keyword">uint32_t</span> interruptNumber,<span class="keyword">void</span> (*intHandler)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Interrupt_unregisterInterrupt</span><span class="params">(<span class="keyword">uint32_t</span> interruptNumber)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>使能某中断时必须<strong>同时调用</strong>外设中断使能函数和系统中断使能函数。</li>
<li>各个外设对应的注册中断向量函数其实内部调用了<strong>系统中断使能函数</strong>和<strong>系统注册中断向量函数</strong></li>
</ul>
</blockquote>
<h2 id="串口（UART）"><a href="#串口（UART）" class="headerlink" title="串口（UART）"></a>串口（UART）</h2><h3 id="串口介绍"><a href="#串口介绍" class="headerlink" title="串口介绍"></a>串口介绍</h3><p>其实串口没啥好介绍的，就是为了标题能整整齐齐所以写了这里。</p>
<p>其实还是看到了一些看起来很新奇的功能模块的，只不过还没用起来过，所以也不好说什么。</p>
<p>或许以后再次接触的时候会用到呢，这里留个坑吧。</p>
<blockquote>
<p><strong>看到的有趣功能：</strong></p>
<ul>
<li><p>Automatic Baud-Rate Detection （自动波特率检测？）</p>
</li>
<li><p>Automatic Error Detection  （自动错误侦测？）</p>
</li>
</ul>
</blockquote>
<h3 id="常用串口函数"><a href="#常用串口函数" class="headerlink" title="常用串口函数"></a>常用串口函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*串口配置结构体*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">eUSCI_eUSCI_UART_ConfigV1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint_fast8_t</span> selectClockSource;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockPrescalar;<span class="comment">//对应取值见设备用户指南（DEVICE USER GUIDE）</span></span><br><span class="line">    <span class="keyword">uint_fast8_t</span> firstModReg;	 <span class="comment">//对应取值见设备用户指南（DEVICE USER GUIDE）</span></span><br><span class="line">    <span class="keyword">uint_fast8_t</span> secondModReg;   <span class="comment">//对应取值见设备用户指南（DEVICE USER GUIDE）</span></span><br><span class="line">    <span class="keyword">uint_fast8_t</span> parity;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> msborLsbFirst;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> numberofStopBits;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> uartMode;</span><br><span class="line">    <span class="keyword">uint_fast8_t</span> overSampling;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> dataLength;</span><br><span class="line">&#125; eUSCI_UART_ConfigV1;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>结构体各部分定义及其取值：</strong></p>
<p><img src="/images/MSP432%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1622470501084.png" alt="1622470501084"></p>
<p><strong>关于上述结构体中注释的三个变量的取值方式：</strong></p>
<p>在USER GUID中查表可得对应取值：</p>
<p><img src="/images/MSP432%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1622472486950.png" alt="1622472486950"></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*串口函数*/</span></span><br><span class="line"><span class="comment">//使能、失能串口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_enableModule</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_disableModule</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance)</span></span>;</span><br><span class="line"><span class="comment">//初始化串口</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UART_initModule</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance, <span class="keyword">const</span> eUSCI_UART_ConfigV1 ∗config)</span></span>;</span><br><span class="line"><span class="comment">//串口收发数据（单字节形式）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_transmitData</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance, <span class="keyword">uint_fast8_t</span> transmitData)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">UART_receiveData</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance)</span></span>;</span><br><span class="line"><span class="comment">//使能、失能串口中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_enableInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance, <span class="keyword">uint_fast8_t</span> mask)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_disableInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance, <span class="keyword">uint_fast8_t</span> mask)</span></span>;</span><br><span class="line"><span class="comment">//清除中断标志位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_clearInterruptFlag</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance, <span class="keyword">uint_fast8_t</span> mask)</span></span>;</span><br><span class="line"><span class="comment">//注册、注销中断向量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_registerInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance, <span class="keyword">void</span>(∗intHandler)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_unregisterInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>需要注意的内容：</strong></p>
<ul>
<li>UART_initModule()函数并不能使能串口，手册说明如下：</li>
</ul>
<p><img src="/images/MSP432%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1622471002332.png" alt="1622471002332"></p>
<ul>
<li>UART_receiveData()函数只有在没有使能串口中断的时候才会轮询中断标志位，也就是说会阻塞程序的运行；当使能中断后就不会再轮询标志位了（因为标志位的变化会引起串口中断，用户可以在中断中进行数据的处理）。</li>
<li>串口的中断接收没法进行断点式的调试，毕竟接收函数并没有轮询标志位，也就不会等着下一个字节数据的到来，信号在线路中传输是不会等待你下断点调试的。</li>
</ul>
</blockquote>
<h2 id="工程函数总结"><a href="#工程函数总结" class="headerlink" title="工程函数总结"></a>工程函数总结</h2><p>在使用的过程中，为了使用方便，我们将我们用到的函数进行了模块化的封装，对应文件内容如下：</p>
<p><strong>user.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZheWana on 2021/5/26.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UARTRetargetInit</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    GPIO_setAsPeripheralModuleFunctionInputPin(GPIO_PORT_P1, GPIO_PIN2 | GPIO_PIN3,</span><br><span class="line">                                               GPIO_PRIMARY_MODULE_FUNCTION);</span><br><span class="line">    <span class="keyword">const</span> eUSCI_UART_ConfigV1 uartConfig =</span><br><span class="line">            &#123;</span><br><span class="line">                    EUSCI_A_UART_CLOCKSOURCE_SMCLK,<span class="comment">//选择时钟源</span></span><br><span class="line">                    <span class="number">6</span>,							   <span class="comment">//In device guide:UCBRx</span></span><br><span class="line">                    <span class="number">8</span>,                             <span class="comment">//In device guide:UCBRFx</span></span><br><span class="line">                    <span class="number">0x11</span>,                          <span class="comment">//In device guide:UCBRSx</span></span><br><span class="line">                    EUSCI_A_UART_NO_PARITY,		   <span class="comment">//极性设置</span></span><br><span class="line">                    EUSCI_A_UART_LSB_FIRST,        <span class="comment">//设置高低位优先</span></span><br><span class="line">                    EUSCI_A_UART_ONE_STOP_BIT,	   <span class="comment">//停止位数</span></span><br><span class="line">                    EUSCI_A_UART_MODE,			   <span class="comment">//串口模式</span></span><br><span class="line">                    EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION,</span><br><span class="line">                    EUSCI_A_UART_8_BIT_LEN		   <span class="comment">//数据长度</span></span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="comment">//配置时钟源，其中SMCLK进行4分频</span></span><br><span class="line">    <span class="comment">//主频48000000</span></span><br><span class="line">    <span class="comment">//SMCLK为12000000</span></span><br><span class="line">    CS_setDCOCenteredFrequency(CS_DCO_FREQUENCY_48);</span><br><span class="line">    CS_setDCOFrequency(<span class="number">48000000</span>);</span><br><span class="line">    CS_initClockSignal(CS_SMCLK,CS_DCOCLK_SELECT,CS_CLOCK_DIVIDER_4);</span><br><span class="line">    <span class="comment">//串口模块初始化以及使能</span></span><br><span class="line">    UART_initModule(EUSCI_A0_BASE, &amp;uartConfig);</span><br><span class="line">    UART_enableModule(EUSCI_A0_BASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口重定向函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART_printf</span><span class="params">(<span class="keyword">uint32_t</span> moduleInstance, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    length = vsnprintf(buffer, <span class="number">128</span>, fmt, ap);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        UART_transmitData(moduleInstance, *(buffer + i));</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int32_t</span> CNT;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encoder_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> temp = GPIO_getInputPinValue(GPIO_PORT_P3, GPIO_PIN2);</span><br><span class="line">    <span class="keyword">uint32_t</span> status;</span><br><span class="line"></span><br><span class="line">    status = MAP_GPIO_getEnabledInterruptStatus(GPIO_PORT_P3);</span><br><span class="line">    MAP_GPIO_clearInterruptFlag(GPIO_PORT_P3, status);</span><br><span class="line">    <span class="keyword">if</span> (status &amp; GPIO_PIN3) &#123;</span><br><span class="line">        MAP_GPIO_toggleOutputOnPin(GPIO_PORT_P1, GPIO_PIN0);</span><br><span class="line">        <span class="keyword">if</span> (temp == GPIO_INPUT_PIN_HIGH) &#123;</span><br><span class="line">            CNT++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == GPIO_INPUT_PIN_LOW) &#123;</span><br><span class="line">            CNT--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EncoderInit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//GPIO模式设置</span></span><br><span class="line">    GPIO_setAsInputPinWithPullUpResistor(GPIO_PORT_P3, GPIO_PIN3);</span><br><span class="line">    GPIO_setAsInputPinWithPullUpResistor(GPIO_PORT_P3, GPIO_PIN2);</span><br><span class="line">    <span class="comment">//清除中断标志位</span></span><br><span class="line">    GPIO_clearInterruptFlag(GPIO_PORT_P3, GPIO_PIN3);</span><br><span class="line">    <span class="comment">//中断使能</span></span><br><span class="line">    GPIO_enableInterrupt(GPIO_PORT_P3, GPIO_PIN3);</span><br><span class="line">    <span class="comment">//中断触发边沿选择</span></span><br><span class="line">    GPIO_interruptEdgeSelect(GPIO_PORT_P3, GPIO_PIN3, GPIO_LOW_TO_HIGH_TRANSITION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中断使能以及中断向量注册</span></span><br><span class="line">    Interrupt_enableInterrupt(INT_PORT3);</span><br><span class="line">    Interrupt_enableMaster();</span><br><span class="line">    Interrupt_registerInterrupt(INT_PORT3, Encoder_IRQHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIMERA0_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    Timer_A_clearInterruptFlag(TIMER_A0_BASE);</span><br><span class="line">    <span class="comment">/********</span></span><br><span class="line"><span class="comment">    *处理函数*</span></span><br><span class="line"><span class="comment">    ********/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimerIntuerruptInit</span><span class="params">(<span class="keyword">double</span> period)</span></span>&#123;</span><br><span class="line">    Timer_A_UpModeConfig Timer=&#123;</span><br><span class="line">            TIMER_A_CLOCKSOURCE_ACLK,</span><br><span class="line">            TIMER_A_CLOCKSOURCE_DIVIDER_1,</span><br><span class="line">            (<span class="keyword">int</span>)(period/<span class="number">1000</span>*<span class="number">32000</span>),</span><br><span class="line">            TIMER_A_TAIE_INTERRUPT_ENABLE,</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    Timer_A_configureUpMode(TIMER_A0_BASE,&amp;Timer);</span><br><span class="line">    Timer_A_enableInterrupt(TIMER_A0_BASE);</span><br><span class="line">    Timer_A_clearInterruptFlag(TIMER_A0_BASE);</span><br><span class="line">    Interrupt_enableInterrupt(INT_TA0_N);</span><br><span class="line">    Interrupt_enableMaster();</span><br><span class="line">    Interrupt_registerInterrupt(INT_TA0_N, TIMERA0_IRQHandler);</span><br><span class="line">    Timer_A_startCounter(TIMER_A0_BASE, TIMER_A_UP_MODE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay_ms</span><span class="params">(<span class="keyword">int</span> freq, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">    SysTick_enableModule();</span><br><span class="line">    SysTick_setPeriod(<span class="number">1</span>&lt;&lt;<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    SysTick-&gt;VAL=<span class="number">1</span>&lt;&lt;<span class="number">24</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> a = SysTick_getValue();</span><br><span class="line">    <span class="keyword">while</span> ((a - SysTick_getValue()) &lt; freq / <span class="number">1000</span> * time);</span><br><span class="line">    SysTick_disableModule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> uartflag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">double</span> data, p, i, d, a;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    buff[cnt] = UART_receiveData(EUSCI_A0_BASE);</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">5</span>)cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>user.h</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZheWana on 2021/5/26.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEMPLATE_USER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEMPLATE_USER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ti/devices/msp432p4xx/driverlib/driverlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdarg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//串口重定向初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UARTRetargetInit</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//串口重定向输出函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART_printf</span><span class="params">(<span class="keyword">uint32_t</span> moduleInstance, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="comment">//定时器中断处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIMERA0_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//定时器中断初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimerIntuerruptInit</span><span class="params">(<span class="keyword">double</span> period)</span></span>;</span><br><span class="line"><span class="comment">//编码器初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EncoderInit</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//编码器对应IO中断处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encoder_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//毫秒延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay_ms</span><span class="params">(<span class="keyword">int</span> freq, <span class="keyword">int</span> time)</span></span>;</span><br><span class="line"><span class="comment">//串口中断回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//TEMPLATE_USER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>因为比赛原因所以学习的其实很仓促，所以很多东西理解的并不好，接下来会找时间系统的好好学习一下的。</p>
<p><strong>路漫漫其修远兮，吾将上下而求索。</strong></p>
]]></content>
      <categories>
        <category>单片机</category>
        <category>MSP432</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>MSP432</tag>
      </tags>
  </entry>
  <entry>
    <title>Everybody loves Somebody</title>
    <url>/2021/05/09/Everybody-lvoes-Somebody/</url>
    <content><![CDATA[<p>《玉子市场》看完啦！</p>
<p><del>什么？你说你发现了我摸鱼？哪有</del></p>
<span id="more"></span>

<p>看过的每部电影和番剧总有一些话会让自己印象深刻，或许下次摸鱼的时候会写一写以前的吧……？</p>
<p><del>不过写了就不算是摸鱼了</del></p>
<h2 id="Everybody-loves-Somebody"><a href="#Everybody-loves-Somebody" class="headerlink" title="Everybody loves Somebody"></a>Everybody loves Somebody</h2><p>说到这句话脑子里就不自觉地响起了蹩脚的日式英语，这就是被洗脑了？</p>
<p><strong>每个人都有其所爱</strong>，看到有人这样翻译感觉真的有被暖到。作为纯爱战士我当然是冲着纯爱来了玉子市场，最后在玉子市场里面我也是真正的看到了纯爱，只不过是邻里之间的纯爱，纯纯的<strong>关爱</strong>。<img src="/images/Everybody-lvoes-Somebody/v2-c16036d2a073bbadc7a9bcf7045f7f41_720w.jpg" alt="img"></p>
<p>兔山真的太好了，看到最后真的觉得整个人都被温馨包围着。虽然看的很迷糊但是还是看出了玉子幼年便丧失了母亲，还能这样乐观真的让人很惊讶，而且玉子真的是傻傻的，很可爱，对年糕有着奇怪的偏执但是并不影响这表现出她对生活的热爱。</p>
<p><img src="/images/Everybody-lvoes-Somebody/v2-904ffa62d33064bea2e1c8c8da1c3995.jpg" alt="v2-904ffa62d33064bea2e1c8c8da1c3995"></p>
<p>玉子市场，是兔山，是围绕在玉子周围的市场。但是从头到尾真的没看到一点印象中市场该有的感觉，每次交易都是围绕着玉子、朋友进行的，目光所及之处满是慷慨的馈赠<del>白嫖党狂喜</del>。听说王子妃一事，大家都纷纷祝愿玉子幸福，又安慰豆大不要伤心，要失去一些东西才能得到新的东西（当然我是非常不希望玉子当上王子妃的）。</p>
<p>顺带一提，最终玉子拒绝当上王子妃的时候我真的狂喜！！</p>
<p>看得出玉子和饼藏的感情萌芽，不过玉子真的好迟钝，也好可爱。</p>
<p>感受得到豆大和雏子（原谅我其实没记住妈妈的名字）年轻的时候的感情，真的很让人羡慕哈！</p>
<p>又想起了馅子和悠月的可爱感情（小盆友互相喜欢什么的真的太可爱啦~）</p>
<p><del>单身狗流下了泪水</del></p>
<p>不写了不写了，越看自己写的东西越感觉:</p>
<p>写的真烂呀T_T</p>
<p>总之就是<strong>完结撒花！</strong></p>
<p><img src="/images/Everybody-lvoes-Somebody/1620574802817.png" alt="1620574802817"></p>
<p>摸鱼结束，该干活了orz</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Clion的STM32开发</title>
    <url>/2021/05/08/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>前段时间刚刚从keil转到了VScode，正当我享受着VScode爽快的代码编辑的时候，被学长安利了Clion。</p>
<p>VScode的代码补全是很舒服的<del>（主要是keil衬托得好啊）</del>，但是真要调试、查看寄存器之类的功能却还是要打开keil，这导致我在搞工程的时候经常要打开VScode、打开CubeMX、打开Keil，这样的话反而背离了我们使用方便的初心，变得更麻烦了，而且VScode无法与CubeMX联动也是件让人伤心的事。</p>
<p>所有以上提到的问题，Clion都可以解决，而且还附带了GDB调试功能，让我们的调试更加<del>花里胡哨</del>高端大气、方便易用。</p>
<p>PS：以下内容均大部分参考自下面几位大佬的文章，但是文章中有一些问题并未涉及，于是我把没有涉及的部分加入进来融合为一篇文章，如果安装的过程中出现任何问题大家也可以看一下几位大佬的原文：</p>
<p><a href="https://www.bilibili.com/read/cv6308000">配置CLion用于STM32开发【优雅の嵌入式开发】</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/160183640">在CLion中开发STM32</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/288376187">CLion开发STM32（环境配置篇）</a> </p>
<span id="more"></span>

<hr>
<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="一、白嫖申请教育优惠"><a href="#一、白嫖申请教育优惠" class="headerlink" title="一、白嫖申请教育优惠"></a>一、<del>白嫖</del>申请教育优惠</h3><p>首先，Clion是JetBrains家的一款C/C++编辑器，正常的使用是要支付不菲的费用的，而且还不是买断制的，不过JetBrains推出了教育优惠，只要我们还是学生，就可以每年使用我们的教育邮箱申请一年的免费使用权限，<a href="https://www.jetbrains.com/shop/eform/students">传送门</a>在这。</p>
<p>填写完个人信息之后再打三个勾，申请一下即可（邮箱一定要用教育邮箱！如果你没有收到激活邮件请移步其他邮件的垃圾箱中查看，如果垃圾箱中也没有，请耐心等待。）</p>
<h3 id="二、下载和安装"><a href="#二、下载和安装" class="headerlink" title="二、下载和安装"></a>二、下载和安装</h3><p>1.<a href="https://www.jetbrains.com/clion/">Clion下载</a>：下载后正常安装即可</p>
<p>2.<a href="https://gnutoolchains.com/arm-eabi/openocd/">OpenOCD下载</a>：下载后解压到存放的目录，记住存放路径留待后面使用。</p>
<p>3.<a href="https://osdn.net/projects/mingw/releases/">MinGW下载</a>：下载后正常安装即可（安装路径不要有中文或空格）</p>
<p>安装后我们会得到一个 名为 “MinGW Installer Manager” 的软件 ，打开它。</p>
<p>勾选如图的两项后选择 Installation -&gt; Apply Changes ，在弹出的对话框中选择Apply后耐心等待安装完成。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619006464175-1620467115426.png" alt="1619006464175"></p>
<p>4.<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">GNU Arm Embedded Toolchain下载</a>：下载后正常安装即可（尽量不要安装到C盘，且安装路径不要有中文或空格），注意要勾选添加到环境变量否则需要手动添加</p>
<p>5.<a href="https://www.st.com/content/st_com/zh/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-programmers/stsw-link007.html">（非必须）ST-Link v2驱动下载</a>由于想要使用Jlink的话需要修改Jlink驱动，所以现在手中有未完成工程还想更换开发环境的建议先用ST-Link做一下过渡（若需要其他版本驱动请到ST官网自行寻找下载）。</p>
<h4 id="附手动添加MinGW环境变量方法："><a href="#附手动添加MinGW环境变量方法：" class="headerlink" title="附手动添加MinGW环境变量方法："></a>附手动添加MinGW环境变量方法：</h4><p>系统设置-&gt;高级系统设置-&gt;环境变量-&gt;（双击）Path-&gt;新建-&gt;添加MinGW安装目录中的bin文件夹到环境变量中（如图），例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\SoftWare\MinGW\bin（该路径因人而异）</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619945824839-1620467115426.png" alt="1619945824839"></p>
<p>结束后一路确定杀回设置。</p>
<h4 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h4><p>按下Win+R打开运行窗口，输入cmd回车，分别输入：</p>
<p>gcc -v</p>
<p>arm-none-eabi-gcc -v</p>
<p>输出如下说明安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\ZheWana&gt;gcc -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=d:/software/mingw/bin/../libexec/gcc/mingw32/9.2.0/lto-wrapper.exe</span><br><span class="line">Target: mingw32</span><br><span class="line">Configured with: ../src/gcc-9.2.0/configure --build=x86_64-pc-linux-gnu --host=mingw32 --target=mingw32 --disable-win32-registry --with-arch=i586 --with-tune=generic --enable-static --enable-shared --enable-threads --enable-languages=c,c++,objc,obj-c++,fortran,ada --with-dwarf2 --disable-sjlj-exceptions --enable-version-specific-runtime-libs --enable-libgomp --disable-libvtv --with-libiconv-prefix=/mingw --with-libintl-prefix=/mingw --enable-libstdcxx-debug --disable-build-format-warnings --prefix=/mingw --with-gmp=/mingw --with-mpfr=/mingw --with-mpc=/mingw --with-isl=/mingw --enable-nls --with-pkgversion=&#x27;MinGW.org GCC Build-2&#x27;</span><br><span class="line">Thread model: win32</span><br><span class="line">gcc version 9.2.0 (MinGW.org GCC Build-2)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\ZheWana&gt;arm-none-eabi-gcc -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=arm-none-eabi-gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=d:/software/10\ 2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/lto-wrapper.exe</span><br><span class="line">Target: arm-none-eabi</span><br><span class="line">Configured with: /mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/src/gcc/configure --build=x86_64-linux-gnu --host=i686-w64-mingw32 --target=arm-none-eabi --prefix=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/install-mingw --libexecdir=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/install-mingw/lib --infodir=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/install-mingw/share/doc/gcc-arm-none-eabi/info --mandir=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/install-mingw/share/doc/gcc-arm-none-eabi/man --htmldir=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/install-mingw/share/doc/gcc-arm-none-eabi/html --pdfdir=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/install-mingw/share/doc/gcc-arm-none-eabi/pdf --enable-languages=c,c++ --enable-mingw-wildcard --disable-decimal-float --disable-libffi --disable-libgomp --disable-libmudflap --disable-libquadmath --disable-libssp --disable-libstdcxx-pch --disable-nls --disable-shared --disable-threads --disable-tls --with-gnu-as --with-gnu-ld --with-headers=yes --with-newlib --with-python-dir=share/gcc-arm-none-eabi --with-sysroot=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/install-mingw/arm-none-eabi --with-libiconv-prefix=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/build-mingw/host-libs/usr --with-gmp=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/build-mingw/host-libs/usr --with-mpfr=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/build-mingw/host-libs/usr --with-mpc=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/build-mingw/host-libs/usr --with-isl=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/build-mingw/host-libs/usr --with-libelf=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/build-mingw/host-libs/usr --with-host-libstdcxx=&#x27;-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm&#x27; --with-pkgversion=&#x27;GNU Arm Embedded Toolchain 10-2020-q4-major&#x27; --with-multilib-list=rmprofile,aprofile</span><br><span class="line">Thread model: single</span><br><span class="line">Supported LTO compression algorithms: zlib</span><br><span class="line">gcc version 10.2.1 20201103 (release) (GNU Arm Embedded Toolchain 10-2020-q4-major)</span><br></pre></td></tr></table></figure>

<h4 id="Clion中文界面配置"><a href="#Clion中文界面配置" class="headerlink" title="Clion中文界面配置"></a>Clion中文界面配置</h4><p>打开Clion，根据提示登录我们的<del>白嫖</del>账号。</p>
<p>选择Plugins-&gt;Marketplace-&gt;搜索“Chinese”,选择Chinese(Simplified) Language Pack/中文语言包</p>
<p>安装后重启即可。</p>
<h4 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h4><p>打开Clion-&gt;自定义-&gt;所有设置…-&gt;嵌入式开发</p>
<p>在OpenOCD位置中选择openocd.exe所在的位置；</p>
<p>在Stm32CubeMX位置中选择STM32CubeMX.exe所在的位置。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619922996711-1620467115426.png" alt="1619922996711"></p>
<p>完成后可以点击测试来测试一下是否成功配置。</p>
<h4 id="来试着建立我们的第一个工程"><a href="#来试着建立我们的第一个工程" class="headerlink" title="来试着建立我们的第一个工程"></a>来试着建立我们的第一个工程</h4><p>打开Clion，选择新建项目；</p>
<p>选择嵌入式一栏中的STM32CubeMX，新建一个文件夹用来存储Clion的工程（名字里面不要带有中文或空格），路径的最后一个文件名称要改为当前工程的名称，须要记住。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619088458058-1620467115427.png" alt="1619088458058"></p>
<p>完成后点击创建。</p>
<p>一番加载之后会出现这样的界面：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619088539398-1620467115427.png" alt="1619088539398"></p>
<p>点击中间的：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619088559232-1620467115427.png" alt="1619088559232"></p>
<p>就会自动运行CubeMX了，不过初始的芯片并不是我们想要的芯片，可以通过点击更换我们想要的芯片：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619088721106-1620467115427.png" alt="1619088721106"></p>
<p>我们仍以STM32F401CCU6为例来进行操作，配置的过程和正常使用芯片的时候几乎完全一致，需要注意的有这么三点：</p>
<p>1.工程名必须与之前的名字一致：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619088916849-1620467115427.png" alt="1619088916849"></p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619088940249-1620467115427.png" alt="1619088940249"></p>
<p>2.工程路径要和之前的路径是一样的：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619089152073-1620467115427.png" alt="1619089152073"></p>
<p><img src="C:\Users\ZheWana\AppData\Roaming\Typora\typora-user-images\1619088940249.png" alt="1619088940249"></p>
<p>3.ToolChain中要在这两项中任选一个并勾选右侧的Generate Under Root：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619089057614-1620467115427.png" alt="1619089057614"></p>
<p>配置完成之后点击生成代码，会提示是否要覆盖已存在的工程，选择Yes。</p>
<p>完成后点击Close，回到Clion。</p>
<p>界面会变成这个样子：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619089560446-1620467115427.png" alt="1619089560446"></p>
<p>紧接着会提示选择配置文件，因为这里没有我们需要的配置文件，所以我们点击取消，后面我们会自己写适合我们自己的配置文件。</p>
<p>至此，工程建立完毕，可以开始愉快的写代码了！</p>
<p>PS：主函数文件在“Core\Src\main.c”</p>
<p>​         函数库文件在“Driver\STM32F4xx_HAL_Driver\Src\xxx.c”</p>
<p>随便写一段代码，发现似乎代码补全并没有很好用？那我们来更改一下设置：</p>
<p>Ctrl+Alt+S打开设置界面：</p>
<p>（什么？你打开了QQ录屏？咳咳咳）</p>
<p>它其实在这里：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619090132742-1620467115427.png" alt="1619090132742"></p>
<p>点击编辑器-&gt;常规-&gt;代码完成（其实应该是代码补全咳咳）-&gt;取消匹配大小写前面的勾选（记得按应用）</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619090292986-1620467115427.png" alt="1619090292986"></p>
<p>回去敲一段代码就可以享受到丝滑的代码补全了：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619090418072-1620467115427.png" alt="1619090418072"></p>
<h4 id="配置文件的书写"><a href="#配置文件的书写" class="headerlink" title="配置文件的书写"></a>配置文件的书写</h4><p>考虑到随着开发过程的延长，我们用到的调试器会逐渐增多，所以我们在Clion工程文件夹中新建一个Config文件夹专门用来存放各种配置文件。</p>
<p>在文件夹中右键新建一个文本文档，后把文档的名字连同后缀改为“STlink.cfg”。</p>
<p>这里说一下配置文件书写的格式：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#前面带有“#”的是注释</span></span><br><span class="line"><span class="comment">#下方xxxxxx选择调试器型号，对应的配置文件在openocd文件夹路径\share\scripts\interface中，从中选择需要的即可。</span></span><br><span class="line">source <span class="section">[find interface/xxxxxx.cfg]</span></span><br><span class="line"><span class="comment">#下方xxxxxx选择调试接口，可选项包括：</span></span><br><span class="line"><span class="comment">#jtag、aice_jtag、swd、stlink_swim、hla_jtag、hla_swd</span></span><br><span class="line">transport select xxxxxx</span><br><span class="line"><span class="comment">#选择目标芯片种类，对应的配置文件在openocd文件夹路径\share\scripts\target中，从中选择需要的即可。</span></span><br><span class="line">source <span class="section">[find target/xxxxxx.cfg]</span></span><br><span class="line"><span class="comment"># 不使用复位接口</span></span><br><span class="line">reset_config none</span><br></pre></td></tr></table></figure>

<p>例如J-Link的配置文件内容如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">source <span class="section">[find interface/jlink.cfg]</span></span><br><span class="line"></span><br><span class="line">transport select swd</span><br><span class="line"></span><br><span class="line">source <span class="section">[find target/stm32f4x.cfg]</span></span><br><span class="line"></span><br><span class="line">reset_config none</span><br></pre></td></tr></table></figure>

<p>ST-Link的配置文件内容如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">source <span class="section">[find interface/stlink-v2.cfg]</span></span><br><span class="line"></span><br><span class="line">transport select hla_swd</span><br><span class="line"></span><br><span class="line">source <span class="section">[find target/stm32f4x.cfg]</span></span><br><span class="line"></span><br><span class="line">reset_config none</span><br></pre></td></tr></table></figure>

<p>接下来点击上方配置界面：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619177022369-1620467115427.png" alt="1619177022369"></p>
<p>选择编辑配置，</p>
<p>在面板配置文件中选择自己对应的调试器的配置文件即可（别忘了点击应用）。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619177105708-1620467115427.png" alt="1619177105708"></p>
<p>如果现在手中有未完成工程还想更换开发环境的此处建议使用ST-Link，因为J-Link需要更改驱动，这将导致你的Keil在换回原来的驱动之前无法使用J-link，而ST-Link则不存在这样的问题。</p>
<h4 id="关于硬件浮点运算单元"><a href="#关于硬件浮点运算单元" class="headerlink" title="关于硬件浮点运算单元"></a>关于硬件浮点运算单元</h4><p>在CMake模板文件中将硬件浮点运算注释掉了，这会导致如果我们使用这部分就会报错，因此需要把这部分取消注释。</p>
<p>我们进入CMake的模板文件：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619959379967-1620467115427.png" alt="1619959379967"></p>
<p>将下面的代码取消注释：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Uncomment for hardware floating point</span></span><br><span class="line">add_compile_definitions(ARM_MATH_CM4<span class="comment">;ARM_MATH_MATRIX_CHECK;ARM_MATH_ROUNDING)</span></span><br><span class="line">add_compile_options(<span class="attr">-mfloat-abi</span>=hard -mfpu=fpv4-sp-d16)</span><br><span class="line">add_link_options(<span class="attr">-mfloat-abi</span>=hard -mfpu=fpv4-sp-d16)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="J-Link驱动修改（非必须，看个人需要）"><a href="#J-Link驱动修改（非必须，看个人需要）" class="headerlink" title="J-Link驱动修改（非必须，看个人需要）"></a>J-Link驱动修改（非必须，看个人需要）</h4><p>接下来我们来修改一下J-Link驱动。</p>
<p>下载Zadig并打开</p>
<p>插上J-Link</p>
<p>点击Options-&gt;在List All Devices前面打勾</p>
<p>然后在下拉列表中选择这个驱动：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619178335471-1620467115427.png" alt="1619178335471"></p>
<p>在下方更改为WinUSB：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619178369514-1620467115427.png" alt="1619178369514"></p>
<p>点击安装即可修改驱动。</p>
<h4 id="简单的界面功能介绍以及一点小小的适应性修改"><a href="#简单的界面功能介绍以及一点小小的适应性修改" class="headerlink" title="简单的界面功能介绍以及一点小小的适应性修改"></a>简单的界面功能介绍以及一点小小的适应性修改</h4><p>首先就是最常用的快捷键：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619178659117-1620467115427.png" alt="1619178659117"></p>
<p>什么，你想用快捷键但是觉得Clion的快捷键风格不适合你？我们可以改下快捷键的风格：</p>
<p>进入设置-&gt;键盘映射，可以在这里将快捷键风格改为Visul Studio风格：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619957548187-1620467115427.png" alt="1619957548187"></p>
<p>这样我们就可以在调试的时候按下F10下一步，按下F11进入函数了。</p>
<p>改完键盘快捷键再说一个代码风格不好的小朋友的福音：<strong>代码格式化</strong></p>
<p>如果你更改了VS风格的快捷键，那么你可以用“Ctrl+Alt+Enter”来实现当前文件代码的格式化。</p>
<p>具体的细节方面设置可以在设置-&gt;编辑器-&gt;代码样式-&gt;C/C++中进行设置：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619958119088-1620467115427.png" alt="1619958119088"></p>
<p>如果你觉得右上角的报错怪怪的并不是你所需要的，</p>
<p>进入设置找到下图设置项，先把上方配置文件从项目默认改成全局默认：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619942701283-1620467115427.png" alt="1619942701283"></p>
<p>取消endless loop后面的勾选：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619942737559-1620467115427.png" alt="1619942737559"></p>
<p>在下面的设置项中找到校对-&gt;拼写错误,取消勾选：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619942755542-1620467115427.png" alt="1619942755542"></p>
<p>点击应用、确定。</p>
<p><strong>调试界面：</strong></p>
<p>由于Clion进入调试模式就会自动运行程序而不是像keil一样在main函数停下来，所以建议调试前在main前下断点。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619187470202-1620467115427.png" alt="1619187470202"></p>
<p>点击虫子图标进入调试界面，功能菜单在下面：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619187955822-1620467115427.png" alt="1619187955822"></p>
<p>关于功能键的介绍：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619190852209-1620467115427.png" alt="1619190852209"></p>
<p>点击变量窗口的“+”可以添加监视变量（可以是表达式，似乎输入函数还可以监视函数的返回值）：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619190975442-1620467115427.png" alt="1619190975442"></p>
<p>此外，代码窗口中的箭头不仅有指示代码执行位置的作用，还可以通过拖动箭头来强制执行语句：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619191179568-1620467115427.png" alt="1619191179568"></p>
<h4 id="关于F4调试过程中的一些问题（只有F4有类似的问题）："><a href="#关于F4调试过程中的一些问题（只有F4有类似的问题）：" class="headerlink" title="关于F4调试过程中的一些问题（只有F4有类似的问题）："></a>关于F4调试过程中的一些问题（只有F4有类似的问题）：</h4><p>我们进入调试之后运行代码，然后暂停会发现一件奇怪的事：</p>
<p>代码停在了错误处理的死循环中：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619191669418-1620467115427.png" alt="1619191669418"></p>
<p>这是由于openocd的配置文件修改了我们的JTAG频率，导致HAL库在配置时钟树的时候会检测到时钟频率不是我们要配置的频率而进入报错。由于进入调试的时候openocd的配置文件被运行了一次所以会产生这个问题。</p>
<p>由于重置会重置我们的时钟频率，所以如果不在意的话只要每次进入调试都重置一下即可解决问题：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619191819353-1620467115427.png" alt="1619191819353"></p>
<p>当然，解决办法也很简单：</p>
<p>在target文件夹中找到stm32f4x.cfg文件打开，用“#”将下面内容注释：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#   $_TARGETNAME configure -event reset-init &#123;</span></span><br><span class="line"><span class="comment">#       # Configure PLL to boost clock to HSI x 4 (64 MHz)</span></span><br><span class="line"><span class="comment">#       mww 0x40023804 0x08012008   ;# RCC_PLLCFGR 16 Mhz /8 (M) * 128 (N) /4(P)</span></span><br><span class="line"><span class="comment">#       mww 0x40023C00 0x00000102   ;# FLASH_ACR = PRFTBE | 2(Latency)</span></span><br><span class="line"><span class="comment">#       mmw 0x40023800 0x01000000 0 ;# RCC_CR |= PLLON</span></span><br><span class="line"><span class="comment">#       sleep 10                    ;# Wait for PLL to lock</span></span><br><span class="line"><span class="comment">#       mmw 0x40023808 0x00001000 0 ;# RCC_CFGR |= RCC_CFGR_PPRE1_DIV2</span></span><br><span class="line"><span class="comment">#       mmw 0x40023808 0x00000002 0 ;# RCC_CFGR |= RCC_CFGR_SW_PLL</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       # Boost JTAG frequency</span></span><br><span class="line"><span class="comment">#       adapter_khz 8000</span></span><br><span class="line"><span class="comment">#   &#125;</span></span><br></pre></td></tr></table></figure>

<p>接下来就可以开心地进行调试了。</p>
<h4 id="关于查看寄存器配置"><a href="#关于查看寄存器配置" class="headerlink" title="关于查看寄存器配置"></a>关于查看寄存器配置</h4><p>进入调试，点击外设：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619189512044-1620467115427.png" alt="1619189512044"></p>
<p>后点击中间的加载.svd文件</p>
<p>由于我们安装过keil，故我们有现成的寄存器文件，路径如下：</p>
<p>…\Keil5\Packs\Keil\STM32F4xx_DFP\2.15.0\CMSIS\SVD\STM32F40x.svd</p>
<p>其他.svd文件也在相同路径下。</p>
<p>选择后出现下面窗口：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619189708577-1620467115427.png" alt="1619189708577"></p>
<p>可以根据需要选择需要查看的寄存器，也可以为了方便直接全选。</p>
<p>后续可以点击配置键重新配置选择的寄存器：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619190024821-1620467115428.png" alt="1619190024821"></p>
<h4 id="关于GDB调试"><a href="#关于GDB调试" class="headerlink" title="关于GDB调试"></a>关于GDB调试</h4><p>网上关于GDB调试的内容有很多，这里就列出一些简单的命令供大家使用：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>命令缩写</th>
<th>命令说明</th>
</tr>
</thead>
<tbody><tr>
<td>list</td>
<td>l</td>
<td>显示多行源代码</td>
</tr>
<tr>
<td>break</td>
<td>b</td>
<td>设置断点,程序运行到断点的位置会停下来</td>
</tr>
<tr>
<td>info</td>
<td>i</td>
<td>描述程序的状态</td>
</tr>
<tr>
<td>display</td>
<td>disp</td>
<td>跟踪查看某个变量,每次停下来都显示它的值</td>
</tr>
<tr>
<td>step</td>
<td>s</td>
<td>执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句</td>
</tr>
<tr>
<td>next</td>
<td>n</td>
<td>执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)</td>
</tr>
<tr>
<td>print</td>
<td>p</td>
<td>打印内部变量值</td>
</tr>
<tr>
<td>continue</td>
<td>c</td>
<td>继续程序的运行,直到遇到下一个断点</td>
</tr>
<tr>
<td>set var name=v</td>
<td></td>
<td>设置变量的值</td>
</tr>
<tr>
<td>start</td>
<td>st</td>
<td>开始执行程序,在main函数的第一条语句前面停下来</td>
</tr>
<tr>
<td>kill</td>
<td>k</td>
<td>终止正在调试的程序</td>
</tr>
<tr>
<td>watch</td>
<td></td>
<td>监视变量值的变化</td>
</tr>
<tr>
<td>quit</td>
<td>q</td>
<td>退出GDB环境</td>
</tr>
</tbody></table>
<p>具体用法可以参考<a href="https://www.cnblogs.com/HKUI/p/8955443.html">这篇文章</a>。</p>
<h4 id="关于printf重定向问题"><a href="#关于printf重定向问题" class="headerlink" title="关于printf重定向问题"></a>关于printf重定向问题</h4><p>在使用Clion时无法正常进行串口重定向。</p>
<p>对此我们有两种解决方法一种是适用于临时使用的简单方法，另一种方法是采用稚晖君提供的方法。</p>
<p>第一种方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件包含如下：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重定向函数内容如下，使用时直接调用即可：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART_printf</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">  length = vsnprintf(buffer, <span class="number">128</span>, fmt, ap);</span><br><span class="line">    </span><br><span class="line">  HAL_UART_Transmit(huart, (<span class="keyword">uint8_t</span> *)buffer, length, HAL_MAX_DELAY);</span><br><span class="line">    </span><br><span class="line">  va_end(ap);</span><br><span class="line">  <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种我们来移植稚晖君的方法：</p>
<p>新建retarget.h文件内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MYSTDIO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MYSTDIO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f4xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RetargetInit</span><span class="params">(UART_HandleTypeDef *huart)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> _isatty(<span class="keyword">int</span> fd);</span><br><span class="line">	<span class="keyword">int</span> _write(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr, <span class="keyword">int</span> len);</span><br><span class="line">	<span class="keyword">int</span> _close(<span class="keyword">int</span> fd);</span><br><span class="line">	<span class="keyword">int</span> _lseek(<span class="keyword">int</span> fd, <span class="keyword">int</span> ptr, <span class="keyword">int</span> dir);</span><br><span class="line">	<span class="keyword">int</span> _read(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr, <span class="keyword">int</span> len);</span><br><span class="line">	<span class="keyword">int</span> _fstat(<span class="keyword">int</span> fd, struct stat *st);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>新建retarget.c文件内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Clion重定向串口</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;_ansi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;_syslist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(OS_USE_SEMIHOSTING)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDIN_FILENO  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDOUT_FILENO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDERR_FILENO 2</span></span><br><span class="line">UART_HandleTypeDef *gHuart;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RetargetInit</span><span class="params">(UART_HandleTypeDef *huart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gHuart = huart;</span><br><span class="line">    <span class="comment">/* Disable I/O buffering for STDOUT stream, so that</span></span><br><span class="line"><span class="comment">    * chars are sent out as soon as they are printed. */</span></span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _isatty(<span class="keyword">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= STDIN_FILENO &amp;&amp; fd &lt;= STDERR_FILENO)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    errno = EBADF;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _write(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr, <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    HAL_StatusTypeDef hstatus;</span><br><span class="line">    <span class="keyword">if</span> (fd == STDOUT_FILENO || fd == STDERR_FILENO)</span><br><span class="line">    &#123;</span><br><span class="line">        hstatus = HAL_UART_Transmit(gHuart, (<span class="keyword">uint8_t</span> *) ptr, len, HAL_MAX_DELAY);</span><br><span class="line">        <span class="keyword">if</span> (hstatus == HAL_OK)</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> EIO;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = EBADF;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _close(<span class="keyword">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= STDIN_FILENO &amp;&amp; fd &lt;= STDERR_FILENO)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    errno = EBADF;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _lseek(<span class="keyword">int</span> fd, <span class="keyword">int</span> ptr, <span class="keyword">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">    (<span class="keyword">void</span>) fd;</span><br><span class="line">    (<span class="keyword">void</span>) ptr;</span><br><span class="line">    (<span class="keyword">void</span>) dir;</span><br><span class="line">    errno = EBADF;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _read(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr, <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    HAL_StatusTypeDef hstatus;</span><br><span class="line">    <span class="keyword">if</span> (fd == STDIN_FILENO)</span><br><span class="line">    &#123;</span><br><span class="line">        hstatus = HAL_UART_Receive(gHuart, (<span class="keyword">uint8_t</span> *) ptr, <span class="number">1</span>, HAL_MAX_DELAY);</span><br><span class="line">        <span class="keyword">if</span> (hstatus == HAL_OK)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> EIO;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = EBADF;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _fstat(<span class="keyword">int</span> fd, struct stat *st)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= STDIN_FILENO &amp;&amp; fd &lt;= STDERR_FILENO)</span><br><span class="line">    &#123;</span><br><span class="line">        st-&gt;st_mode = S_IFCHR;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = EBADF;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>将上述.c文件加入Src文件夹，.h文件加入Inc文件夹（其他自己添加的文件也是如此）</p>
<p>编译之后会发现报错信息，是说在syscalls.c中有函数重定义了，只要追踪到源码处把源码注释即可（注释和取消注释的快捷键为“Ctrl+/”）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//int _close(int file)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	return -1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//int _fstat(int file, struct stat *st)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	st-&gt;st_mode = S_IFCHR;</span></span><br><span class="line"><span class="comment">//	return 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//int _isatty(int file)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	return 1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//int _lseek(int file, int ptr, int dir)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	return 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用时只需要在<strong>串口初始化之后</strong>加上RetargetInit();之后就可以使用printf和scanf了。</p>
<h4 id="关于多文件工程的组建"><a href="#关于多文件工程的组建" class="headerlink" title="关于多文件工程的组建"></a>关于多文件工程的组建</h4><p>在使用的过程中还会遇到的问题就是关于多文件项目找不到包含文件的问题，为了解决这种问题我们给出两种方法：</p>
<p>首先是最简单粗暴的方法：</p>
<p><strong>将需要使用的头文件（.h）丢进Inc文件夹，把源文件(.c)放进Src文件夹，然后在主函数include一下就可以用了。</strong></p>
<p>不过这种简单粗暴的方法往往不能让我们的工程变得井井有条，故我们有下面这个优雅的方法：</p>
<p>由于Clion是使用CMake进行工程组建的，所以我们在导入外部源文件的时候需要对CMake配置文件做点手脚。</p>
<p>PS：CMakeLists.txt是根据模板文件生成的，所以我们应该更改模板文件而不是这个文件，否则所作更改会在重新生成CMake文件的时候被覆盖。</p>
<p>此处以<strong>DMP库的导入</strong>为例：</p>
<p>首先在<strong>工程目录下</strong>新建一个文件夹并命名为“DMP”；</p>
<p>接下来将我们需要用到的文件复制到该文件夹下；</p>
<p>接下来打开我们项目列表中的<strong>CmakeLists_template.txt</strong>文件，我们开始改写CMake模板文件：</p>
<p>我们在文件中搜索“<strong>include_directories</strong>”可以看到如下语句：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">include_directories($&#123;includes&#125;)</span><br></pre></td></tr></table></figure>

<p>我们在这句话的下方加一句：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">include_directories(DMP)</span><br></pre></td></tr></table></figure>

<p>然后将下方的这个语句做一点小小的更改：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#更改前：</span></span><br><span class="line">file(GLOB_RECURSE SOURCES $&#123;sources&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#更改后：</span></span><br><span class="line">file(GLOB_RECURSE SOURCES $&#123;sources&#125; &quot;DMP/*.*&quot;)</span><br></pre></td></tr></table></figure>

<p>完成后右击(.ioc）文件，选择“使用CubeMX更新CMake项目”：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619958919004-1620467115428.png" alt="1619958919004"></p>
<p>回到主函数文件编译，此时应该没有问题了。</p>
<p>至此全部教程完成，如有问题可与我本人联系，内容中如果有任何形式的任何错误，欢迎大佬指出。</p>
<p>以上</p>
]]></content>
      <categories>
        <category>单片机</category>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>通过串口空闲中断结合DMA的方式实现不定长数据的接受</title>
    <url>/2021/05/08/%E9%80%9A%E8%BF%87%E4%B8%B2%E5%8F%A3%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD%E7%BB%93%E5%90%88DMA%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E5%8F%97/</url>
    <content><![CDATA[<p>本文为我自己写的串口收发函数的使用说明，采用了串口空闲中断+DMA的方式来实现不定长数据的接收。</p>
<p>环境：<strong>STM32F401CCU6+CubeMX+HAL库</strong></p>
<span id="more"></span>

<p>首先打开串口并打开串口的收发DMA。</p>
<p>接下来全部编译一遍文件。</p>
<p>找到main.h文件，在对应位置插入回调函数函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN EFP */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_UART_IDLECallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span>;</span><br><span class="line"><span class="comment">/* USER CODE END EFP */</span></span><br></pre></td></tr></table></figure>

<p>进入stm32f4xx_it.c文件，在串口中断函数里面插入空闲中断服务函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* USER CODE BEGIN USART1_IRQn 1 */</span></span><br><span class="line"><span class="comment">//判断是否是串口1</span></span><br><span class="line"><span class="keyword">if</span>(USART1 == huart1.Instance)                                   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断是否是空闲中断</span></span><br><span class="line">	<span class="keyword">if</span>(RESET != __HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_IDLE))   </span><br><span class="line">    &#123;	</span><br><span class="line">        <span class="comment">//清除空闲中断标志（否则会一直不断进入中断）</span></span><br><span class="line">        __HAL_UART_CLEAR_IDLEFLAG(&amp;huart1);                     </span><br><span class="line">        <span class="comment">//调用中断回调函数</span></span><br><span class="line">        My_UART_IDLECallback(&amp;huart1);                         </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/* USER CODE END USART1_IRQn 1 */</span></span><br></pre></td></tr></table></figure>

<p>最后在main.c文件里面加入我们自己的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN PD */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 20</span></span><br><span class="line"><span class="comment">/* USER CODE END PD */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myuart</span>&#123;</span></span><br><span class="line">	<span class="keyword">uint8_t</span>* buffer_addr;<span class="comment">//缓冲区首地址</span></span><br><span class="line">	<span class="keyword">uint32_t</span> date_size;<span class="comment">//传输数据长度</span></span><br><span class="line">&#125;myuart_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口结构体初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_UART_IDLEIT_DMA_Init</span><span class="params">(<span class="keyword">uint8_t</span>* Address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myuart_1.buffer_addr=Address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口接收函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_UART_IDLEIT_DMA_Receive</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">uint8_t</span> *pData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__HAL_UART_ENABLE_IT(huart, UART_IT_IDLE);<span class="comment">//开启空闲中断</span></span><br><span class="line">	HAL_UART_Receive_DMA(huart, pData, BUFFER_SIZE);<span class="comment">//开启DMA接收函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口发送函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_UART_IDLEIT_DMA_Transmit</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">uint8_t</span> *pData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__HAL_UART_ENABLE_IT(huart, UART_IT_IDLE);<span class="comment">//开启空闲中断</span></span><br><span class="line">	HAL_UART_Transmit_DMA(huart, pData, BUFFER_SIZE);<span class="comment">//开启DMA发送函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空闲中断回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_UART_IDLECallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HAL_UART_DMAStop(huart);<span class="comment">//停止DMA传输</span></span><br><span class="line">	</span><br><span class="line">	myuart_1.date_size = BUFFER_SIZE - 	__HAL_DMA_GET_COUNTER(huart-&gt;hdmarx);<span class="comment">//计算数据长度</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*数据处理函数开始*/</span></span><br><span class="line">	<span class="comment">/*bla  bla ....*/</span></span><br><span class="line">	<span class="comment">/*数据处理函数结束*/</span></span><br><span class="line">	<span class="built_in">memset</span>(myuart_1.buffer_addr, <span class="number">0</span>, myuart_1.date_size);<span class="comment">//重置缓冲区</span></span><br><span class="line">	</span><br><span class="line">	HAL_UART_Receive_DMA(huart, myuart_1.buffer_addr, BUFFER_SIZE);<span class="comment">//开启DMA接受函数</span></span><br><span class="line">	__HAL_UART_ENABLE_IT(huart, UART_IT_IDLE);<span class="comment">//开启空闲中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>单片机</category>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>逐飞常用库函数列举</title>
    <url>/2021/04/10/%E9%80%90%E9%A3%9E%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E5%88%97%E4%B8%BE/</url>
    <content><![CDATA[<h2 id="常用用户函数列举"><a href="#常用用户函数列举" class="headerlink" title="常用用户函数列举"></a>常用用户函数列举</h2><p>学习英飞凌TC-264单片机时采用了逐飞的开源库，现将常用库函数总结如下：</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      PWM初始化</span></span><br><span class="line"><span class="comment">//  @param      pwmch       PWM通道号及引脚</span></span><br><span class="line"><span class="comment">//  @param      freq        PWM频率</span></span><br><span class="line"><span class="comment">//  @param      duty        PWM占空比</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:           gtm_pwm_init(ATOM0_CH7_P02_7, 50, 1000);     //ATOM 0模块的通道7 使用P02_7引脚输出PWM  PWM频率50HZ  占空比百分之1000/GTM_ATOM0_PWM_DUTY_MAX*100</span></span><br><span class="line"><span class="comment">//							GTM_ATOM0_PWM_DUTY_MAX宏定义在zf_gtm_pwm.h  默认为10000</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gtm_pwm_init</span><span class="params">(ATOM_PIN_enum pwmch, uint32 freq, uint32 duty)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      PWM占空比设置</span></span><br><span class="line"><span class="comment">//  @param      pwmch       PWM通道号及引脚</span></span><br><span class="line"><span class="comment">//  @param      duty        PWM占空比</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:           pwm_duty(ATOM0_CH7_P02_7, 5000);//设置占空比为百分之5000/GTM_ATOM0_PWM_DUTY_MAX*100</span></span><br><span class="line"><span class="comment">//							GTM_ATOM0_PWM_DUTY_MAX宏定义在zf_gtm_pwm.h  默认为10000</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pwm_duty</span><span class="params">(ATOM_PIN_enum pwmch, uint32 duty)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      校验FLASH是否有数据</span></span><br><span class="line"><span class="comment">//  @param      sector_num 		需要写入的扇区编号   参数范围0-11</span></span><br><span class="line"><span class="comment">//  @param      page_num	 	当前扇区页的编号     参数范围0-1023</span></span><br><span class="line"><span class="comment">//  @return     				返回1有数据，返回0没有数据，如果需要对有数据的区域写入新的数据则应该对所在扇区进行擦除操作</span></span><br><span class="line"><span class="comment">//  @since      v1.0</span></span><br><span class="line"><span class="comment">//  Sample usage:               flash_check(0,0);//校验0号扇区，第0页是否有数据</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">uint8 <span class="title">flash_check</span><span class="params">(uint32 sector_num, uint32 page_num)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      擦除扇区</span></span><br><span class="line"><span class="comment">//  @param      sector_num 		需要写入的扇区编号   参数范围0-11</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  @since      v1.0</span></span><br><span class="line"><span class="comment">//  Sample usage:               eeprom_erase_sector(0);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eeprom_erase_sector</span><span class="params">(uint32 sector_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      编程一页</span></span><br><span class="line"><span class="comment">//  @param      sector_num 		需要写入的扇区编号   参数范围0-11</span></span><br><span class="line"><span class="comment">//  @param      page_num 		需要写入的页编号     参数范围0-1023</span></span><br><span class="line"><span class="comment">//  @param      buf 		   	需要写入的数据地址   传入的数组类型必须为uint32</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  @since      v1.0</span></span><br><span class="line"><span class="comment">//  Sample usage:				eeprom_page_program(0,0, &amp;buf);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eeprom_page_program</span><span class="params">(uint32 sector_num, uint32 page_num, uint32 *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      eru触发dma初始化</span></span><br><span class="line"><span class="comment">//  @param      dma_ch           	选择DMA通道</span></span><br><span class="line"><span class="comment">//  @param      source_addr         设置源地址</span></span><br><span class="line"><span class="comment">//  @param      destination_addr    设置目的地址</span></span><br><span class="line"><span class="comment">//  @param      eru_pin				设置触发的eru通道</span></span><br><span class="line"><span class="comment">//  @param      trigger				设置触发方式</span></span><br><span class="line"><span class="comment">//  @param      dma_count			设置dma搬移次数</span></span><br><span class="line"><span class="comment">//	@return		void</span></span><br><span class="line"><span class="comment">//  Sample usage:</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">uint8 <span class="title">eru_dma_init</span><span class="params">(IfxDma_ChannelId dma_ch, uint8 *source_addr, uint8 *destination_addr, ERU_PIN_enum eru_pin, TRIGGER_enum trigger, uint16 dma_count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      dma启动</span></span><br><span class="line"><span class="comment">//  @param      dma_ch           	选择DMA通道</span></span><br><span class="line"><span class="comment">//	@return		void</span></span><br><span class="line"><span class="comment">//  Sample usage:</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_start</span><span class="params">(IfxDma_ChannelId dma_ch)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      dma停止</span></span><br><span class="line"><span class="comment">//  @param      dma_ch           	选择DMA通道</span></span><br><span class="line"><span class="comment">//	@return		void</span></span><br><span class="line"><span class="comment">//  Sample usage:</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_stop</span><span class="params">(IfxDma_ChannelId dma_ch)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      eru初始化(gpio中断)</span></span><br><span class="line"><span class="comment">//  @param      eru_pin         设置eru通道及引脚</span></span><br><span class="line"><span class="comment">//  @param      trigger         设置触发方式</span></span><br><span class="line"><span class="comment">//	@return		void</span></span><br><span class="line"><span class="comment">//  Sample usage:				eru_init(ERU_CH0_REQ0_P15_4, RISING);//eru通道0 使用P10_7引脚，上升沿触发中断</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eru_init</span><span class="params">(ERU_PIN_enum eru_pin, TRIGGER_enum trigger)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      开启eru中断</span></span><br><span class="line"><span class="comment">//  @param      eru_pin         设置eru通道及引脚</span></span><br><span class="line"><span class="comment">//	@return		void</span></span><br><span class="line"><span class="comment">//  Sample usage:				eru_enable_interrupt(ERU_CH0_REQ0_P15_4);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eru_enable_interrupt</span><span class="params">(ERU_PIN_enum eru_pin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      关闭eru中断</span></span><br><span class="line"><span class="comment">//  @param      eru_pin         设置eru通道及引脚</span></span><br><span class="line"><span class="comment">//	@return		void</span></span><br><span class="line"><span class="comment">//  Sample usage:				eru_disable_interrupt(ERU_CH0_REQ0_P15_4);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eru_disable_interrupt</span><span class="params">(ERU_PIN_enum eru_pin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      获取GPIO基地址</span></span><br><span class="line"><span class="comment">//  @param      pin         选择的引脚 (可选择范围由 common.h 内PIN_enum枚举值确定)</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:           文件内部使用，用户无需关心</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">volatile</span> Ifx_P* <span class="title">get_port</span><span class="params">(PIN_enum pin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      GPIO初始化</span></span><br><span class="line"><span class="comment">//  @param      pin         选择的引脚 (可选择范围由 common.h 内PIN_enum枚举值确定)</span></span><br><span class="line"><span class="comment">//  @param      dir         引脚的方向   输出：GPO   输入：GPI</span></span><br><span class="line"><span class="comment">//  @param      dat         引脚初始化时设置的电平状态，输出时有效 0：低电平 1：高电平</span></span><br><span class="line"><span class="comment">//  @param      pinmode     引脚配置（可设置参数由zf_gpio.h文件内GPIOMODE_enum枚举值确定）</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:           gpio_init(P00_0, GPO, 1, PUSHPULL);//P00_0初始化为GPIO功能、输出模式、输出高电平、推挽输出</span></span><br><span class="line"><span class="comment">//  @note					需要特别注意P20_2是不能用于输出的，仅仅只有输入的功能</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpio_init</span><span class="params">(PIN_enum pin, GPIODIR_enum dir, uint8 dat, GPIOMODE_enum pinmode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      GPIO引脚驱动模式</span></span><br><span class="line"><span class="comment">//  @param      pin         选择的引脚 (可选择范围由 common.h 内PIN_enum枚举值确定)</span></span><br><span class="line"><span class="comment">//  @param      pin_driver 	引脚驱动模式设置</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:           gpio_pin_driver(P00_0, IfxPort_PadDriver_cmosAutomotiveSpeed1)</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpio_pin_driver</span><span class="params">(PIN_enum pin, IfxPort_PadDriver pin_driver)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      GPIO输出设置</span></span><br><span class="line"><span class="comment">//  @param      pin         选择的引脚 (可选择范围由 common.h 内PIN_enum枚举值确定)</span></span><br><span class="line"><span class="comment">//  @param      dat         0：低电平 1：高电平</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:           gpio_set(P00_0, 1);//P00_0 输出高电平</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpio_set</span><span class="params">(PIN_enum pin, uint8 dat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dat) IfxPort_setPinHigh(get_port(pin), pin&amp;<span class="number">0x1f</span>);</span><br><span class="line">    <span class="keyword">else</span>    IfxPort_setPinLow(get_port(pin), pin&amp;<span class="number">0x1f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      GPIO状态获取</span></span><br><span class="line"><span class="comment">//  @param      pin         选择的引脚 (可选择范围由 common.h 内PIN_enum枚举值确定)</span></span><br><span class="line"><span class="comment">//  @return     uint8       0：低电平 1：高电平</span></span><br><span class="line"><span class="comment">//  Sample usage:           uint8 status = gpio_get(P00_0);//获取P00_0引脚电平</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">uint8 <span class="title">gpio_get</span><span class="params">(PIN_enum pin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      GPIO方向设置</span></span><br><span class="line"><span class="comment">//  @param      pin         选择的引脚 (可选择范围由 common.h 内PIN_enum枚举值确定)</span></span><br><span class="line"><span class="comment">//  @param      dir         引脚的方向   输出：GPO   输入：GPI</span></span><br><span class="line"><span class="comment">//  @param      pinmode     引脚配置（可设置参数由zf_gpio.h文件内GPIOMODE_enum枚举值确定）</span></span><br><span class="line"><span class="comment">//  @return     void        </span></span><br><span class="line"><span class="comment">//  Sample usage:           gpio_dir(P00_0, GPO, PUSHPULL);//设置P00_0为推挽输出模式</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpio_dir</span><span class="params">(PIN_enum pin, GPIODIR_enum dir, GPIOMODE_enum pinmode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      GPIO 翻转</span></span><br><span class="line"><span class="comment">//  @param      pin         选择的引脚 (可选择范围由 common.h 内PIN_enum枚举值确定)</span></span><br><span class="line"><span class="comment">//  @return     void        </span></span><br><span class="line"><span class="comment">//  Sample usage:           gpio_toggle(P00_0);//P00_0引脚电平翻转</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpio_toggle</span><span class="params">(PIN_enum pin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      GPT12初始化（编码器采集）</span></span><br><span class="line"><span class="comment">//  @param      gptn         	选择所使用的GPT12定时器</span></span><br><span class="line"><span class="comment">//  @param      count_pin 		设置计数引脚</span></span><br><span class="line"><span class="comment">//  @param      dir_pin     	设置计数方向引脚</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:           	gpt12_init(GPT12_T2, GPT12_T2INA_P00_7, GPT12_T2EUDA_P00_8);//使用T2定时器   P00_7引脚进行计数    计数方向使用P00_8引脚</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpt12_init</span><span class="params">(GPTN_enum gptn, GPT_PIN_enum count_pin, GPT_PIN_enum dir_pin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      GPT12计数读取（编码器采集）</span></span><br><span class="line"><span class="comment">//  @param      gptn         	选择所使用的GPT12定时器</span></span><br><span class="line"><span class="comment">//  @return     int16</span></span><br><span class="line"><span class="comment">//  Sample usage:           	speed = gpt12_get(GPT12_T2);//使用T2定时器</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">int16 <span class="title">gpt12_get</span><span class="params">(GPTN_enum gptn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      清除GPT12计数（编码器采集）</span></span><br><span class="line"><span class="comment">//  @param      gptn         	选择所使用的GPT12定时器</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:           	gpt12_clear(GPT12_T2);//使用T2定时器</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpt12_clear</span><span class="params">(GPTN_enum gptn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      SPI初始化</span></span><br><span class="line"><span class="comment">//  @param      spi_n           选择SPI模块(SPI_1-SPI_4)</span></span><br><span class="line"><span class="comment">//  @param      cs_pin          选择SPI片选引脚</span></span><br><span class="line"><span class="comment">//  @param      sck_pin         选择SPI时钟引脚</span></span><br><span class="line"><span class="comment">//  @param      mosi_pin        选择SPI MOSI引脚</span></span><br><span class="line"><span class="comment">//  @param      miso_pin        选择SPI MISO引脚</span></span><br><span class="line"><span class="comment">//  @param      mode            SPI模式 0：CPOL=0 CPHA=0    1：CPOL=0 CPHA=1   2：CPOL=1 CPHA=0   3：CPOL=1 CPHA=1 //具体细节可自行百度</span></span><br><span class="line"><span class="comment">//  @param      baud            设置SPI的波特率</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:               spi_init(SPI_2, SPI2_SCLK_P15_3, SPI2_MOSI_P15_5, SPI2_MISO_P15_4, SPI2_CS0_P15_2, 0, 1*1000*1000);//硬件SPI初始化  模式0 波特率为1Mhz</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spi_init</span><span class="params">(SPIN_enum spi_n, SPI_PIN_enum sck_pin, SPI_PIN_enum mosi_pin, SPI_PIN_enum miso_pin, SPI_PIN_enum cs_pin, uint8 mode, uint32 baud)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      SPI发送接收函数</span></span><br><span class="line"><span class="comment">//  @param      spi_n           选择SPI模块   (SPI_1-SPI_4)</span></span><br><span class="line"><span class="comment">//  @param      cs_pin          选择SPI片选引脚</span></span><br><span class="line"><span class="comment">//  @param      modata          发送的数据缓冲区地址</span></span><br><span class="line"><span class="comment">//  @param      midata          发送数据时接收到的数据的存储地址(不需要接收则传 NULL)</span></span><br><span class="line"><span class="comment">//  @param      len             发送的字节数</span></span><br><span class="line"><span class="comment">//  @param      continuous      本次通信是CS是否持续保持有效状态 1:持续保持  0:每传输完一个字节关闭CS(一般设置为1 即可)</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  @since      v2.0</span></span><br><span class="line"><span class="comment">//  Sample usage:       		spi_mosi(SPI_2,SPI2_CS0_P15_2,buf,buf,1,1);    //发送buff的内容，并接收到buf里，长度为1字节 通信期间CS持续拉低</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spi_mosi</span><span class="params">(SPIN_enum spi_n, SPI_PIN_enum cs_pin, uint8 *modata, uint8 *midata, uint32 len, uint8 continuous)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------以下宏定义用于延时------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> systick_delay_ms(stmn, time)	systick_delay(stmn, time*1000000)   <span class="comment">//设置延时时间  单位ms</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> systick_delay_us(stmn, time)	systick_delay(stmn, time*1000)      <span class="comment">//设置延时时间  单位us</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> systick_delay_ns(stmn, time)	systick_delay(stmn, time)   		<span class="comment">//设置延时时间  单位ns</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------以下宏定义用于获取当前时间------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> systick_getval_ms(stmn)         systick_getval(stmn)/100000         <span class="comment">//获取当前计时时间  单位ms</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> systick_getval_us(stmn)         systick_getval(stmn)/100            <span class="comment">//获取当前计时时间  单位us</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> systick_getval_ns(stmn)         systick_getval(stmn)*10    			<span class="comment">//获取当前计时时间  单位ns</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      systick定时器启动</span></span><br><span class="line"><span class="comment">//  @param      stmn			选择使用的模块</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:				systick_start(STM0);//记录下当前的时间</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">systick_start</span><span class="params">(STMN_enum stmn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief     获得当前System tick timer的值</span></span><br><span class="line"><span class="comment">//  @param     stmn				选择使用的模块</span></span><br><span class="line"><span class="comment">//  @return    uint32 			返回从开始到现在的时间(单位10ns)</span></span><br><span class="line"><span class="comment">//  Sample usage:               uint32 tim = systick_getval(STM0);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">uint32 <span class="title">systick_getval</span><span class="params">(STMN_enum stmn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      串口初始化</span></span><br><span class="line"><span class="comment">//  @param      uartn           串口模块号(UART_0,UART_1,UART_2,UART_3)</span></span><br><span class="line"><span class="comment">//  @param      baud            串口波特率</span></span><br><span class="line"><span class="comment">//  @param      tx_pin          串口发送引脚</span></span><br><span class="line"><span class="comment">//  @param      rx_pin          串口接收引脚</span></span><br><span class="line"><span class="comment">//  @return     uint32          实际波特率</span></span><br><span class="line"><span class="comment">//  Sample usage:               uart_init(UART_0,115200,UART0_TX_P14_0,UART0_RX_P14_1);       // 初始化串口0 波特率115200 发送引脚使用P14_0 接收引脚使用P14_1</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">(UARTN_enum uartn, uint32 baud, UART_PIN_enum tx_pin, UART_PIN_enum rx_pin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      串口字节输出</span></span><br><span class="line"><span class="comment">//  @param      uartn           串口模块号(UART_0,UART_1,UART_2,UART_3)</span></span><br><span class="line"><span class="comment">//  @param      dat             需要发送的字节</span></span><br><span class="line"><span class="comment">//  @return     void        </span></span><br><span class="line"><span class="comment">//  Sample usage:               uart_putchar(UART_0, 0xA5);       // 串口0发送0xA5</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_putchar</span><span class="params">(UARTN_enum uartn, uint8 dat)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      串口发送数组</span></span><br><span class="line"><span class="comment">//  @param      uartn           串口模块号(UART_0,UART_1,UART_2,UART_3)</span></span><br><span class="line"><span class="comment">//  @param      *buff           要发送的数组地址</span></span><br><span class="line"><span class="comment">//  @param      len             发送长度</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:               uart_putbuff(UART_0,&amp;a[0],5);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_putbuff</span><span class="params">(UARTN_enum uartn, uint8 *buff, uint32 len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      串口发送字符串</span></span><br><span class="line"><span class="comment">//  @param      uartn           串口模块号(UART_0,UART_1,UART_2,UART_3)</span></span><br><span class="line"><span class="comment">//  @param      *str            要发送的字符串地址</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:               uart_putstr(UART_0,&quot;i lvoe you&quot;);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_putstr</span><span class="params">(UARTN_enum uartn, <span class="keyword">const</span> int8 *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      读取串口接收的数据（whlie等待）</span></span><br><span class="line"><span class="comment">//  @param      uartn           串口模块号(UART_0,UART_1,UART_2,UART_3)</span></span><br><span class="line"><span class="comment">//  @param      *dat            接收数据的地址</span></span><br><span class="line"><span class="comment">//  @return     void        </span></span><br><span class="line"><span class="comment">//  Sample usage:               uint8 dat; uart_getchar(UART_0,&amp;dat);       // 接收串口0数据  存在在dat变量里</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_getchar</span><span class="params">(UARTN_enum uartn, uint8 *dat)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      读取串口接收的数据（查询接收）</span></span><br><span class="line"><span class="comment">//  @param      uartn           串口模块号(UART_0,UART_1,UART_2,UART_3)</span></span><br><span class="line"><span class="comment">//  @param      *dat            接收数据的地址</span></span><br><span class="line"><span class="comment">//  @return     uint8           1：接收成功   0：未接收到数据</span></span><br><span class="line"><span class="comment">//  Sample usage:               uint8 dat; uart_query(UART_0,&amp;dat);       // 接收串口0数据  存在在dat变量里</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">uint8 <span class="title">uart_query</span><span class="params">(UARTN_enum uartn, uint8 *dat)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      ADC初始化</span></span><br><span class="line"><span class="comment">//  @param      adcn            选择ADC模块(ADC_0、ADC_1、ADC_2)</span></span><br><span class="line"><span class="comment">//  @param      ch              选择ADC通道</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:               adc_init(ADC_0, ADC0_CH0_A0);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adc_init</span><span class="params">(VADCN_enum vadc_n, VADC_CHN_enum vadc_chn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      ADC转换一次</span></span><br><span class="line"><span class="comment">//  @param      adcn            选择ADC模块(ADC_0、ADC_1、ADC_2)</span></span><br><span class="line"><span class="comment">//  @param      ch              选择ADC通道</span></span><br><span class="line"><span class="comment">//  @return     转换值</span></span><br><span class="line"><span class="comment">//  Sample usage:               adc_convert(ADC_0, ADC0_CH0_A0, ADC_12BIT);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">uint16 <span class="title">adc_convert</span><span class="params">(VADCN_enum vadc_n, VADC_CHN_enum vadc_chn, VADC_RES_enum vadc_res)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      ADC均值滤波</span></span><br><span class="line"><span class="comment">//  @param      adcn            选择ADC模块(ADC_0、ADC_1、ADC_2)</span></span><br><span class="line"><span class="comment">//  @param      ch              选择ADC通道</span></span><br><span class="line"><span class="comment">//  @param      count           均值滤波次数</span></span><br><span class="line"><span class="comment">//  @return     平均转换值</span></span><br><span class="line"><span class="comment">//  Sample usage:               adc_mean_filter(ADC_0, ADC0_CH0_A0, ADC_12BIT, 5);//采集5次 然后返回平均值</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">uint16 <span class="title">adc_mean_filter</span><span class="params">(VADCN_enum vadc_n, VADC_CHN_enum vadc_chn, VADC_RES_enum vadc_res, uint8 count)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>单片机</category>
        <category>infineon</category>
        <category>函数库</category>
      </categories>
      <tags>
        <tag>智能车</tag>
      </tags>
  </entry>
  <entry>
    <title>记MPU6050模块的学习过程</title>
    <url>/2021/04/05/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文为我自己学习MPU6050的过程以及其过程中遇到的问题，将其记录下来以方便自己以后再次使用，同时也是为了防止遗忘。</p>
<p>学习过程中用到的资料整理了下存了起来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.lanzous.com/iROIKnjuo6h</span><br><span class="line">密码:gzai</span><br></pre></td></tr></table></figure>

<p>环境：<strong>STM32F401CCU6+CubeMX+HAL库</strong></p>
<span id="more"></span>

<hr>
<h2 id="模块组成："><a href="#模块组成：" class="headerlink" title="模块组成："></a>模块组成：</h2><p> MPU6050+HMC5883L+MS5611 </p>
<h3 id="MPU6050：加速度计-陀螺仪"><a href="#MPU6050：加速度计-陀螺仪" class="headerlink" title="MPU6050：加速度计+陀螺仪"></a>MPU6050：加速度计+陀螺仪</h3><h3 id="HMC5883L：-3轴数字罗盘"><a href="#HMC5883L：-3轴数字罗盘" class="headerlink" title="HMC5883L：  3轴数字罗盘"></a>HMC5883L：  3轴数字罗盘</h3><h3 id="MS5611-：气压传感器"><a href="#MS5611-：气压传感器" class="headerlink" title="MS5611 ：气压传感器"></a>MS5611 ：气压传感器</h3><hr>
<h2 id="模块引脚定义："><a href="#模块引脚定义：" class="headerlink" title="模块引脚定义："></a>模块引脚定义：</h2><p>以下引脚用途以及配置为个人对与数据手册内容的理解，可能有误。</p>
<h3 id="VCC-IN-5V电源输入"><a href="#VCC-IN-5V电源输入" class="headerlink" title="VCC_IN:5V电源输入"></a>VCC_IN:5V电源输入</h3><h3 id="3-3V：3-3V电源输入"><a href="#3-3V：3-3V电源输入" class="headerlink" title="3.3V：3.3V电源输入"></a>3.3V：3.3V电源输入</h3><h3 id="GND：接地"><a href="#GND：接地" class="headerlink" title="GND：接地"></a>GND：接地</h3><h3 id="SCL：IIC总线时钟"><a href="#SCL：IIC总线时钟" class="headerlink" title="SCL：IIC总线时钟"></a>SCL：IIC总线时钟</h3><h3 id="SDA：IIC总线数据输入"><a href="#SDA：IIC总线数据输入" class="headerlink" title="SDA：IIC总线数据输入"></a>SDA：IIC总线数据输入</h3><h3 id="FSYNC：（MPU6050）"><a href="#FSYNC：（MPU6050）" class="headerlink" title="FSYNC：（MPU6050）"></a>FSYNC：（MPU6050）</h3><p>​    Frame synchronization digital input. Connect to GND if unused</p>
<p>​    帧同步数字输入。 如果未使用，则连接到GND</p>
<h3 id="（GND）"><a href="#（GND）" class="headerlink" title="（GND）"></a>（GND）</h3><h3 id="INTA：（MPU6050）"><a href="#INTA：（MPU6050）" class="headerlink" title="INTA：（MPU6050）"></a>INTA：（MPU6050）</h3><p>​    Interrupt digital output (totem pole or open-drain)</p>
<p>​    中断数字输出（图腾柱或漏极开路）</p>
<p>​     Interrupt functionality is configured via the Interrupt Configuration register. Items that are configurable include the INT pin configuration, the interrupt latching and clearing method, and triggers for the interrupt. Items that can trigger an interrupt are </p>
<p>(1) Clock generator locked to new reference oscillator (used when switching clock sources); </p>
<p>(2) new data is available to be read (from the FIFO and Data registers); </p>
<p>(3) accelerometer event interrupts; </p>
<p>(4) the MPU-60X0 did not receive an knowledge from an auxiliary sensor on the secondary I2C bus. The interrupt status can be read from the Interrupt Status register.  </p>
<h3 id="（配置为外部中断）"><a href="#（配置为外部中断）" class="headerlink" title="（配置为外部中断）"></a>（配置为外部中断）</h3><h3 id="DRDY：（HMC5883L）"><a href="#DRDY：（HMC5883L）" class="headerlink" title="DRDY：（HMC5883L）"></a>DRDY：（HMC5883L）</h3><p>​    Data Ready, Interrupt Pin. Internally pulled high. Optional connection. Low for 250 µsec when data is placed in the data output registers.</p>
<p>​    数据准备，中断引脚。内部被拉高。可选连接，当数据位于输出寄存器 上时会在低电位上停250μs。（理解为数据传输完成标志引脚）</p>
<h3 id="（配置为外部中断）-1"><a href="#（配置为外部中断）-1" class="headerlink" title="（配置为外部中断）"></a>（配置为外部中断）</h3><hr>
<h2 id="模块使用："><a href="#模块使用：" class="headerlink" title="模块使用："></a>模块使用：</h2><h3 id="伪前言："><a href="#伪前言：" class="headerlink" title="伪前言："></a>伪前言：</h3><p>使用分为两部分，首先是为了<strong>熟悉IIC使用以及对数据手册的阅读</strong>而存在的<strong>原始数据打印</strong>部分，接下来是为了真正应用而存在的<strong>DMP库移植</strong>部分。</p>
<p>第一次进行库的移植的确会出现很多奇怪的问题，请细心细心加耐心。</p>
<p>官方的手册是好东西，请多阅读。</p>
<p><em><strong>如果只是需要使用欧拉角数据，则不需要参考第一部分内容，直接进行第二部分即可</strong></em></p>
<p><em><strong>如果只是需要使用欧拉角数据，则不需要参考第一部分内容，直接进行第二部分即可</strong></em></p>
<p><em><strong>如果只是需要使用欧拉角数据，则不需要参考第一部分内容，直接进行第二部分即可</strong></em></p>
<hr>
<h3 id="原始数据的打印："><a href="#原始数据的打印：" class="headerlink" title="原始数据的打印："></a>原始数据的打印：</h3><p>首先新建一个F401工程，在新工程里面完成IIC和UART的配置。</p>
<p>其中IIC选择IIC1，下拉栏选择IIC，配置默认即可。</p>
<p>生成工程并打开。</p>
<p>在工程文件夹中新建一个mpu6050.h文件。</p>
<p>（PS：如果是自己添加的文件需要添加包含路径，方法参考u8g2屏幕的配置文档）</p>
<p>为了方便使用，首先把要用到的寄存器在mpu6050.h中进行宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************************</span></span><br><span class="line"><span class="comment"> *设备地址  </span></span><br><span class="line"><span class="comment"> *PS：在数据手册里面的七位地址是0x68，但是HAL库中函数前面的注释有说明如下：</span></span><br><span class="line"><span class="comment"> *DevAddress Target device address: The device 7 bits address value</span></span><br><span class="line"><span class="comment"> *in datasheet must be shifted to the left before calling the interface</span></span><br><span class="line"><span class="comment"> *也就是说我们在使用时要将设备地址左移一位，而0x68左移一位是0xD0。</span></span><br><span class="line"><span class="comment"> **********************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU6050_ADDR 0xD0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//采样频率分频器寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMPRT_DIV_REG 0x19</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//陀螺仪配置寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GYRO_CONFIG_REG 0x1B</span></span><br><span class="line"><span class="comment">//角速度量程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSR1_GYRO 0   <span class="comment">//+-250°/s</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSR2_GYRO 1   <span class="comment">//+-500°/s</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSR3_GYRO 2   <span class="comment">//+-1000°/s</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSR4_GYRO 3   <span class="comment">//+-2000°/s</span></span></span><br><span class="line"><span class="comment">//角速度最低分辨率</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB1_GYRO 16384.0   <span class="comment">//+-250°/s</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB2_GYRO 8192.0   <span class="comment">//+-500°/s</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB3_GYRO 4096.0   <span class="comment">//+-1000°/s</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB4_GYRO 2048.0   <span class="comment">//+-2000°/s</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加速度配置寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACCEL_CONFIG_REG 0x1c</span></span><br><span class="line"><span class="comment">//加速度量程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSR1_ACCEL 0  <span class="comment">//+-2g</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSR2_ACCEL 1  <span class="comment">//+-4g</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSR3_ACCEL 2  <span class="comment">//+-8g</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSR4_ACCEL 3  <span class="comment">//+-16g</span></span></span><br><span class="line"><span class="comment">//加速度最低分辨率</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB1_ACCEL 131.0   <span class="comment">//+-2g</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB2_ACCEL 65.5   <span class="comment">//+-4g</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB3_ACCEL 32.8   <span class="comment">//+-8g</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB4_ACCEL 16.4   <span class="comment">//+-16g</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加速度测量值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACCEL_XOUT_H_REG 0x3B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//温度测量值</span></span><br><span class="line"><span class="comment">//温度计算公式:摄氏度=(int16_t)REG/340+36.53</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEMP_OUT_H_REG 0x41</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//陀螺仪测量值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GYRO_XOUT_H_REG 0x43</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//电源管理寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWR_MGMT_1_REG 0x6B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设备身份标识寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHO_AM_I_REG 0x75</span></span><br></pre></td></tr></table></figure>

<p>定义几个变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int16_t</span> Axo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int16_t</span> Ayo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int16_t</span> Azo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int16_t</span> Gxo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int16_t</span> Gyo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int16_t</span> Gzo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int16_t</span> Temp_RAW = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> Ax,Ay,Az,Gx,Gy,Gz,Temp;</span><br></pre></td></tr></table></figure>

<p>首先对模块进行初始化设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU6050_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> check,Data;</span><br><span class="line">	<span class="comment">//检查设备身份标识(WHO_AM_I)</span></span><br><span class="line">	HAL_I2C_Mem_Read (&amp;hi2c1 ,MPU6050_ADDR,WHO_AM_I_REG,<span class="number">1</span>,&amp;check ,<span class="number">1</span>,<span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">if</span>(check == <span class="number">104</span>)		<span class="comment">//验证设备地址</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//在电源管理寄存器中写入0来使能传感器</span></span><br><span class="line">		Data = <span class="number">0</span>;</span><br><span class="line">		HAL_I2C_Mem_Write (&amp;hi2c1 ,MPU6050_ADDR ,PWR_MGMT_1_REG ,<span class="number">1</span>,&amp;Data ,<span class="number">1</span>,<span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//设置采样频率</span></span><br><span class="line">		Data = <span class="number">0x07</span>;</span><br><span class="line">		HAL_I2C_Mem_Write (&amp;hi2c1 ,MPU6050_ADDR ,SMPRT_DIV_REG ,<span class="number">1</span> ,&amp;Data,<span class="number">1</span>,<span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//设置加速度量程</span></span><br><span class="line">		Data = FSR1_ACCEL;</span><br><span class="line">		HAL_I2C_Mem_Write (&amp;hi2c1 ,MPU6050_ADDR, ACCEL_CONFIG_REG, <span class="number">1</span>, &amp;Data, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//设置陀螺仪量程</span></span><br><span class="line">		Data = FSR1_GYRO;</span><br><span class="line">		HAL_I2C_Mem_Write (&amp;hi2c1 ,MPU6050_ADDR, GYRO_CONFIG_REG, <span class="number">1</span>, &amp;Data, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对几个重要寄存器做一些说明：</p>
<p><strong>1.采样频率分频器：</strong></p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617031200192-1620477659491.png" alt="1617031200192"></p>
<p>采样频率的计算公式为：</p>
<p>​    <strong>采样频率=陀螺仪输出频率/（ 1+SMPLRT_DIV  ）</strong></p>
<p>而陀螺仪的输出频率是受到DLPF（数字低通滤波器）的配置影响的，具体影响如下图：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617031379242-1620477659492.png" alt="1617031379242"></p>
<p>而上述滤波器在配置寄存器中进行设置：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617031435930-1620477659492.png" alt="1617031435930"></p>
<p><strong>2.陀螺仪配置寄存器</strong></p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617031496511-1620477659492.png" alt="1617031496511"></p>
<p>主要功能为触发陀螺仪自检以及陀螺仪最大量程配置，我们主要用到第二个功能。</p>
<p>自检功能：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617031878416-1620477659492.png" alt="1617031878416"></p>
<p>具体量程配置参考下表：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617031692618-1620477659492.png" alt="1617031692618"></p>
<p><strong>3.加速度配置寄存器</strong></p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617031935975-1620477659492.png" alt="1617031935975"></p>
<p>主要功能和陀螺仪配置寄存器一致，我们还是用第二个功能。</p>
<p>自检功能：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617032006471-1620477659492.png" alt="1617032006471"></p>
<p>具体量程配置参考下表：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617032031176-1620477659492.png" alt="1617032031176"></p>
<p><strong>4.测量值寄存器</strong></p>
<p>要用到的测量值寄存器有三个：加速度、陀螺仪和温度。</p>
<p>首先是加速度计：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617032142421-1620477659492.png" alt="1617032142421"></p>
<p>不难看出，数据的存储方式是用了六个字节来存储三个坐标轴的数据，其中相邻两个数据分别表示同一坐标轴数据的高八位和低八位，因此我们可以对数据如此处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义六位数组来存放寄存器值</span></span><br><span class="line"><span class="keyword">int8_t</span> Mesurment[<span class="number">6</span>];</span><br><span class="line"><span class="comment">//将寄存器值读取出来存入数组中方便后续操作</span></span><br><span class="line">HAL_I2C_Mem_Read (&amp;hi2c1 ,MPU6050_ADDR ,ACCEL_XOUT_H_REG ,<span class="number">1</span>,Mesurment ,<span class="number">6</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//以x轴数据为例，应做如下处理：</span></span><br><span class="line">Ax=(<span class="keyword">int16_t</span>)(Mesurment[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)|Mesurment[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//处理后的数据除以LSB（灵敏度最低分辨率）即可得到加速度值</span></span><br><span class="line">Accel=Ax*<span class="number">1.0</span>/<span class="number">16384</span>;</span><br></pre></td></tr></table></figure>

<p>最小分辨率取值参考下表：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617032758704-1620477659492.png" alt="1617032758704"></p>
<p>接下来是陀螺仪：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617280360231-1620477659492.png" alt="1617280360231"></p>
<p>处理方式与加速度相同，最小分辨率参考下表：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617280418367-1620477659493.png" alt="1617280418367"></p>
<p>最后是温度：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617280458545-1620477659493.png" alt="1617280458545"></p>
<p>读出数据需要按照下述公式进行处理：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617349496815-1620477659493.png" alt="1617349496815"></p>
<p><strong>5.电源管理寄存器</strong></p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617280616125-1620477659493.png" alt="1617280616125"></p>
<p>具体各位功能参考数据手册，这里我们想让他正常工作，需要将所有位置0.</p>
<p><strong>6.设备身份标识寄存器</strong></p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617280733301-1620477659493.png" alt="1617280733301"></p>
<p>说明设备地址的寄存器，若AD0接地，则最低位位0，设备地址为0x68;</p>
<p>若AD0置高，则最低位为1，设备地址为0x69.</p>
<p>配置完模块后，只要自己写出函数将数据读出打印出来即可。</p>
<p>以下读取函数仅作参考：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//陀螺仪数据读取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GYRO_READ</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> Mesurment[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">  HAL_I2C_Mem_Read(&amp;hi2c1,MPU6050_ADDR,GYRO_XOUT_H_REG,<span class="number">1</span>,Mesurment,<span class="number">6</span>,<span class="number">1000</span>);</span><br><span class="line">  	Gxo = (<span class="keyword">int16_t</span> )(Mesurment [<span class="number">0</span>] &lt;&lt; <span class="number">8</span> | Mesurment [<span class="number">1</span>]);</span><br><span class="line">	Gyo = (<span class="keyword">int16_t</span> )(Mesurment [<span class="number">2</span>] &lt;&lt; <span class="number">8</span> | Mesurment [<span class="number">3</span>]);</span><br><span class="line">	Gzo = (<span class="keyword">int16_t</span> )(Mesurment [<span class="number">4</span>] &lt;&lt; <span class="number">8</span> | Mesurment [<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">  	Gx = (<span class="keyword">double</span>)Gxo/LSB1_GYRO;</span><br><span class="line">	Gy = (<span class="keyword">double</span>)Gyo/LSB1_GYRO;</span><br><span class="line">	Gz = (<span class="keyword">double</span>)Gzo/LSB1_GYRO;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加速度数据读取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ACCEL_READ</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> Mesurment[<span class="number">6</span>];</span><br><span class="line">	</span><br><span class="line">	HAL_I2C_Mem_Read (&amp;hi2c1 ,MPU6050_ADDR ,ACCEL_XOUT_H_REG ,<span class="number">1</span>,Mesurment ,<span class="number">6</span>,<span class="number">1000</span>);</span><br><span class="line">	</span><br><span class="line">	Axo = (<span class="keyword">int16_t</span> )(Mesurment [<span class="number">0</span>] &lt;&lt;<span class="number">8</span> | Mesurment [<span class="number">1</span>]);</span><br><span class="line">	Ayo = (<span class="keyword">int16_t</span> )(Mesurment [<span class="number">2</span>] &lt;&lt;<span class="number">8</span> | Mesurment [<span class="number">3</span>]);</span><br><span class="line">	Azo = (<span class="keyword">int16_t</span> )(Mesurment [<span class="number">4</span>] &lt;&lt;<span class="number">8</span> | Mesurment [<span class="number">5</span>]);</span><br><span class="line">	</span><br><span class="line">	Ax = (<span class="keyword">double</span>) Axo / LSB1_ACCEL;</span><br><span class="line">	Ay = (<span class="keyword">double</span>) Ayo / LSB1_ACCEL;</span><br><span class="line">	Az = (<span class="keyword">double</span>) Azo / LSB1_ACCEL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//温度数据读取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TEMP_READ</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> Mesurment[<span class="number">2</span>];</span><br><span class="line">	</span><br><span class="line">	HAL_I2C_Mem_Read (&amp;hi2c1 ,MPU6050_ADDR ,TEMP_OUT_H_REG ,<span class="number">1</span> ,Mesurment  ,<span class="number">2</span> ,<span class="number">1000</span>);</span><br><span class="line">	</span><br><span class="line">	Tempo = (<span class="keyword">int16_t</span> )(Mesurment [<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)|Mesurment [<span class="number">1</span>];</span><br><span class="line">	Temp = <span class="number">36.53</span> + Tempo * <span class="number">1.0</span> / <span class="number">340</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此，第一部分结束。</p>
<hr>
<h3 id="DMP库移植"><a href="#DMP库移植" class="headerlink" title="DMP库移植"></a>DMP库移植</h3><p>首先新建一个F401工程，在新工程里面完成IIC和UART的配置。</p>
<p>其中IIC选择IIC1，下拉栏选择IIC，配置默认即可。</p>
<p>生成工程并打开。</p>
<p>先把我们要移植的库文件复制到工程文件夹中：</p>
<p>下载并解压“MPU6050资料”这一文件，文件内容以及具体文件路径在README中有说明。</p>
<p>解压官方库文件“motion_driver_6.12.7z”</p>
<p>复制库文件和包含文件所在的两个文件夹，粘贴到工程文件夹。<img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617352471139-1620477659493.png" alt="1617352471139"></p>
<p>回到keil中，新建文件夹命名为DMP</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617352556822-1620477659493.png" alt="1617352556822"></p>
<p>双击文件夹为其中添加库文件：</p>
<p>记得将文件类型的筛选改成所有文件<img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617352641220-1620477659493.png" alt="1617352641220"></p>
<p>全选eMPL中的6个文件点击添加：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617352677192-1620477659493.png" alt="1617352677192"></p>
<p>接下来添加所需的包含路径：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617352990063-1620477659493.png" alt="1617352990063"></p>
<p>添加这两个文件：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617353030848-1620477659493.png" alt="1617353030848"></p>
<p>接下来添加我们要用到的包含文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inv_mpu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inv_mpu_dmp_motion_driver.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>这时编译一下<del>应该是0 errors</del></p>
<p>咳咳  应该是</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617353398948-1620477659493.png" alt="1617353398948"></p>
<p>那么接下来我们来修改库文件。</p>
<p>打开inv_mpu.c</p>
<p>可以看到这里官方已经为我们写好了F4的接口，只需要我们定义一个宏即可。复制一下宏的内容，打开选项界面选择C/C++，在上面的define中添加预编译的内容，即刚刚复制的宏，顺手把优化改到最低（方便后面出问题调试）：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617353709603-1620477659493.png" alt="1617353709603"></p>
<p>编译：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617353777911-1620477659493.png" alt="1617353777911"></p>
<p>我们来看看这两个错误：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617353828850-1620477659493.png" alt="1617353828850"></p>
<p>都是”board-st_discovery.h”没有找到导致的，这个文件是官方的测试工程中用到的文件，所以直接删除对于我们没有影响。</p>
<p>双击对应的错误传送带对应位置删除宏定义代码，</p>
<p>编译：<del>0 errors！！！</del></p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617354000906-1620477659493.png" alt="1617354000906"></p>
<p>缓缓的打出一堆问号？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？</p>
<p>别急，我们慢慢解决。</p>
<p>首先让我们好好读一下官方的说明：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617354101759-1620477659493.png" alt="1617354101759"></p>
<p>明确的说明了我们需要定义这四个函数来使库正常工作。而下面的宏定义就是留给我们的函数接口，于是我们开始写一下这几个函数。</p>
<p>首先根据网上资料，get_ms函数没什么用，所以下一个空函数防止报错;</p>
<p>delay_ms函数直接调用HAL库的延时函数；</p>
<p>而i2c_read和i2c_write我们通过调用HAL库的IIC函数来实现，需要注意的是HAL库函数与需要的函数参数个数和顺序都不一样。</p>
<p>参考代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空函数防止报错</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mget_ms</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *time)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用HAL库函数</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">i2c_write</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> slave_addr, <span class="keyword">unsigned</span> <span class="keyword">char</span> reg_addr,<span class="keyword">unsigned</span> <span class="keyword">char</span> length, <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">const</span> *data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line">	res=HAL_I2C_Mem_Write(&amp;hi2c1,slave_addr,reg_addr,<span class="number">1</span>,(<span class="keyword">uint8_t</span> *)data,length,<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">i2c_read</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> slave_addr, <span class="keyword">unsigned</span> <span class="keyword">char</span> reg_addr,<span class="keyword">unsigned</span> <span class="keyword">char</span> length, <span class="keyword">unsigned</span> <span class="keyword">char</span> *data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    res=HAL_I2C_Mem_Read(&amp;hi2c1,slave_addr,reg_addr,<span class="number">1</span>,(<span class="keyword">uint8_t</span> *)data,length,<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于之前提到的HAL库IIC地址偏移特性，我们需要把库里面的设备地址改为0xD0:</p>
<p>在inv_mpu.c中搜索0x68:</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617357292231-1620477659493.png" alt="1617357292231"></p>
<p>改为0xD0:</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617357328178-1620477659493.png" alt="1617357328178"></p>
<p>把函数接口改成我们的函数名：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617354938152-1620477659493.png" alt="1617354938152"></p>
<p>记得inv_mpu_dmp_motion_driver.c中的接口也要改：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617355462081-1620477659493.png" alt="1617355462081"></p>
<p>编译，会看到一堆错误中有这样一个画风清奇：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617355116084-1620477659493.png" alt="1617355116084"></p>
<p>这是在提醒我们要定义我们的模块型号，于是在预编译中添加MPU6050：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617355183949-1620477659493.png" alt="1617355183949"></p>
<p>编译：2 errors</p>
<p>我们来看看是什么错误：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617355311309-1620477659493.png" alt="1617355311309"></p>
<p>到inv_mpu_dmp_motion_driver.c中搜索operation看到</p>
<p>__no_operation();</p>
<p>看函数名就知道啥都没做，注释掉。</p>
<p>更改inv_mpu.c中log的宏，用空语句替换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log_i(...)     do &#123;&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log_e(...)     do &#123;&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>编译，0 errors！！！</p>
<p>接下来我们来调用库里面的函数进行模块的初始化以及数据的输出。</p>
<p>添加我们需要的宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN PD */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> q30  1073741824.0f</span></span><br><span class="line"><span class="comment">/* USER CODE END PD */</span></span><br></pre></td></tr></table></figure>

<p>定义我们需要的变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"><span class="keyword">float</span> pitch=<span class="number">0</span>,roll=<span class="number">0</span>,yaw=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">signed</span> <span class="keyword">char</span> gyro_orientation[<span class="number">9</span>] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                           <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">                                           <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br></pre></td></tr></table></figure>

<p>定义我们需要的函数（网上抄的）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN PFP */</span></span><br><span class="line"><span class="comment">//得到dmp处理后的数据(注意,本函数需要比较多堆栈,局部变量有点多)</span></span><br><span class="line"><span class="comment">//pitch:俯仰角 精度:0.1°   范围:-90.0° &lt;---&gt; +90.0°</span></span><br><span class="line"><span class="comment">//roll:横滚角  精度:0.1°   范围:-180.0°&lt;---&gt; +180.0°</span></span><br><span class="line"><span class="comment">//yaw:航向角   精度:0.1°   范围:-180.0°&lt;---&gt; +180.0°</span></span><br><span class="line"><span class="comment">//返回值:0,正常</span></span><br><span class="line"><span class="comment">//    其他,失败</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">mpu_dmp_get_data</span><span class="params">(<span class="keyword">float</span> *pitch,<span class="keyword">float</span> *roll,<span class="keyword">float</span> *yaw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> q0=<span class="number">1.0f</span>,q1=<span class="number">0.0f</span>,q2=<span class="number">0.0f</span>,q3=<span class="number">0.0f</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sensor_timestamp;</span><br><span class="line">	<span class="keyword">short</span> gyro[<span class="number">3</span>], accel[<span class="number">3</span>], sensors;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> more;</span><br><span class="line">	<span class="keyword">long</span> quat[<span class="number">4</span>]; </span><br><span class="line">	<span class="keyword">if</span>(dmp_read_fifo(gyro, accel, quat, &amp;sensor_timestamp, &amp;sensors,&amp;more))<span class="keyword">return</span> <span class="number">1</span>;	 </span><br><span class="line">	<span class="comment">/* Gyro and accel data are written to the FIFO by the DMP in chip frame and hardware units.</span></span><br><span class="line"><span class="comment">	 * This behavior is convenient because it keeps the gyro and accel outputs of dmp_read_fifo and mpu_read_fifo consistent.</span></span><br><span class="line"><span class="comment">	**/</span></span><br><span class="line">	<span class="comment">/*if (sensors &amp; INV_XYZ_GYRO )</span></span><br><span class="line"><span class="comment">	send_packet(PACKET_TYPE_GYRO, gyro);</span></span><br><span class="line"><span class="comment">	if (sensors &amp; INV_XYZ_ACCEL)</span></span><br><span class="line"><span class="comment">	send_packet(PACKET_TYPE_ACCEL, accel); */</span></span><br><span class="line">	<span class="comment">/* Unlike gyro and accel, quaternions are written to the FIFO in the body frame, q30.</span></span><br><span class="line"><span class="comment">	 * The orientation is set by the scalar passed to dmp_set_orientation during initialization. </span></span><br><span class="line"><span class="comment">	**/</span></span><br><span class="line">	<span class="keyword">if</span>(sensors&amp;INV_WXYZ_QUAT) </span><br><span class="line">	&#123;</span><br><span class="line">		q0 = quat[<span class="number">0</span>] / q30;	<span class="comment">//q30格式转换为浮点数</span></span><br><span class="line">		q1 = quat[<span class="number">1</span>] / q30;</span><br><span class="line">		q2 = quat[<span class="number">2</span>] / q30;</span><br><span class="line">		q3 = quat[<span class="number">3</span>] / q30; </span><br><span class="line">		<span class="comment">//计算得到俯仰角/横滚角/航向角</span></span><br><span class="line">		*pitch = <span class="built_in">asin</span>(<span class="number">-2</span> * q1 * q3 + <span class="number">2</span> * q0* q2)* <span class="number">57.3</span>;	<span class="comment">// pitch</span></span><br><span class="line">		*roll  = <span class="built_in">atan2</span>(<span class="number">2</span> * q2 * q3 + <span class="number">2</span> * q0 * q1, <span class="number">-2</span> * q1 * q1 - <span class="number">2</span> * q2* q2 + <span class="number">1</span>)* <span class="number">57.3</span>;	<span class="comment">// roll</span></span><br><span class="line">		*yaw   = <span class="built_in">atan2</span>(<span class="number">2</span>*(q1*q2 + q0*q3),q0*q0+q1*q1-q2*q2-q3*q3) * <span class="number">57.3</span>;	<span class="comment">//yaw</span></span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_self_test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result;</span><br><span class="line">	<span class="keyword">char</span> test_packet[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">long</span> gyro[<span class="number">3</span>], accel[<span class="number">3</span>]; </span><br><span class="line">	result = mpu_run_self_test(gyro, accel);</span><br><span class="line">	<span class="keyword">if</span> (result == <span class="number">0x7</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Test passed. We can trust the gyro data here, so let&#x27;s push it down</span></span><br><span class="line"><span class="comment">		* to the DMP.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">float</span> sens;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">short</span> accel_sens;</span><br><span class="line">		mpu_get_gyro_sens(&amp;sens);</span><br><span class="line">		gyro[<span class="number">0</span>] = (<span class="keyword">long</span>)(gyro[<span class="number">0</span>] * sens);</span><br><span class="line">		gyro[<span class="number">1</span>] = (<span class="keyword">long</span>)(gyro[<span class="number">1</span>] * sens);</span><br><span class="line">		gyro[<span class="number">2</span>] = (<span class="keyword">long</span>)(gyro[<span class="number">2</span>] * sens);</span><br><span class="line">		dmp_set_gyro_bias(gyro);</span><br><span class="line">		mpu_get_accel_sens(&amp;accel_sens);</span><br><span class="line">		accel[<span class="number">0</span>] *= accel_sens;</span><br><span class="line">		accel[<span class="number">1</span>] *= accel_sens;</span><br><span class="line">		accel[<span class="number">2</span>] *= accel_sens;</span><br><span class="line">		dmp_set_accel_bias(accel);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//DMP初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">mpu_dmp_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint8_t</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">int_param_s</span> <span class="title">int_param</span>;</span><span class="comment">//这个没什么用，就是为了能给他实参调用起来</span></span><br><span class="line">	<span class="keyword">if</span>(mpu_init(&amp;int_param)==<span class="number">0</span>)	<span class="comment">//初始化MPU6050</span></span><br><span class="line">	&#123;	 </span><br><span class="line">		res=mpu_set_sensors(INV_XYZ_GYRO|INV_XYZ_ACCEL);<span class="comment">//设置所需要的传感器</span></span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">		res=mpu_configure_fifo(INV_XYZ_GYRO | INV_XYZ_ACCEL);<span class="comment">//设置FIFO</span></span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">		res=mpu_set_sample_rate(<span class="number">100</span>);	<span class="comment">//设置采样率</span></span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">3</span>; </span><br><span class="line">		res=dmp_load_motion_driver_firmware();		<span class="comment">//加载dmp固件</span></span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">4</span>; </span><br><span class="line">		<span class="comment">//res=dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation));//设置陀螺仪方向</span></span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">5</span>; </span><br><span class="line">		res=dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT|DMP_FEATURE_TAP|	<span class="comment">//设置dmp功能</span></span><br><span class="line">		    DMP_FEATURE_ANDROID_ORIENT|DMP_FEATURE_SEND_RAW_ACCEL|DMP_FEATURE_SEND_CAL_GYRO|</span><br><span class="line">		    DMP_FEATURE_GYRO_CAL);</span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">6</span>; </span><br><span class="line">		res=dmp_set_fifo_rate(<span class="number">100</span>);	<span class="comment">//设置DMP输出速率(最大不超过200Hz)</span></span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">7</span>;   </span><br><span class="line">		res=run_self_test();		<span class="comment">//自检</span></span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">8</span>;    </span><br><span class="line">		res=mpu_set_dmp_state(<span class="number">1</span>);	<span class="comment">//使能DMP</span></span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在循环前面调用初始化函数，在循环中调用数据处理函数，并打印出欧拉角的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> res;</span><br><span class="line">res = mpu_dmp_init();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">	res=mpu_dmp_get_data(&amp;pitch,&amp;roll,&amp;yaw);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.2f,%.2f,%.2f\n&quot;</span>,pitch,roll,yaw);</span><br><span class="line">   <span class="comment">/* USER CODE END WHILE */</span></span><br></pre></td></tr></table></figure>

<p>串口重定向：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 4 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch,FILE *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HAL_UART_Transmit (&amp;huart1 ,(<span class="keyword">uint8_t</span> *)&amp;ch,<span class="number">1</span>,HAL_MAX_DELAY );</span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 4 */</span></span><br></pre></td></tr></table></figure>

<p>编译烧录，就可以在串口调试助手上看到欧拉角了：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617357509432-1620477659493.png" alt="1617357509432"></p>
<p>如果出现了三个角度全为0的情况，必然是某一环出现的问题，我会将我遇到的问题在之后列举一下，可以自己使用打印对应返回值以及单步调试的方法逐步排查。</p>
<h4 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h4><p>PS：“/”表示不易出现问题，如出现问题可能是硬件问题，检查是否是未供电以及供电电压是否正确，或者可能你的模块坏掉了。</p>
<table>
<thead>
<tr>
<th align="center">函数返回值</th>
<th align="center">mpu_dmp_init函数</th>
<th align="center">mpu_dmp_get_data函数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">/</td>
<td align="center">dmp_read_fifo函数出现问题</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">/</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">/</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">/</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">/</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">/</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">/</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">说明run_self_test函数出现问题</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">/</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">说明mpu_init函数出现问题</td>
<td align="center">/</td>
</tr>
</tbody></table>
<h5 id="run-self-test问题"><a href="#run-self-test问题" class="headerlink" title="run_self_test问题"></a>run_self_test问题</h5><p>进入run_self_test函数内部有一个</p>
<p>mpu_run_self_test函数，将它的result打印出来。</p>
<table>
<thead>
<tr>
<th align="center">result</th>
<th align="center">mpu_run_self_test内部</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x4</td>
<td align="center">加速度计和陀螺仪自检均未通过，考虑为模块损坏</td>
</tr>
<tr>
<td align="center">0x5</td>
<td align="center">加速度计自检未通过，未知原因</td>
</tr>
<tr>
<td align="center">0x6</td>
<td align="center">陀螺仪自检未通过，未知原因</td>
</tr>
</tbody></table>
<p>如果重新连线、改变防止方向（芯片平放）无法解决你的问题，可以试试将后面的条件判断修改为你的值，看看是否可以出数据，但是如果出了数据，对数据的准确性无法做以保证。</p>
<h5 id="mpu-init问题"><a href="#mpu-init问题" class="headerlink" title="mpu_init问题"></a>mpu_init问题</h5><p>这里的问题一般是由于IIC配置错误导致的。</p>
<p>进入函数内不出意外的话程序会在i2c_write返回-1，此时进入函数内部查看返回值：</p>
<p>**HAL_ERROR:**请检查之前的0x68改为0xD0是否有更改。如果更改了，则可能是其他的地方地址出现问题。（检查AD0引脚是否被拉高，若拉高则地址应为0xD1）。</p>
<p>**HAL_BUSY:**硬件IIC会出现的busy锁死问题，这是ST硬件上的一点小问题，可能已经在后续的产品中修复。临时解决办法是把设备完全断电，在不上IIC的情况下上电，清除BUSY位后断电重新插线即可解决问题。</p>
<h5 id="dmp-read-fifo问题"><a href="#dmp-read-fifo问题" class="headerlink" title="dmp_read_fifo问题"></a>dmp_read_fifo问题</h5><p>进入函数内部，不出意外是mpu_read_fifo_stream这个函数处返回了-1，这说明我们读取速度太慢了导致了FIFO溢出，只需要在读取语句之后加上一行代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(mpu_dmp_get_data(&amp;pitch,&amp;roll,&amp;yaw));</span><br></pre></td></tr></table></figure>

<p>在FIFO下次溢出前再次读取即可。</p>
]]></content>
      <categories>
        <category>硬件</category>
        <category>模块</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>MPU6050</tag>
      </tags>
  </entry>
  <entry>
    <title>利用VScode的STM32开发</title>
    <url>/2021/03/22/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="第一部分-配置VScode的C-C-环境"><a href="#第一部分-配置VScode的C-C-环境" class="headerlink" title="第一部分   配置VScode的C/C++环境"></a>第一部分   配置VScode的C/C++环境</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本部分文档为网上教程改编，可参考原文：</p>
<p><a href="https://zhuanlan.zhihu.com/p/87864677">VSCode配置C/C++环境</a></p>
<span id="more"></span>

<hr>
<h2 id="VScode的安装"><a href="#VScode的安装" class="headerlink" title="VScode的安装"></a>VScode的安装</h2><p><a href="https://code.visualstudio.com/">VScode官网</a>中下载对应系统版本的安装包即可。</p>
<p>安装具体过程不再赘述，需要注意的是记得更改安装路径到C盘以外的盘符。</p>
<h2 id="设置中文环境"><a href="#设置中文环境" class="headerlink" title="设置中文环境"></a>设置中文环境</h2><p> VSCode  本身只是一款文本编辑器 ，其所有的功能都是以插件的形式存在的，语言也不例外。</p>
<p>首先在左侧拓展栏</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616341142247.png" alt="1616341142247"></p>
<p>上方的搜索框中搜索language</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616341205671.png" alt="1616341205671"></p>
<p>下面应该不用说选什么了，记得安装之后重启下软件。</p>
<h2 id="配置C-C-环境"><a href="#配置C-C-环境" class="headerlink" title="配置C/C++环境"></a>配置C/C++环境</h2><h3 id="安装MinGW编译器"><a href="#安装MinGW编译器" class="headerlink" title="安装MinGW编译器"></a>安装MinGW编译器</h3><p>我将安装包传到了蓝奏云上，可以从上面下载：</p>
<blockquote>
<p> <a href="https://wws.lanzous.com/imPwJn6qibe">https://wws.lanzous.com/imPwJn6qibe</a><br>密码:gd5j </p>
</blockquote>
<p>或者可以从<a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">MinGW开源项目</a>上下载对应的Installer来进行安装。</p>
<p>进入项目后一直下拉，直到看到如图界面</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616341671972.png" alt="1616341671972"></p>
<p>下载在线安装程序后运行</p>
<p>配置如图</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616476262964.png" alt="1616476262964"></p>
<p>后点击Next</p>
<p>之后更改安装路径，注意不要包含<strong>空格</strong>和<strong>中文</strong>,记住你的安装路径之后备用。</p>
<p>之后就会自动进行安装程序了。</p>
<p>程序安装完成后，还需要进行环境变量的配置：</p>
<p>右键我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;双击Path打开-&gt;添加安装路径下的bin文件夹的路径（步骤如下图）</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616342450484.png" alt="1616342450484"></p>
<p>配置后一路确定杀回设置，关掉设置。</p>
<p>按下win+R，输入cmd 回车，在跳出的窗口里面粘贴一下语句：</p>
<p> <em>gcc -v</em> </p>
<p>敲下回车</p>
<p>若出现类似界面说明安装成功。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616342634581.png" alt="1616342634581"></p>
<h3 id="安装C-C-拓展"><a href="#安装C-C-拓展" class="headerlink" title="安装C/C++拓展"></a>安装C/C++拓展</h3><p>在拓展库中搜索C/C++即可找到，安装即可。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616342752458.png" alt="1616342752458"></p>
<p>安装之后出现uninstall说明安装完成，此时最好重启一下。</p>
<h3 id="配置编译器"><a href="#配置编译器" class="headerlink" title="配置编译器"></a>配置编译器</h3><p>按下 Ctrl+Shift+P调出命令面板，输入C/C++，选择“Edit Configurations(UI)”进入配置（如图）。 </p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616380593074.png" alt="1616380593074"></p>
<p>进入后配置编译器路径：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616380868668.png" alt="1616380868668"></p>
<p>具体路径视安装路径不同而有些微差别。</p>
<p>之后配置IntelliSense 模式：gcc-x64</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616380988222.png" alt="1616380988222"></p>
<p>配置完成后发现侧边栏多了一个.vscode文件夹，并且里面有一个.json文件说明配置成功。</p>
<h3 id="配置构建任务"><a href="#配置构建任务" class="headerlink" title="配置构建任务"></a>配置构建任务</h3><p> 按快捷键Ctrl+Shift+P调出命令面板，输入tasks，选择“Tasks:Configure Default Build Task” </p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616383132256.png" alt="1616383132256"></p>
<p> 再选择“C/C++: g++.exe build active file” </p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616383222167.png" alt="1616383222167"></p>
<p> 此时会出现一个名为tasks.json的配置文件 ，说明配置成功。</p>
<h3 id="配置调试设置"><a href="#配置调试设置" class="headerlink" title="配置调试设置"></a>配置调试设置</h3><p> 这里主要是为了在.vscode文件夹中产生一个launch.json文件，用来配置调试的相关信息。按下F5，选择 C++(GDB/LLDB) </p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616383429025.png" alt="1616383429025"></p>
<p>接下来就会生成 一个launch.json的文件 </p>
<p>至此配置完成。</p>
<p>以后再用的时候可以直接把.vscode文件夹复制即可。</p>
<hr>
<h2 id="第二部分-在vscode上使用keil插件编写keil代码"><a href="#第二部分-在vscode上使用keil插件编写keil代码" class="headerlink" title="第二部分   在vscode上使用keil插件编写keil代码"></a>第二部分   在vscode上使用keil插件编写keil代码</h2><h3 id="前言（废话）："><a href="#前言（废话）：" class="headerlink" title="前言（废话）："></a>前言（废话）：</h3><hr>
<p>众所周知，一款好的代码编写软件能提高写代码的效率，总觉得keil的界面有点简陋而且看着不是很舒服（这一定是我学不好32的一大原因），所以，队友提到vscode能编写32的代码时，就去csdn上找了找，然后配置了一下，就发现真香。</p>
<h2 id="配置方法："><a href="#配置方法：" class="headerlink" title="配置方法："></a>配置方法：</h2><p>安装keil assistant</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1620477086386.png" alt="1620477086386"></p>
<p>安装完之后，打开你的扩展区，找到安装好的keil助手，点击图示设置</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1620477119981.png" alt="1620477119981"></p>
<p>然后点击扩展设置，就出现以下界面</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1620477146632.png" alt="1620477146632"></p>
<p>第二个路径刚刚安装完成是没有的，需要你填写你对应keil的安装文件路径，填入，</p>
<p>然后就可以愉快的使用了！</p>
<p>如何使用：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616400728718.png" alt="1616400728718"></p>
<p>打开资源管理器，然后如果你的keil助手成功安装（安装不能说明你能编译程序），就有2所对应的管理器，打开它，然后</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616400754821.png" alt="1616400754821"></p>
<p>添加你的keil文件（.uvprojx)</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1620477233425.png" alt="1620477233425"></p>
<p>弹出这个就选ok吧，这样你就成功用vscode打开了你的keil工程。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1620477277505.png" alt="1620477277505"></p>
<p>具体界面就像这样，然后就和往常一样，打开你要的.c.h文件即可</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1620477308271.png" alt="1620477308271"></p>
<p>编译和下载：</p>
<p>把鼠标指针移到你对应工程文件上面就可以选择，或者快捷键</p>
<p>ctrl+alt+F7 rebuild </p>
<p>ctrl+alt+d烧录</p>
<p>假如弹出0 Error(s), 0 Warning(s) 就像这样</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1620477348618.png" alt="1620477348618"></p>
<p>就可以了，如果没成功就需要检查一下你的keil文件路径是不是写错了，是不是忘记加.exe之类的。</p>
]]></content>
      <categories>
        <category>单片机</category>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>记编码器的学习历程</title>
    <url>/2021/01/22/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于积分赛要求最近在学电机控制，其中包括PID算法，当然就少不了用编码器来监测电机当前运动状态了，为防止遗忘，特将编码器的学习过程记录如下。</p>
<span id="more"></span>

<h2 id="编码器以及其原理"><a href="#编码器以及其原理" class="headerlink" title="编码器以及其原理"></a>编码器以及其原理</h2><p>首先关于编码器概述不用说太多，网上一搜一大把（以下介绍为复制内容）：</p>
<p>编码器分为光电和霍尔编码器是一种将角位移或者角速度转换成一连串电数字脉冲的旋转式传感器，我们可以通过编码器测量到位移或者速度信息。编码器从输出数据类型上分，可以分为增量式编码器和绝对式编码器。</p>
<p>从编码器检测原理上来分，还可以分为光学式、磁式、感应式、电容式。常见的是光电编码器（光学式）和霍尔编码器（磁式）。两种（以下介绍为复制内容）：</p>
<p>光电编码器是一种通过光电转换将输出轴上的机械几何位移量转换成脉冲或数字量的传感器。光电编码器是由光码盘和光电检测装置组成。光码盘是在一 定直径的圆板上等分地开通若干个长方形孔。由于光电码盘与电动机同轴，电动机旋转时，检测装置检测输出若干脉冲信号，为判断转向，一般输出两组存在一 定相位差的方波信号。</p>
<p>霍尔编码器是一种通过磁电转换将输出轴上的机械几何位移量转换成脉冲或数字量的传感器。霍尔编码器是由霍尔码盘和霍尔元件组成。霍尔码盘是在一 定直径的圆板上等分地布置有不同的磁极。霍尔码盘与电动机同轴，电动机旋转时，霍尔元件检测输出若干脉冲信号，为判断转向，一般输出两组存在一定相位差的方波信号。</p>
<p>下图为正交编码器的输出波形图：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478338406.png" alt="1620478338406"></p>
<p>除了这些还有一个参数对我们很有用，那就是编码器的线数。  </p>
<p>线数是什么呢？  </p>
<p>我们可以简单的理解为线数是多少，那么编码器每转动一圈就会产生多少个脉冲信号。  </p>
<hr>
<h2 id="程序实现（废话不说纯享版）"><a href="#程序实现（废话不说纯享版）" class="headerlink" title="程序实现（废话不说纯享版）"></a>程序实现（废话不说纯享版）</h2><p>实例环境：<strong>STM32F401CCU6+CubeMX+HAL库</strong></p>
<p>首先随便打开一个定时器，打开编码器模式：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478445392.png" alt="1620478445392"></p>
<p>  设置为TI1和TI2共同触发：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478459280.png" alt="1620478459280"></p>
<p>打开串口一以便接收数据<del>（真的不是懒得配置屏幕显示）</del></p>
<p>接下来我们需要额外打开一个定时器来测出单位时间产生了多少脉冲,我用了TIM4来进行定时:  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478474987.png" alt="1620478474987"></p>
<p>  并且打开定时器中断：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478513729.png" alt="1620478513729"></p>
<p>  再打开一个定时器用于产生PWM波（20kHz占空比50%）进而控制电机转动。  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478530063.png" alt="1620478530063"></p>
<p>电机驱动为TB6612，使用并不麻烦，此处不再赘述。</p>
<p>为了方便调试，我们再打开两个连接着开关的IO口用于控制PWM的输出（一个用于控制电机转动与停止，另一个调节占空比），接着生成工程。</p>
<p>敲代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变量定义</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"><span class="keyword">float</span> freq=<span class="number">0</span>，CNT_prevalue=<span class="number">0</span>，period=<span class="number">0</span>，velocity=<span class="number">0</span>，position=<span class="number">0</span>；</span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="comment">//包含头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;math.h&quot;</span></span></span><br><span class="line"><span class="comment">//串口重定向</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">PUTCHAR_PROTOTYPE&#123;</span><br><span class="line">    HAL_UART_Transmit(&amp;huart1, (<span class="keyword">uint8_t</span> *)&amp;ch, <span class="number">1</span> , <span class="number">0xffff</span>);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定时器中断回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span>&#123;</span><br><span class="line">	velocity=(TIM1-&gt;CNT*<span class="number">1.0f</span>-CNT_prevalue)*<span class="number">1.0f</span>*<span class="number">1000</span>/(<span class="number">13</span>*<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//公式应该是：</span></span><br><span class="line">    <span class="comment">// （CNT2-CNT1）*计数器溢出频率/（编码器线数*采集边沿数）</span></span><br><span class="line">    <span class="comment">//PS：因为设置了TI1和TI2共同采样，所以采集边沿为4个。</span></span><br><span class="line">    period = <span class="built_in">fabs</span>( velocity * <span class="number">360</span> );</span><br><span class="line">    position = (<span class="keyword">int</span>)period % <span class="number">360</span>;</span><br><span class="line">    value = TIM1 -&gt; CNT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环前后</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">    HAL_TIM_Base_Start_IT(&amp;htim4);<span class="comment">//开启定时器4中断</span></span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3,TIM_CHANNEL_1);<span class="comment">//开启PWM通道</span></span><br><span class="line">    HAL_TIM_Encoder_Start(&amp;htim1,TIM_CHANNEL_2);<span class="comment">//开启定编码器接口通道</span></span><br><span class="line">    HAL_TIM_Encoder_Start(&amp;htim1,TIM_CHANNEL_1);<span class="comment">//同上</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//控制电机</span></span><br><span class="line">    <span class="keyword">if</span>(!HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1))</span><br><span class="line">    	HAL_GPIO_WritePin(GPIOA,GPIO_PIN_2,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	HAL_GPIO_WritePin(GPIOA,GPIO_PIN_2,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//输出计算结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; v=%.1f r/s\n period=%.1f degrees/s\n position=%.0f degrees\n&quot;</span>,velocity,period,position);</span><br><span class="line">    <span class="comment">//调节方波占空比</span></span><br><span class="line">    <span class="keyword">if</span>(!HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0))</span><br><span class="line">    &#123;</span><br><span class="line">    	TIM3-&gt;CCR1+<span class="number">210</span>&gt;<span class="number">4200</span>?TIM3-&gt;CCR1=<span class="number">0</span>:TIM3-&gt;CCR1+=<span class="number">210</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_Delay(<span class="number">200</span>);</span><br><span class="line"><span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure>

<p>  烧录，测试，结果如图：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478729839.png" alt="1620478729839"></p>
<p>  教程结束。  </p>
<hr>
<h2 id="程序实现（墨迹墨迹解读版）"><a href="#程序实现（墨迹墨迹解读版）" class="headerlink" title="程序实现（墨迹墨迹解读版）"></a>程序实现（墨迹墨迹解读版）</h2><p>方法其实很好理解，只要测量单位时间内输出的脉冲个数即可间接得知转速。</p>
<p>那么如果想测得脉冲个数，相信大家一定会很容易想到输入捕获。</p>
<p><del>输入捕获大家应该都会，好的教程结束，大家加油！</del></p>
<p>我也是第一个想到了输入捕获，不过出现这个想法的时候就有一个问题一直难以解决：</p>
<p>如何判断电机的转向呢？这是个值得思考的问题，因为我们后面想要实现很多功能都需要知道电机的转向，然而仅仅使用输入捕获只能测出脉冲的个数进而测出速度，确实没办法知道电机的转向。此路不通的情况下，就要开始思考其他的方法了。</p>
<p>好在经过好心人的提醒我得知：STM32具有专门的硬件编码器接口，于是立刻跑去翻手册。那么让我们先来看看STM32的硬件编码器接口是怎么回事：</p>
<p>（PS：如果其他的单片机没有如果没有编码器外设的话，我们可以使用GPIO中断进行，在中断里面判断另一相的电平来判断方向，该方法感兴趣的读者可以自己尝试  ）</p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478834327.png" alt="1620478834327"></p>
<p>好家伙，选择接口模式之后直接就选择计数边沿，<del>有输入捕获内味了嗷</del>（可是为什么只选择TI1和TI2的边沿却不是选择TI3、TI4呢？）。</p>
<p>我们打开CubeMX试着配置一下：  </p>
<p>首先随便打开一个定时器（此处其实建议使用片内32位定时器），打开编码器模式：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478949658.png" alt="1620478949658"></p>
<p>可以看到选下编码器模式之后上面五个配置选项就锁定了。也就是说编码器模式的设置以及频道的使用其实是早就内定好的，并不像其他的模式一样可以自己选择通道。</p>
<p>这件事情其实在参考手册的通用定时器框图里面也得到了验证：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479003499.png" alt="1620479003499">至于手册说的边沿选择这句话  ：</p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479026932.png" alt="1620479026932"></p>
<p>  是在这里设置的：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479037219.png" alt="1620479037219"></p>
<p>正如手册所说，可以选择仅TI1、仅TI2和TI与TI2共同使用三种方式。</p>
<p>继续阅读手册：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479059771.png" alt="1620479059771"></p>
<p>极性？我们回忆一下PWM波中的极性，表示的是OCxREF和实际输出OCx之间的关系（即极性相同或相反）。好的，此处拓展想一下，这里的极性应该也是选择一个二值的量，很明显就是检测边沿。  </p>
<p>对应到CubeMX里面：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479200390.png" alt="1620479200390"></p>
<p>CubeMX里面接下来的IC Selection选项里面只有直接选项，从图里面就可以明确的看出来。继续看手册：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479223708.png" alt="1620479223708"></p>
<p>输入滤波器的编程对应的应该就是这里：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479251663.png" alt="1620479251663"></p>
<p>  至此，CubeMX里面的可设置项就看完了，我们继续看看手册里面还说了什么：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479273239.png" alt="1620479273239"></p>
<p>上面的内容挺让人头大的，不过好在重点就两句。第一句的意思其实就是说<strong>只有当编码器产生脉冲的时候，CNT的值才会改变</strong>。第二句的意思就是说输入改变的时候会更改计数器的计数方向。  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479305031.png" alt="1620479305031"></p>
<p>看到这里我们就懂了，这模式不但能计数，还能辨别转动方向。</p>
<p>后面给出了一个实例我们来看一下：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479327782.png" alt="1620479327782"></p>
<p>上面给出的波形就是编码器的波形，很容易看出编码器正转时CNT递增，反之递减。</p>
<p>因此，我们只需要在中断里面连续进行两次采样，对两次采样的CNT值做差，如果结果为正说明CNT正向计数，即电机正向旋转，反之反向。除此之外，我们还可以通过读取TIMx_CR1寄存器的DIR位来获得计数方向进而得知电机转向：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479372193.png" alt="1620479372193"></p>
<p>  实现代码前面给过了，就不赘述了。  </p>
<hr>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>2021.5.17补充：</p>
<p>关于利用GPIO中断写出软件编码器的实现方法：</p>
<p>由于最近在学MSP432，其上并没有硬件编码器接口，因此只能自己写软件编码器，实现了一下发现其实并不难，写在此作为之前内容的补充。</p>
<p>PS：以下实现代码为使用MSP432的函数实现的，STM32版本如果有机会写的话<del>其实就是没机会了</del>会写的。</p>
<p>首先是分析：</p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1621253575694.png" alt="1621253575694"></p>
<p>观察编码器AB相的输出不难看出，当电机正向旋转时，下方相位领先上方90°，反转反之。</p>
<p>因此，要判断旋转方向其实就是判断两侧输入的相位差，但是单片机并不是示波器，它没法看出两个波形的全貌，只能看到某一瞬间两个波形的高低电平状况。那么有没有好的方法可以<strong>利用瞬间的电平状态</strong>判断出两个波形的相位差呢？答案是有的。</p>
<p>其实很简单，我们观察下<strong>当上方波形出现上升沿的时候，对应下方波形的电平</strong>就会发现：</p>
<p><strong>正向旋转的时候对应为低电平；</strong></p>
<p><strong>反向旋转的时候对应位高电平。</strong></p>
<p>如此我们便实现了对方向的判断。</p>
<p>与此同时，上升沿的个数其实也对应着波形中出现的高电平个数，因此可以利用计数上升沿个数的方法来实现对速度的测量。</p>
<p>MSP432实现代码如下(IDE:Clion):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZheWana on 2021/5/17.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ti/devices/msp432p4xx/driverlib/driverlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UARTRetarget.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Standard Includes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义技术脉冲个数的计数变量CNT</span></span><br><span class="line"><span class="keyword">int32_t</span> CNT;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO中断处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> temp = GPIO_getInputPinValue(GPIO_PORT_P3, GPIO_PIN2);</span><br><span class="line">    <span class="keyword">uint32_t</span> status;</span><br><span class="line">    status = MAP_GPIO_getEnabledInterruptStatus(GPIO_PORT_P3);</span><br><span class="line">    MAP_GPIO_clearInterruptFlag(GPIO_PORT_P3, status);</span><br><span class="line">    <span class="keyword">if</span> (status &amp; GPIO_PIN3) &#123;</span><br><span class="line">        MAP_GPIO_toggleOutputOnPin(GPIO_PORT_P1, GPIO_PIN0);</span><br><span class="line">        <span class="keyword">if</span> (temp == GPIO_INPUT_PIN_HIGH) &#123;</span><br><span class="line">            CNT++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == GPIO_INPUT_PIN_LOW) &#123;</span><br><span class="line">            CNT--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    WDT_A_holdTimer();</span><br><span class="line"></span><br><span class="line">    GPIO_setAsOutputPin(GPIO_PORT_P1, GPIO_PIN0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用P3.3和P3.2作为AB相输入</span></span><br><span class="line">    GPIO_setAsInputPinWithPullUpResistor(GPIO_PORT_P3, GPIO_PIN3);</span><br><span class="line">    GPIO_setAsInputPinWithPullUpResistor(GPIO_PORT_P3, GPIO_PIN2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将P3.3作为中断引脚</span></span><br><span class="line">    GPIO_clearInterruptFlag(GPIO_PORT_P3, GPIO_PIN3);</span><br><span class="line">    GPIO_enableInterrupt(GPIO_PORT_P3, GPIO_PIN3);</span><br><span class="line">    GPIO_interruptEdgeSelect(GPIO_PORT_P3, GPIO_PIN3, GPIO_LOW_TO_HIGH_TRANSITION);</span><br><span class="line"></span><br><span class="line">    Interrupt_enableInterrupt(INT_PORT3);</span><br><span class="line">    Interrupt_enableMaster();</span><br><span class="line">    Interrupt_registerInterrupt(INT_PORT3, GPIO_IRQHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>硬件</category>
        <category>模块</category>
      </categories>
      <tags>
        <tag>编码器</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>记超声波模块的学习过程</title>
    <url>/2020/12/01/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天<del>亲身尝试了可怜的打工生活</del>帮助同学搞了一辆智能车，看着上面要求的指标，我意识到似乎我该学一学超声波模块了。  </p>
<span id="more"></span>

<hr>
<h2 id="关于HC-SR04的那些事（想看HC-SR04教程-你在想peach。请后翻）"><a href="#关于HC-SR04的那些事（想看HC-SR04教程-你在想peach。请后翻）" class="headerlink" title="关于HC-SR04的那些事（想看HC-SR04教程?你在想peach。请后翻）"></a>关于HC-SR04的那些事（<del>想看HC-SR04教程?你在想peach。</del>请后翻）</h2><p>当时手里拿的是HC-SR04模块，于是就去查了它的资料,通过CSDN上的一些博客得知它的工作原理之后，我便开始自行操作了。</p>
<p><strong>错误示范</strong></p>
<p>首先，我满怀信心的打开CubeMX,配置了Trig引脚作为输出引脚（下拉），Echo引脚作为输入引脚（下拉）。</p>
<p>接下来，打开一个定时器，纠结了一番后，我打开了定时器中断，<del>别骂了别骂了，在改了在改了</del>将PSC设置为83，将ARR设置为0，于是美滋滋的得到了一个1us触发一次的中断用于计时。只要在中断回调函数里面每次让一个计时变量加一，就可以做到计时了（gepi）。</p>
<p><strong>以下内容虽然整体是错误的，但是还是有一点有用的地方的</strong></p>
<p>再接下来，我需要发出一个超过10us的信号来触发模块工作，于是就产生了一个有趣的问题：<strong>微秒级延时</strong>。在网上找了好多资料都由于我太菜看不懂无果，于是我开始向我们亲爱的学长求助，了解到有一个计数频率等于单片机主频的寄存器，我们可以通过读取其中的值来获得微秒级别的延时。</p>
<p>代码如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay_us</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; i</span><br><span class="line">nt a;</span><br><span class="line">a=SysTick-&gt;VAL;<span class="comment">//读取寄存器的当前值</span></span><br><span class="line"><span class="keyword">while</span>(SysTick-&gt;VAL-a&lt;<span class="number">84</span>*n);<span class="comment">//等待n us</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了好了，接下来就是敲一段简单的主函数代码之后享受胜利的喜悦了。</p>
<p><del>今天学会了超声波模块，真是开心的一天！</del></p>
<p>屁啦！Debug一下发现距离的值根本不会动啊！</p>
<p>询问了学长，得知是定时器中断的频率太快，<del>这谁受得了啊</del>建议用输入捕获来计时。</p>
<p>于是，我又回去卑微的看了一遍参考手册，加上学长的指导，自己有了一些体会：<strong>串口通信真香！</strong></p>
<hr>
<h2 id="关于US-100的那些事"><a href="#关于US-100的那些事" class="headerlink" title="关于US-100的那些事"></a>关于US-100的那些事</h2><p>其实会有以上奇怪的体会还是因为学长<del>满脸嫌弃</del>细心认真的指导：干嘛用那种东西，US-100它不香嘛？  </p>
<p>换了US-100之后我发现，<strong>串口模式的确很香</strong>。  </p>
<p>模块拿到手，首先是万年不变的查资料过程。（PS：请注意观察模块的引脚连线部分内容，一般的串口通信都是Tx连接Rx，Rx连接Tx，而这个模块<strong>刚好相反</strong>。）  </p>
<p>了解了模块的使用方法之后，我便开始操作（梅开二度）了：  </p>
<p>首先，打开CubeMX进行引脚的配置，此处需要打开一组串口并使能串口中断以确保收发数据时不会被打断，我用的是USART1。  </p>
<p>定义两个变量，一个用来发送触发信号，一个用来接收两个字节的反馈信息：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> receive[<span class="number">2</span>];<span class="comment">//存储接收的数据</span></span><br><span class="line"><span class="keyword">double</span> dis;<span class="comment">//存储计算得到的距离</span></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">256</span>];<span class="comment">//显示变量所需要的缓冲变量</span></span><br><span class="line"><span class="keyword">uint8_t</span> sign=<span class="number">0x55</span>;<span class="comment">//触发信号</span></span><br></pre></td></tr></table></figure>

<p>在正确配置屏幕之后，在循环语句前后敲上以下代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">    u8g2_Setup_ssd1306_128x64_noname_1(&amp;u8g2, U8G2_R0, u8x8_byte_4wire_hw_spi,</span><br><span class="line">    u8x8_gpio_and_delay);</span><br><span class="line">    u8g2_InitDisplay(&amp;u8g2);</span><br><span class="line">    u8g2_SetPowerSave(&amp;u8g2, <span class="number">0</span>); <span class="comment">//u8g2屏幕的初始化</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    HAL_UART_Transmit_IT(&amp;huart1,&amp;sign,<span class="number">1</span>);</span><br><span class="line">    HAL_UART_Receive_IT(&amp;huart1,receive,<span class="number">2</span>);</span><br><span class="line">    u8g2_FirstPage(&amp;u8g2);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        u8g2_SetFont(&amp;u8g2, u8g2_font_courR18_tf);</span><br><span class="line">        <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%.2lf&quot;</span>,dis);</span><br><span class="line">        u8g2_DrawStr(&amp;u8g2, <span class="number">0</span>, <span class="number">15</span>, buffer);</span><br><span class="line">        u8g2_DrawStr(&amp;u8g2, <span class="number">80</span>, <span class="number">31</span>, <span class="string">&quot;cm&quot;</span> );</span><br><span class="line">    &#125; <span class="keyword">while</span> (u8g2_NextPage(&amp;u8g2));</span><br><span class="line">    HAL_Delay(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure>

<p>最后定义中断回调函数并在其中计算距离：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dis=((<span class="keyword">double</span>)receive[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>+(<span class="keyword">double</span>)receive[<span class="number">1</span>])/<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就可以在我们的屏幕上面显示模块测量的距离值了。<br><del>什么你问HC-SR04？你就是为了它才来的？没门！</del><br>我这就去学输入捕获………  </p>
<p><strong>A FEW THOUSEND YEARS LATER……..</strong></p>
<hr>
<h2 id="关于HC-SR04"><a href="#关于HC-SR04" class="headerlink" title="关于HC-SR04"></a>关于HC-SR04</h2><p>经过不断的请教之后，我终于弄懂了我心心念念的输入捕获。<br>是这样的，在F4参考手册里面有这样的一个图：  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620482530457.png" alt="1620482530457"></p>
<p>这张图对于我们弄懂输入捕获至关重要，在尝试期间我出现过了许多<del>玄学错误</del>由于不懂原理而出现的错误，下面一一与大家分享。（观前提示：以下错误均是在TIM引脚的配置上出现的，我使用的是TIM2。）  </p>
<p><strong>一大波错误示范如期而至</strong></p>
<p><strong>(对于其中原理不感兴趣的童鞋请直接移步下一部分,会提供完整的代码供移植)</strong></p>
<p>首先屏幕和IO口的配置就不赘述了 ：  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620482586012.png" alt="1620482586012"></p>
<p>看了参考手册里面关于输入捕获的介绍之后，我便开始了操作：</p>
<p>此时对于输入捕获，我的理解是这样的：</p>
<p>首先我看到了这张图  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620482641174.png" alt="1620482641174"></p>
<p>  哦！检测到跳变沿后<strong>CCRx会获取CNT寄存器的值并且锁存</strong>，因此我们只需要读取CCRx的值就可以得到从<strong>CNT为0</strong>一直到<strong>跳变沿发生</strong>经过的时间，那么问题来了，CNT什么时候为０呢？于是我继续看到了这张图：</p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620482728662.png" alt="1620482728662"></p>
<p>好嘛!这不是写的明明白白的嘛!第一个上升沿时IC1和IC2共同捕获,并且将计数器(CNT寄存器)复位，到达下降沿时IC2再次捕获，将CNT的值锁存到CCR2寄存器里面,下次上升沿来的时候重复以上操作.<br><del>被快乐冲昏了头脑</del>我配置了TIM引脚如下:  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620482766886.png" alt="1620482766886"></p>
<p>生成代码后完成一番配置,接着在循环前后敲下如下代码:  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_IC_Start(&amp;htim2,TIM_CHANNEL_1);<span class="comment">//使能输入捕获</span></span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       Trig();<span class="comment">//发出触发信号</span></span><br><span class="line">       HAL_Delay(<span class="number">100</span>);<span class="comment">//延时是为了给模块完成回响信号的发送的时间</span></span><br><span class="line">       a=TIM2-&gt;CCR2;<span class="comment">//读取CCR2的值</span></span><br><span class="line">       dis=a/<span class="number">84000</span>*<span class="number">17</span>;<span class="comment">//根据声速公式进行计算(PS:CNT寄存器计时的频率等于总线频率经过预分频</span></span><br><span class="line">       后的结果)</span><br><span class="line">       u8g2_FirstPage(&amp;u8g2);</span><br><span class="line">       <span class="keyword">do</span></span><br><span class="line">       &#123; </span><br><span class="line">           u8g2_SetFont(&amp;u8g2, u8g2_font_courR18_tf);</span><br><span class="line">           <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%.2lf&quot;</span>,dis);</span><br><span class="line">           u8g2_DrawStr(&amp;u8g2, <span class="number">0</span>, <span class="number">15</span>, buffer);	</span><br><span class="line">       &#125; <span class="keyword">while</span> (u8g2_NextPage(&amp;u8g2));</span><br><span class="line">       <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line">       <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure>

<p>变量定义:  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trig</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">double</span> a,dis;</span><br></pre></td></tr></table></figure>

<p>触发函数Trig():  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trig</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HAL_GPIO_WritePin(GPIOA,GPIO_PIN_1,GPIO_PIN_SET);</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a=SysTick-&gt;VAL;</span><br><span class="line">    <span class="keyword">while</span>(SysTick-&gt;VAL-a&lt;<span class="number">840</span>);<span class="comment">//延时10us</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOA,GPIO_PIN_1,GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(以上代码可以放心移植,因为问题不出在代码上,不过后面会有点小调整.)<br>烧完了程序,玄学现象出现了:屏幕上的数字一直是0.00…….<br>作为一个菜狗  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620482979560.png" alt="1620482979560"></p>
<p>我想了好久才想到是怎么回事,我看到了之前的那张图:  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620482996852.png" alt="1620482996852"></p>
<p>意识到频道一的值似乎应该用CCR1啊,又注意到PWM输入时序图上面写的是PWM输入不是输入捕获，我瞬间懂了，看来我想的是对的，就是应该用CCR1的值,于是就改成了读取CCR1的值.<strong>（一个错误的结论）</strong><br>再次运行………<br>屏幕上的数字不再是0.00了我十分兴奋,<del>今天搞懂了HC-SR04 ,真是开心！</del>不过我很快就意识到了问题:<br>数字在不断的上涨,没有一点停止的迹象.  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483068136.png" alt="1620483068136"></p>
<p>不知所措的我再次向手册求助,问题还是出在了这张图上面：</p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483088539.png" alt="1620483088539"></p>
<p>注意到了TI1FP1和IC１以及CCR1的关系:  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483101258.png" alt="1620483101258"></p>
<p>我意识到自己根本没有进行TI1FP1的配置,于是回到MX里面进行配置，很快就又发现：  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483115539.png" alt="1620483115539"></p>
<p>这唤起了我的记忆,好像是要配置一个Reset Mode来着?  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483131833.png" alt="1620483131833"></p>
<p>点下Reset Mode的一瞬间,我悟了,马上去手册里面翻看,果然发现了:  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483146068.png" alt="1620483146068"></p>
<p>复位模式是需要进行配置的,而这个Reset Mode显然就是对此进行了配置,而之前数值不断上升的现象显然是CNT寄存器没有重置导致的.<br>好嘞!生成代码烧程序<del>收工!</del><br>这次数字果然没有一直增加,然而却会一直乱跳,即使我完全没有碰模块,也会一直乱跳.  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483187822.png" alt="1620483187822"></p>
<p>转念一想,PWM时序图里面测量脉冲长度的是啥来着?CCR2吧,可是我读CCR2是0,读取CCR1又出现这么奇怪的读数,果然还是串口香,HC-SR04算个屁,教程结束!问题应该还是出在那张我看不懂的乱七八糟关系图上,于是我硬着头皮开始硬看,好在看懂了,不然就劝退了.</p>
<p><strong>以下为正确内容</strong></p>
<p>其实我们只需要关注这么一小部分就可以:  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483231142.png" alt="1620483231142"></p>
<p>首先,最上面一行告诉我们了CNT计数器的频率是主频经过PSC分频之后得到的频率，这为我们计算脉冲宽度（时间）提供了时间基准．</p>
<p>接下来，想想我们之前说的话:  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483264848.png" alt="1620483264848"></p>
<p>捕获脉冲宽度的是IC2而不是IC1,所以的确是应该读取CCR2的值的,可是为什么之前的实验得到的值是0呢?我们再来看图:  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483287339.png" alt="1620483287339"></p>
<p>显然IC2的输入大部分是从CH2里面过来的,我们用的是CH1啊,根本就没有输入怎么会有值呢?可是总不能再分一路到CH2去吧?</p>
<p>别慌,仔细看图就会发现IC2的输入里面有一个<strong>卧底</strong>,那就是TI1FP2:  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483332852.png" alt="1620483332852"></p>
<p>可以看出它不是直接由CH2输入到IC2的,换句话说就是从CH1间接输入到CH2的.</p>
<p>好的,相信大家都想到了我们之前讲的CH2间接模式(其实大家应该很早就想到了,只有我这样的菜狗才会这么晚才意识到问题所在orz):  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483356038.png" alt="1620483356038"></p>
<p>到了这里,我们已经离成功不远了,需要注意的是(别问我怎么注意到的):CH2有一个单独的边沿设置选项,默认为上升沿捕获,  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483372851.png" alt="1620483372851"></p>
<p>而我们希望IC2捕获下降沿,所以记得更改捕获边沿为下降沿.</p>
<p>接下来敲代码,完成.  </p>
<hr>
<h2 id="仅供参考的例程"><a href="#仅供参考的例程" class="headerlink" title="仅供参考的例程"></a>仅供参考的例程</h2><p>1.屏幕的配置略</p>
<p>2.CubeMX配置:  </p>
<p>打开TIM2_CH1连接ECHO引脚以便捕获回响信号;<br>将A1设置为GPIO输出模式并下拉，用作触发引脚．  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483454734.png" alt="1620483454734"></p>
<p>定时器配置如图：(箭头指向为非默认选项)  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483468995.png" alt="1620483468995"></p>
<p>3.代码内容:</p>
<p>变量定义和函数声明:  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trig</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">double</span> a,dis;</span><br></pre></td></tr></table></figure>

<p>触发函数Trig()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trig</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HAL_GPIO_WritePin(GPIOA,GPIO_PIN_1,GPIO_PIN_SET);</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a=SysTick-&gt;VAL;</span><br><span class="line">    <span class="keyword">while</span>(SysTick-&gt;VAL-a&lt;<span class="number">840</span>);<span class="comment">//延时10us</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOA,GPIO_PIN_1,GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数循环前后:  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_IC_Start(&amp;htim2,TIM_CHANNEL_1);<span class="comment">//使能输入捕获</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Trig();<span class="comment">//发出触发信号</span></span><br><span class="line">        HAL_Delay(<span class="number">100</span>);<span class="comment">//延时是为了给模块完成回响信号的发送的时间</span></span><br><span class="line">        a=TIM2-&gt;CCR2;<span class="comment">//读取CCR2的值</span></span><br><span class="line">        dis=a/<span class="number">84000</span>*<span class="number">17</span>;<span class="comment">//根据声速公式进行计算(PS:CNT寄存器计时的频率等于总线频率经过预分频后的结果)</span></span><br><span class="line">        u8g2_FirstPage(&amp;u8g2);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123; </span><br><span class="line">            u8g2_SetFont(&amp;u8g2, u8g2_font_courR18_tf);</span><br><span class="line">            <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%.2lf&quot;</span>,dis);</span><br><span class="line">            u8g2_DrawStr(&amp;u8g2, <span class="number">0</span>, <span class="number">15</span>, buffer);</span><br><span class="line">        &#125; <span class="keyword">while</span> (u8g2_NextPage(&amp;u8g2));</span><br><span class="line">        <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line">        <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">    &#125; </span><br><span class="line">	<span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>谨以此文记录自己学习超声波模块的曲折过程，分享给大家希望能给正在研究超声波模块的人以帮助.</p>
]]></content>
      <categories>
        <category>硬件</category>
        <category>模块</category>
      </categories>
      <tags>
        <tag>超声波模块</tag>
      </tags>
  </entry>
</search>
