<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Everybody loves Somebody</title>
    <url>/2021/bed4a5279825/</url>
    <content><![CDATA[<p>《玉子市场》看完啦！</p>
<p><del>什么？你说你发现了我摸鱼？哪有</del></p>
<span id="more"></span>

<p>看过的每部电影和番剧总有一些话会让自己印象深刻，或许下次摸鱼的时候会写一写以前的吧……？</p>
<p><del>不过写了就不算是摸鱼了</del></p>
<h2 id="Everybody-loves-Somebody"><a href="#Everybody-loves-Somebody" class="headerlink" title="Everybody loves Somebody"></a>Everybody loves Somebody</h2><p>说到这句话脑子里就不自觉地响起了蹩脚的日式英语，这就是被洗脑了？</p>
<p><strong>每个人都有其所爱</strong>，看到有人这样翻译感觉真的有被暖到。作为纯爱战士我当然是冲着纯爱来了玉子市场，最后在玉子市场里面我也是真正的看到了纯爱，只不过是邻里之间的纯爱，纯纯的<strong>关爱</strong>。<img src="/images/Everybody-lvoes-Somebody/v2-c16036d2a073bbadc7a9bcf7045f7f41_720w.jpg" alt="img"></p>
<p>兔山真的太好了，看到最后真的觉得整个人都被温馨包围着。虽然看的很迷糊但是还是看出了玉子幼年便丧失了母亲，还能这样乐观真的让人很惊讶，而且玉子真的是傻傻的，很可爱，对年糕有着奇怪的偏执但是并不影响这表现出她对生活的热爱。</p>
<p><img src="/images/Everybody-lvoes-Somebody/v2-904ffa62d33064bea2e1c8c8da1c3995.jpg" alt="v2-904ffa62d33064bea2e1c8c8da1c3995"></p>
<p>玉子市场，是兔山，是围绕在玉子周围的市场。但是从头到尾真的没看到一点印象中市场该有的感觉，每次交易都是围绕着玉子、朋友进行的，目光所及之处满是慷慨的馈赠<del>白嫖党狂喜</del>。听说王子妃一事，大家都纷纷祝愿玉子幸福，又安慰豆大不要伤心，要失去一些东西才能得到新的东西（当然我是非常不希望玉子当上王子妃的）。</p>
<p>顺带一提，最终玉子拒绝当上王子妃的时候我真的狂喜！！</p>
<p>看得出玉子和饼藏的感情萌芽，不过玉子真的好迟钝，也好可爱。</p>
<p>感受得到豆大和雏子（原谅我其实没记住妈妈的名字）年轻的时候的感情，真的很让人羡慕哈！</p>
<p>又想起了馅子和悠月的可爱感情（小盆友互相喜欢什么的真的太可爱啦~）</p>
<p><del>单身狗流下了泪水</del></p>
<p>不写了不写了，越看自己写的东西越感觉:</p>
<p>写的真烂呀T_T</p>
<p>总之就是<strong>完结撒花！</strong></p>
<p><img src="/images/Everybody-lvoes-Somebody/1620574802817.png" alt="1620574802817"></p>
<p>摸鱼结束，该干活了orz</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>HAL库基本函数（下）</title>
    <url>/2021/8e232aea5e5b/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文接上篇<a href="http://zhewana.cn/2021/8e2b5d35a586/">HAL库基本函数（上）</a>。</p>
<span id="more"></span>

<h2 id="系统相关函数"><a href="#系统相关函数" class="headerlink" title="系统相关函数"></a>系统相关函数</h2><p>获取当前系统运行时间函数：返回当前系统运行时间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__weak <span class="keyword">uint32_t</span> <span class="title">HAL_GetTick</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uwTick;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延时函数：以毫秒为单位进行延时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__weak <span class="keyword">void</span> <span class="title">HAL_Delay</span><span class="params">(<span class="keyword">uint32_t</span> Delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//获取当前系统运行时间</span></span><br><span class="line">  <span class="keyword">uint32_t</span> tickstart = HAL_GetTick();</span><br><span class="line">  <span class="keyword">uint32_t</span> wait = Delay;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (wait &lt; HAL_MAX_DELAY)</span><br><span class="line">  &#123;</span><br><span class="line">    wait += (<span class="keyword">uint32_t</span>)(uwTickFreq);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>((HAL_GetTick() - tickstart) &lt; wait)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器函数"><a href="#定时器函数" class="headerlink" title="定时器函数"></a>定时器函数</h2><blockquote>
<p>由于包括定时器函数在内的其他函数内部实现相较GPIO而言比较复杂，因此在此不作解读，只是给出常用函数作为参考</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定时器基础功能开启</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_TIM_Base_Start</span><span class="params">(TIM_HandleTypeDef *htim)</span></span>;</span><br><span class="line"><span class="comment">//定时器基础功能关闭</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_TIM_Base_Stop</span><span class="params">(TIM_HandleTypeDef *htim)</span></span>;</span><br><span class="line"><span class="comment">//定时器中断功能开启</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_TIM_Base_Start_IT</span><span class="params">(TIM_HandleTypeDef *htim)</span></span>;</span><br><span class="line"><span class="comment">//定时器中断功能关闭</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_TIM_Base_Stop_IT</span><span class="params">(TIM_HandleTypeDef *htim)</span></span>;</span><br><span class="line"><span class="comment">//定时器输出比较开启</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_TIM_OC_Start</span><span class="params">(TIM_HandleTypeDef *htim, <span class="keyword">uint32_t</span> Channel)</span></span>;</span><br><span class="line"><span class="comment">//定时器输出比较关闭</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_TIM_OC_Stop</span><span class="params">(TIM_HandleTypeDef *htim, <span class="keyword">uint32_t</span> Channel)</span></span>;</span><br><span class="line"><span class="comment">//定时器输出比较中断开启</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_TIM_OC_Start_IT</span><span class="params">(TIM_HandleTypeDef *htim, <span class="keyword">uint32_t</span> Channel)</span></span>;</span><br><span class="line"><span class="comment">//定时器输出比较中断关闭</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_TIM_OC_Stop_IT</span><span class="params">(TIM_HandleTypeDef *htim, <span class="keyword">uint32_t</span> Channel)</span></span>;</span><br><span class="line"><span class="comment">//PWM输出开启</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_TIM_PWM_Start</span><span class="params">(TIM_HandleTypeDef *htim, <span class="keyword">uint32_t</span> Channel)</span></span>;</span><br><span class="line"><span class="comment">//PWM输出关闭</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_TIM_PWM_Stop</span><span class="params">(TIM_HandleTypeDef *htim, <span class="keyword">uint32_t</span> Channel)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>记得在使用定时器相关功能之前先打开对应的功能，否则在查了一天的bug之后发现自己没开对应功能的那种感觉真的终生难忘。</p>
<h2 id="串口函数"><a href="#串口函数" class="headerlink" title="串口函数"></a>串口函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串口发送函数</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_UART_Transmit</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">uint8_t</span> *pData, <span class="keyword">uint16_t</span> Size, <span class="keyword">uint32_t</span> Timeout)</span></span>;</span><br><span class="line"><span class="comment">//串口接收函数（阻塞模式）</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_UART_Receive</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">uint8_t</span> *pData, <span class="keyword">uint16_t</span> Size, <span class="keyword">uint32_t</span> Timeout)</span></span>;</span><br><span class="line"><span class="comment">//串口中断发送函数</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_UART_Transmit_IT</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">uint8_t</span> *pData, <span class="keyword">uint16_t</span> Size)</span></span>;</span><br><span class="line"><span class="comment">//串口中断接收函数（非阻塞模式）</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_UART_Receive_IT</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">uint8_t</span> *pData, <span class="keyword">uint16_t</span> Size)</span></span>;</span><br><span class="line"><span class="comment">//串口DMA模式发送函数</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_UART_Transmit_DMA</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">uint8_t</span> *pData, <span class="keyword">uint16_t</span> Size)</span></span>;</span><br><span class="line"><span class="comment">//串口DMA模式接收函数</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_UART_Receive_DMA</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">uint8_t</span> *pData, <span class="keyword">uint16_t</span> Size)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>串口接收函数就像scanf函数一样，会阻塞程序的运行，而串口中断函数则不会阻塞程序的运行。</p>
<h3 id="关于串口重定向"><a href="#关于串口重定向" class="headerlink" title="关于串口重定向"></a>关于串口重定向</h3><p>MDK环境下的串口重定向：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//printf的重定向</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE *f)</span></span>&#123;</span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, (<span class="keyword">uint8_t</span> *)&amp;ch, <span class="number">1</span>, <span class="number">0xffff</span>);</span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//scanf的重定向</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *f)</span></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> ch = <span class="number">0</span>;</span><br><span class="line">  HAL_UART_Receive(&amp;huart1, &amp;ch, <span class="number">1</span>, <span class="number">0xffff</span>);</span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gcc环境下的串口重定向：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件包含</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdarg.h&quot;</span></span></span><br><span class="line"><span class="comment">//printf重定向</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART_printf</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">  length = vsnprintf(buffer, <span class="number">128</span>, fmt, ap);</span><br><span class="line">    </span><br><span class="line">  HAL_UART_Transmit(huart, (<span class="keyword">uint8_t</span> *)buffer, length, HAL_MAX_DELAY);</span><br><span class="line">    </span><br><span class="line">  va_end(ap);</span><br><span class="line">  <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更详细的方法在<a href="http://zhewana.cn/2021/c69c321f18aa/">这篇文章</a>里面有说过，感兴趣的话可以看看。</p>
]]></content>
      <categories>
        <category>单片机</category>
        <category>STM32</category>
        <category>函数库</category>
      </categories>
      <tags>
        <tag>函数库</tag>
      </tags>
  </entry>
  <entry>
    <title>HAL库基本函数（上）</title>
    <url>/2021/8e2b5d35a586/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知道写啥了，但还是要有一个前言的。</p>
<p><del>摸鱼的时候不知道该干点啥，那就写一篇博客吧！</del></p>
<span id="more"></span>

<p><del>坑已留，摸鱼时填。</del></p>
<p>摸鱼啦，想必今天会是开心的一天~</p>
<p>既然没什么事情做，那就总结一下HAL库常用的基本函数吧！</p>
<blockquote>
<p>本文可能含有一些读者未曾掌握的知识点在内，其存在只是为了让笔者能够正常进行讲述，而不至于一直用类似于“什么什么之类的”这种无用的废话来浪费读者的时间。</p>
<p>所以如果有的名词读者看不懂，别担心，随便看看也好嘛</p>
</blockquote>
<h2 id="我该去哪里找到这些函数？"><a href="#我该去哪里找到这些函数？" class="headerlink" title="我该去哪里找到这些函数？"></a>我该去哪里找到这些函数？</h2><p>首先最直观的当然就是ST的<a href="https://www.st.com/resource/en/user_manual/dm00105879-description-of-stm32f4-hal-and-ll-drivers-stmicroelectronics.pdf">HAL库官方手册</a>啦。</p>
<p>不过这本手册的内容只是<strong>函数声明的简单堆叠</strong>，因此建议去看看HAL库的函数<strong>源码中的注释</strong>。我们来举个简单的小例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file    stm32f4xx_hal_gpio.c</span></span><br><span class="line"><span class="comment">  * @author  MCD Application Team</span></span><br><span class="line"><span class="comment">  * @brief   GPIO HAL module driver.</span></span><br><span class="line"><span class="comment">  *          This file provides firmware functions to manage the following </span></span><br><span class="line"><span class="comment">  *          functionalities of the General Purpose Input/Output (GPIO) peripheral:</span></span><br><span class="line"><span class="comment">  *           + Initialization and de-initialization functions</span></span><br><span class="line"><span class="comment">  *           + IO operation functions</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  @verbatim</span></span><br><span class="line"><span class="comment">  ==============================================================================</span></span><br><span class="line"><span class="comment">                    ##### GPIO Peripheral features #####</span></span><br><span class="line"><span class="comment">  ==============================================================================</span></span><br><span class="line"><span class="comment">  [..] </span></span><br><span class="line"><span class="comment">  Subject to the specific hardware characteristics of each I/O port listed in the datasheet, each port bit of the General Purpose IO (GPIO) Ports, can be individually configured by software in several modes:</span></span><br><span class="line"><span class="comment">  (+) Input mode </span></span><br><span class="line"><span class="comment">  (+) Analog mode</span></span><br><span class="line"><span class="comment">  (+) Output mode</span></span><br><span class="line"><span class="comment">  (+) Alternate function mode</span></span><br><span class="line"><span class="comment">  (+) External interrupt/event lines</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  [..]  </span></span><br><span class="line"><span class="comment">  During and just after reset, the alternate functions and external interrupt lines are not active and the I/O ports are configured in input floating mode.</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  [..]   </span></span><br><span class="line"><span class="comment">  All GPIO pins have weak internal pull-up and pull-down resistors, which can be activated or not.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  [..]</span></span><br><span class="line"><span class="comment">  In Output or Alternate mode, each IO can be configured on open-drain or push-pull type and the IO speed can be selected depending on the VDD value.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  [..]  </span></span><br><span class="line"><span class="comment">  All ports have external interrupt/event capability. To use external interrupt lines, the port must be configured in input mode. All available GPIO pins are connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  [..]</span></span><br><span class="line"><span class="comment">  The external interrupt/event controller consists of up to 23 edge detectors(16 lines are connected to GPIO) for generating event/interrupt requests (each input line can be independently configured to select the type (interrupt or event)and the corresponding trigger event (rising or falling or both). Each line can also be masked independently. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                     ##### How to use this driver #####</span></span><br><span class="line"><span class="comment">  ==============================================================================  </span></span><br><span class="line"><span class="comment">  [..]</span></span><br><span class="line"><span class="comment">    (#) Enable the GPIO AHB clock using the following function: __HAL_RCC_GPIOx_CLK_ENABLE(). </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (#) Configure the GPIO pin(s) using HAL_GPIO_Init().</span></span><br><span class="line"><span class="comment">        (++) Configure the IO mode using &quot;Mode&quot; member from GPIO_InitTypeDef structure</span></span><br><span class="line"><span class="comment">        (++) Activate Pull-up, Pull-down resistor using &quot;Pull&quot; member from GPIO_InitTypeDef structure.</span></span><br><span class="line"><span class="comment">        (++) In case of Output or alternate function mode selection: the speed is configured through &quot;Speed&quot; member from GPIO_InitTypeDef structure.</span></span><br><span class="line"><span class="comment">        (++) In alternate mode is selection, the alternate function connected to the IO is configured through &quot;Alternate&quot; member from GPIO_InitTypeDef structure.</span></span><br><span class="line"><span class="comment">        (++) Analog mode is required when a pin is to be used as ADC channel or DAC output.</span></span><br><span class="line"><span class="comment">        (++) In case of external interrupt/event selection the &quot;Mode&quot; member from GPIO_InitTypeDef structure select the type (interrupt or event) and the corresponding trigger event (rising or falling or both).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using HAL_NVIC_EnableIRQ().</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">    (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">    (#) To set/reset the level of a pin configured in output mode use HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                 </span></span><br><span class="line"><span class="comment">    (#) During and just after reset, the alternate functions are not active and the GPIO pins are configured in input floating mode (except JTAG pins).</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has priority over the GPIO function.</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as general purpose PH0 and PH1, respectively, when the HSE oscillator is off. The HSE has priority over the GPIO function.</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  @endverbatim</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @attention</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2017 STMicroelectronics.</span></span><br><span class="line"><span class="comment">  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * This software component is licensed by ST under BSD 3-Clause license,</span></span><br><span class="line"><span class="comment">  * the &quot;License&quot;; You may not use this file except in compliance with the</span></span><br><span class="line"><span class="comment">  * License. You may obtain a copy of the License at:</span></span><br><span class="line"><span class="comment">  *                        opensource.org/licenses/BSD-3-Clause</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  */</span> </span><br></pre></td></tr></table></figure>

<p>这大段的注释出现在stm32f4xx_hal_gpio.c中，整体上先是介绍了GPIO的外设特点（模式、内部上下拉、中断等），接着介绍了如何使用GPIO的驱动(驱动GPIO的流程)：</p>
<p>使能总线时钟→引脚初始化→（配置中断→设置优先级→）获取/配置引脚状态</p>
<p>以上内容可以说是相当的详细了，在使用的过程中会对我们有很大的帮助。</p>
<p>同时不只是对于整个模块有详细的介绍，对于每个函数也都有注释做详细的介绍，例如对于HAL_GPIO_WritePin函数就有如下的详细介绍：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Sets or clears the selected data port bit.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @note   This function uses GPIOx_BSRR register to allow atomic read/modify</span></span><br><span class="line"><span class="comment">  *         accesses. In this way, there is no risk of an IRQ occurring between</span></span><br><span class="line"><span class="comment">  *         the read and the modify access.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param  GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or</span></span><br><span class="line"><span class="comment">  *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.</span></span><br><span class="line"><span class="comment">  * @param  GPIO_Pin specifies the port bit to be written.</span></span><br><span class="line"><span class="comment">  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).</span></span><br><span class="line"><span class="comment">  * @param  PinState specifies the value to be written to the selected bit.</span></span><br><span class="line"><span class="comment">  *          This parameter can be one of the GPIO_PinState enum values:</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_PIN_RESET: to clear the port pin</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_PIN_SET: to set the port pin</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于注释的内容：</p>
<p>详细内容可以参考<a href="https://blog.csdn.net/wenrenhua08/article/details/39591239">这篇文章</a>，这里简单介绍下：</p>
<p>brief：函数功能简介</p>
<p>note：函数使用过程中需要注意的事项</p>
<p>param：即parameter，函数中的参数相关说明</p>
<p>retval：即return value，函数返回值</p>
</blockquote>
<p>大致看了看注释，是不是对于函数有更深的了解了呢？现在我们可以开始<del>大规模复制粘贴</del>真正的主题了。</p>
<h2 id="GPIO函数"><a href="#GPIO函数" class="headerlink" title="GPIO函数"></a>GPIO函数</h2><p>GPIO写函数:配置GPIO引脚状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_GPIO_WritePin</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin, GPIO_PinState PinState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line">  assert_param(IS_GPIO_PIN_ACTION(PinState));<span class="comment">//断言验证参数正确性</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(PinState != GPIO_PIN_RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    GPIOx-&gt;BSRR = GPIO_Pin;<span class="comment">//将BSRR寄存器置位，进而完成引脚的配置</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    GPIOx-&gt;BSRR = (<span class="keyword">uint32_t</span>)GPIO_Pin &lt;&lt; <span class="number">16U</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_13,GPIO_PIN_SET);<span class="comment">//将PC13置高</span></span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_13,GPIO_PIN_RESET);<span class="comment">//将PC13置低</span></span><br></pre></td></tr></table></figure>

<hr>
<p>GPIO读函数：读取GPIO引脚状态并返回对应的状态值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">GPIO_PinState <span class="title">HAL_GPIO_ReadPin</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GPIO_PinState bitstatus;</span><br><span class="line">  <span class="comment">//断言验证参数正确性</span></span><br><span class="line">  assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//读取IDR寄存器的对应引脚位</span></span><br><span class="line">  <span class="keyword">if</span>((GPIOx-&gt;IDR &amp; GPIO_Pin) != (<span class="keyword">uint32_t</span>)GPIO_PIN_RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//若为高，返回GPIO_PIN_SET</span></span><br><span class="line">    bitstatus = GPIO_PIN_SET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//否则，返回GPIO_PIN_RESET</span></span><br><span class="line">    bitstatus = GPIO_PIN_RESET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bitstatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//判断PA0是否为高电平</span></span><br><span class="line"><span class="keyword">if</span> (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET) &#123;</span><br><span class="line">    <span class="comment">//如果是，将PC13置高</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果不是，将PC13置低</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>GPIO翻转引脚状态：反转GPIO引脚的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_GPIO_TogglePin</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> odr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//断言验证参数正确性</span></span><br><span class="line">  assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读取ODR寄存器的值</span></span><br><span class="line">  odr = GPIOx-&gt;ODR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过写入BSRR寄存器更改引脚状态</span></span><br><span class="line">  GPIOx-&gt;BSRR = ((odr &amp; GPIO_Pin) &lt;&lt; GPIO_NUMBER) | (~odr &amp; GPIO_Pin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断A0的状态是否为高</span></span><br><span class="line"><span class="keyword">if</span> (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET)</span><br><span class="line">    <span class="comment">//如果是，反转PC13的引脚状态</span></span><br><span class="line">	HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);</span><br></pre></td></tr></table></figure>

<hr>
<p>GPIO中断回调函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__weak <span class="keyword">void</span> <span class="title">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//函数内容需要在用户文件中重新定义</span></span><br><span class="line">  UNUSED(GPIO_Pin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在用户文件中定义函数：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="keyword">uint16_t</span> GPIO_Pin)</span></span>&#123;</span><br><span class="line">    <span class="comment">//当中断触发的时候反转PC13引脚的状态</span></span><br><span class="line">    HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>篇幅限制，只能讲这么多了，剩下的我们下一篇文章再看。</p>
]]></content>
      <categories>
        <category>单片机</category>
        <category>STM32</category>
        <category>函数库</category>
      </categories>
      <tags>
        <tag>函数库</tag>
      </tags>
  </entry>
  <entry>
    <title>ZWFly项目记录</title>
    <url>/2021/21928eec9c6c/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文为假期即将结束时开始做的并且可能会做很久的小无人机项目的记录。</p>
<span id="more"></span>

<h2 id="一切的开始"><a href="#一切的开始" class="headerlink" title="一切的开始"></a>一切的开始</h2><p>假期快结束了，这个假期挺无聊的，遂给自己想了一个小项目做来玩玩。虽然对于现在的我来说难度是有些稍大的，但是没关系，一边学习一边进步嘛。</p>
<p>自己给项目想了个名字：ZWFly</p>
<p>原因很简单，看很多开源飞控都叫某某fly，所以就这么叫了（当然我做出来的东西效果肯定不能和开源飞控比较），不过这个名字至少寄托了我希望自己做出堪比开源飞控无人机的小心思。</p>
<h2 id="20210730硬件准备"><a href="#20210730硬件准备" class="headerlink" title="20210730硬件准备"></a>20210730硬件准备</h2><p>笔者在朋友的帮助下，入手了一个无人机机架，机架本体自带四个820的空心杯电机，价格很便宜，质量也很满意：</p>
<p><img src="/images/ZWFly%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/%E6%99%BA%E8%83%BD%E8%BD%A6-1629183245865.jpg" alt="1631265626208"></p>
<blockquote>
<p>由于本段并非与项目实时撰写，所以其实无人机架上面并不应该有控制板</p>
</blockquote>
<h2 id="20210731PCB绘制"><a href="#20210731PCB绘制" class="headerlink" title="20210731PCB绘制"></a>20210731PCB绘制</h2><ul>
<li>单片机选型为STM32F401CCU6</li>
<li>空心杯为MOS直驱</li>
<li>姿态传感器为MPU6050（DMP驱动）</li>
<li>高度传感器使用US-100或VL53L0（未定）</li>
</ul>
<p>明确以上后便开始了原理图的绘制工作：</p>
<p>首先是主控和电源部分，接着是驱动电路和检测电路。</p>
<p>经过考虑并没有加上充电电路。</p>
<p>接着完成了初版PCB的绘制。</p>
<blockquote>
<p>原理图已经经过后续修改，故该版本原理图和PCB均无</p>
</blockquote>
<h2 id="20210801软件代码"><a href="#20210801软件代码" class="headerlink" title="20210801软件代码"></a>20210801软件代码</h2><p>首先笔者想实现的功能很简单：</p>
<ul>
<li>无人机采用X姿态进行飞行</li>
<li>无人机能够实现平稳起飞以及平稳落地</li>
<li>无人机能够实现定高悬停</li>
<li>无人机能够实现遥控操作</li>
</ul>
<p>为了实现对应功能，软件的大体构想如下：</p>
<ul>
<li>利用定时器中断来实现对数据的采集和处理</li>
<li>姿态控制采用串级PID实现对于角速度和角度的串级控制</li>
<li>高度控制采用串级PID实现对于Z轴加速度和高度的串级控制</li>
<li>利用无线串口进行单片机间的数据通信</li>
</ul>
<h3 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h3><p>笔者在写软件的过程中不可避免的再一次遇到了IIC的Busy锁死问题，为了保证无人机运行过程中的稳定性，笔者尝试着解决了这个问题。</p>
<p>首先这个问题在官方的勘误手册中是有所提及的，并且给出了解决方法，我们需要做的仅仅是根据官方给出的解决方法写出代码。</p>
<p>官方给出的解决方法也非常简单粗暴：</p>
<p><strong>将IIC外设关闭后用GPIO接管其控制权，当确保GPIO输出正常后再将IIC外设重新打开</strong></p>
<p>代码当然也很简单粗暴：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Init GPIO </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_IICBusyErrorGPIOInit</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Configure GPIO pin Output Level */</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOx, GPIO_Pin, GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Configure GPIO pin : PB8 */</span></span><br><span class="line">    GPIO_InitStruct.Pin = GPIO_Pin;</span><br><span class="line">    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;</span><br><span class="line">    GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;</span><br><span class="line">    HAL_GPIO_Init(GPIOx, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Handle busy error</span></span><br><span class="line"><span class="comment">//IIC Pin:</span></span><br><span class="line"><span class="comment">//		SCL:PB6 </span></span><br><span class="line"><span class="comment">//		SDA:PB7</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_IIC_BusyErrorHandler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Disable the I2C peripheral</span></span><br><span class="line">    HAL_I2C_DeInit(&amp;hi2c1);</span><br><span class="line">    <span class="comment">//Configure the SCL and SDA I/Os as General Purpose Output Open-Drain</span></span><br><span class="line">    My_IICBusyErrorGPIOInit(GPIOB, GPIO_PIN_6 | GPIO_PIN_7);</span><br><span class="line">    <span class="comment">//Check SCL and SDA High level in GPIOx_IDR.</span></span><br><span class="line">    <span class="keyword">if</span> ((HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_6) == <span class="number">0</span>)</span><br><span class="line">        || (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_7 == <span class="number">0</span>))) &#123;</span><br><span class="line">        UART_printf(&amp;huart1, <span class="string">&quot;Checking SCL and SDA in high level ERROR!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Configure the SDA I/O low level</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_RESET);</span><br><span class="line">    <span class="comment">//Check SDA Low level in GPIOx_IDR.</span></span><br><span class="line">    <span class="keyword">if</span> (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_7)) &#123;</span><br><span class="line">        UART_printf(&amp;huart1, <span class="string">&quot;Checking SDA in low level ERROR!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Configure the SCL I/O low level</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, GPIO_PIN_RESET);</span><br><span class="line">    <span class="comment">//Check SCL Low level in GPIOx_IDR.</span></span><br><span class="line">    <span class="keyword">if</span> (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_6)) &#123;</span><br><span class="line">        UART_printf(&amp;huart1, <span class="string">&quot;Checking SCL in low level ERROR!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Configure the SCL I/O high level</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, GPIO_PIN_SET);</span><br><span class="line">    <span class="comment">//Check SCL high level in GPIOx_IDR.</span></span><br><span class="line">    <span class="keyword">if</span> (!HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_6)) &#123;</span><br><span class="line">        UART_printf(&amp;huart1, <span class="string">&quot;Checking SCL in high level ERROR!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Configure the SDA I/O high level</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_SET);</span><br><span class="line">    <span class="comment">//Check SDA Low level in GPIOx_IDR.</span></span><br><span class="line">    <span class="keyword">if</span> (!HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_7)) &#123;</span><br><span class="line">        UART_printf(&amp;huart1, <span class="string">&quot;Checking SDA in high level ERROR!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_6 | GPIO_PIN_7);</span><br><span class="line">    MX_I2C1_Init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目记录</category>
        <category>ZWFly</category>
      </categories>
      <tags>
        <tag>项目记录</tag>
      </tags>
  </entry>
  <entry>
    <title>利用VScode的STM32开发</title>
    <url>/2021/2e4af69907ea/</url>
    <content><![CDATA[<h2 id="第一部分-配置VScode的C-C-环境"><a href="#第一部分-配置VScode的C-C-环境" class="headerlink" title="第一部分   配置VScode的C/C++环境"></a>第一部分   配置VScode的C/C++环境</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本部分文档为网上教程改编，可参考原文：</p>
<p><a href="https://zhuanlan.zhihu.com/p/87864677">VSCode配置C/C++环境</a></p>
<span id="more"></span>

<hr>
<h2 id="VScode的安装"><a href="#VScode的安装" class="headerlink" title="VScode的安装"></a>VScode的安装</h2><p><a href="https://code.visualstudio.com/">VScode官网</a>中下载对应系统版本的安装包即可。</p>
<p>安装具体过程不再赘述，需要注意的是记得更改安装路径到C盘以外的盘符。</p>
<h2 id="设置中文环境"><a href="#设置中文环境" class="headerlink" title="设置中文环境"></a>设置中文环境</h2><p> VSCode  本身只是一款文本编辑器 ，其所有的功能都是以插件的形式存在的，语言也不例外。</p>
<p>首先在左侧拓展栏</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616341142247.png" alt="1616341142247"></p>
<p>上方的搜索框中搜索language</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616341205671.png" alt="1616341205671"></p>
<p>下面应该不用说选什么了，记得安装之后重启下软件。</p>
<h2 id="配置C-C-环境"><a href="#配置C-C-环境" class="headerlink" title="配置C/C++环境"></a>配置C/C++环境</h2><h3 id="安装MinGW编译器"><a href="#安装MinGW编译器" class="headerlink" title="安装MinGW编译器"></a>安装MinGW编译器</h3><p>我将安装包传到了蓝奏云上，可以从上面下载：</p>
<blockquote>
<p> <a href="https://wws.lanzous.com/imPwJn6qibe">https://wws.lanzous.com/imPwJn6qibe</a><br>密码:gd5j </p>
</blockquote>
<p>或者可以从<a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">MinGW开源项目</a>上下载对应的Installer来进行安装。</p>
<p>进入项目后一直下拉，直到看到如图界面</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616341671972.png" alt="1616341671972"></p>
<p>下载在线安装程序后运行</p>
<p>配置如图</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616476262964.png" alt="1616476262964"></p>
<p>后点击Next</p>
<p>之后更改安装路径，注意不要包含<strong>空格</strong>和<strong>中文</strong>,记住你的安装路径之后备用。</p>
<p>之后就会自动进行安装程序了。</p>
<p>程序安装完成后，还需要进行环境变量的配置：</p>
<p>右键我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;双击Path打开-&gt;添加安装路径下的bin文件夹的路径（步骤如下图）</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616342450484.png" alt="1616342450484"></p>
<p>配置后一路确定杀回设置，关掉设置。</p>
<p>按下win+R，输入cmd 回车，在跳出的窗口里面粘贴一下语句：</p>
<p> <em>gcc -v</em> </p>
<p>敲下回车</p>
<p>若出现类似界面说明安装成功。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616342634581.png" alt="1616342634581"></p>
<h3 id="安装C-C-拓展"><a href="#安装C-C-拓展" class="headerlink" title="安装C/C++拓展"></a>安装C/C++拓展</h3><p>在拓展库中搜索C/C++即可找到，安装即可。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616342752458.png" alt="1616342752458"></p>
<p>安装之后出现uninstall说明安装完成，此时最好重启一下。</p>
<h3 id="配置编译器"><a href="#配置编译器" class="headerlink" title="配置编译器"></a>配置编译器</h3><p>按下 Ctrl+Shift+P调出命令面板，输入C/C++，选择“Edit Configurations(UI)”进入配置（如图）。 </p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616380593074.png" alt="1616380593074"></p>
<p>进入后配置编译器路径：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616380868668.png" alt="1616380868668"></p>
<p>具体路径视安装路径不同而有些微差别。</p>
<p>之后配置IntelliSense 模式：gcc-x64</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616380988222.png" alt="1616380988222"></p>
<p>配置完成后发现侧边栏多了一个.vscode文件夹，并且里面有一个.json文件说明配置成功。</p>
<h3 id="配置构建任务"><a href="#配置构建任务" class="headerlink" title="配置构建任务"></a>配置构建任务</h3><p> 按快捷键Ctrl+Shift+P调出命令面板，输入tasks，选择“Tasks:Configure Default Build Task” </p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616383132256.png" alt="1616383132256"></p>
<p> 再选择“C/C++: g++.exe build active file” </p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616383222167.png" alt="1616383222167"></p>
<p> 此时会出现一个名为tasks.json的配置文件 ，说明配置成功。</p>
<h3 id="配置调试设置"><a href="#配置调试设置" class="headerlink" title="配置调试设置"></a>配置调试设置</h3><p> 这里主要是为了在.vscode文件夹中产生一个launch.json文件，用来配置调试的相关信息。按下F5，选择 C++(GDB/LLDB) </p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616383429025.png" alt="1616383429025"></p>
<p>接下来就会生成 一个launch.json的文件 </p>
<p>至此配置完成。</p>
<p>以后再用的时候可以直接把.vscode文件夹复制即可。</p>
<hr>
<h2 id="第二部分-在vscode上使用keil插件编写keil代码"><a href="#第二部分-在vscode上使用keil插件编写keil代码" class="headerlink" title="第二部分   在vscode上使用keil插件编写keil代码"></a>第二部分   在vscode上使用keil插件编写keil代码</h2><h3 id="前言（废话）："><a href="#前言（废话）：" class="headerlink" title="前言（废话）："></a>前言（废话）：</h3><hr>
<p>众所周知，一款好的代码编写软件能提高写代码的效率，总觉得keil的界面有点简陋而且看着不是很舒服（这一定是我学不好32的一大原因），所以，队友提到vscode能编写32的代码时，就去csdn上找了找，然后配置了一下，就发现真香。</p>
<h2 id="配置方法："><a href="#配置方法：" class="headerlink" title="配置方法："></a>配置方法：</h2><p>安装keil assistant</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1620477086386.png" alt="1620477086386"></p>
<p>安装完之后，打开你的扩展区，找到安装好的keil助手，点击图示设置</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1620477119981.png" alt="1620477119981"></p>
<p>然后点击扩展设置，就出现以下界面</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1620477146632.png" alt="1620477146632"></p>
<p>第二个路径刚刚安装完成是没有的，需要你填写你对应keil的安装文件路径，填入，</p>
<p>然后就可以愉快的使用了！</p>
<p>如何使用：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616400728718.png" alt="1616400728718"></p>
<p>打开资源管理器，然后如果你的keil助手成功安装（安装不能说明你能编译程序），就有2所对应的管理器，打开它，然后</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1616400754821.png" alt="1616400754821"></p>
<p>添加你的keil文件（.uvprojx)</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1620477233425.png" alt="1620477233425"></p>
<p>弹出这个就选ok吧，这样你就成功用vscode打开了你的keil工程。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1620477277505.png" alt="1620477277505"></p>
<p>具体界面就像这样，然后就和往常一样，打开你要的.c.h文件即可</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1620477308271.png" alt="1620477308271"></p>
<p>编译和下载：</p>
<p>把鼠标指针移到你对应工程文件上面就可以选择，或者快捷键</p>
<p>ctrl+alt+F7 rebuild </p>
<p>ctrl+alt+d烧录</p>
<p>假如弹出0 Error(s), 0 Warning(s) 就像这样</p>
<p><img src="/images/%E5%88%A9%E7%94%A8VScode%E7%9A%84STM32%E5%BC%80%E5%8F%91/1620477348618.png" alt="1620477348618"></p>
<p>就可以了，如果没成功就需要检查一下你的keil文件路径是不是写错了，是不是忘记加.exe之类的。</p>
]]></content>
      <categories>
        <category>单片机</category>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇文章</title>
    <url>/2021/701f437b7fd9/</url>
    <content><![CDATA[<p>这是我的第一篇文章。</p>
<span id="more"></span>

<p>这确实是我的第一篇文章，我怎么会骗你呢？</p>
<p>当然，这个第一篇是博客意义上的。</p>
<p>本人，大一废物一个（写下这篇文章的时候），绩点废物，还在坚强的努力学习，技术不精通，除了一颗喜欢玩的心之外一无所有。特别喜欢听音乐，无线耳机重度依赖症，纯音乐、填词音乐、中文音乐、英文音乐只要是好听的音乐都喜欢听。喜欢看电影和看番，但是不是那种会追溯番剧历史和文化的人，最喜欢的类型应该是温馨画风的番剧，以及烧脑电影。重度Warma粉，最近刚画了一块满是Warma的板子。偶尔会自己一个人多愁善感感叹人生，但是清醒过来还是会觉得自己当时是个智障。</p>
<p>我很讨厌文科，但是讽刺的是某一天突然发现自己似乎特别喜欢写一些自己学习技术的时候的技术笔记来作为教程帮助一些初学者（虽然我自己也是初学者），于是在社团里面投稿了很多学习笔记。但是一次重装系统让我意识到<del>爱</del>知识的确是会消失的，最终决定把自己之前的笔记以及以后的笔记全部上传在这个博客。此外，可能还会有一些平时的小吐槽发在里面。</p>
<p>希望自己能在技术的道路上越走越远，最后真的能成为一个软硬兼修的全栈工程师</p>
<p>…….吧？</p>
<p>最后，虽然有点突兀，但是还是要说的：</p>
<p>我已经完全爱上Warma啦！！！</p>
<p><img src="/images/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/437011d3d5437f6e2f534038626ec6c00ff9accf.jpg" alt="437011d3d5437f6e2f534038626ec6c00ff9accf"></p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>废话</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>控制器？单片机？内核？外设？蛤？</title>
    <url>/2021/64b5a1ee4851/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大概是笔者为了早日成为键盘侠而在进行的观点输出训练吧。</p>
<p>学习这么久，中间产生了无数个有趣的小问题，可能有些问题的解释现在也还是很浅显可笑，不过总归要记录下来，方便自己以后回来嘲笑自己。</p>
<span id="more"></span>

<blockquote>
<p><em><strong>本文内含多次观点转变，中间的观点均是笔者曾产生过的有趣想法，只有最终的观点才是笔者目前的观点。若读者并没有阅读完全文，请忘掉在所阅读的部分中汲取到的观点。</strong></em></p>
</blockquote>
<h2 id="我在学啥"><a href="#我在学啥" class="headerlink" title="我在学啥"></a>我在学啥</h2><p>当笔者意识到这个问题的时候自己已经在思考这个问题了，由于学长们总是会在笔者面前嘴里不断地往外冒出这几个词语：</p>
<p><strong>“控制器”、“单片机”、“内核”、“外设”</strong></p>
<p>所以单片机到底是个啥？是个控制器吗？还是说是个电脑？内核又是个啥？单片机是电脑的话那内核是CPU咯？外设又是什么玩意儿？单片机的鼠标键盘吗？</p>
<p>类似的问题一直萦绕在笔者的小脑瓜中挥之不去，真的很好奇这些问题的答案，于是笔者开始打开一个个浏览器标签页，最终其实也没搞明白个所以然。</p>
<p>大概就是在这种完全不知道自己在学什么的状态下，接触了ST的HAL库，接触了德仪的SDK，还接触了逐飞的TC264；做了智能小车，做了风力摆，又做了一堆乱七八糟的小项目。</p>
<p>笔者隐约发现，似乎无论在做什么，单片机总是最核心的那一个，承担了数据处理和程序调度的重任，果然单片机就是一个控制系统的<strong>内核</strong>吧！</p>
<p>既然单片机是控制系统的内核，那么外部所用的超声波测距模块一定就是<strong>外设</strong>吧！</p>
<h2 id="事情似乎开始不太对"><a href="#事情似乎开始不太对" class="headerlink" title="事情似乎开始不太对"></a>事情似乎开始不太对</h2><p>一次无聊冲浪的时候，了解了一下有关控制系统的内容：</p>
<p>原来控制系统是由<strong>控制器</strong>和<strong>执行器</strong>组成的。</p>
<p><img src="/images/%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%9F%E5%8D%95%E7%89%87%E6%9C%BA%EF%BC%9F%E5%86%85%E6%A0%B8%EF%BC%9F%E5%A4%96%E8%AE%BE%EF%BC%9F%E8%9B%A4%EF%BC%9F/image-20210928153014661.png" alt="image-20210928153014661"></p>
<p>这样看来笔者之前的理解有误，应该将单片机称为一个控制系统的控制器，那既然有了控制器就应该有相应的执行器，很显然，对于一辆小车而言<strong>电机就是系统的执行器</strong>。</p>
<blockquote>
<p>读者可能会将超声波测距模块理解为执行器，但是其实他应该属于传感器的范围之中，而传感器在一个控制系统中的作用是获取数据并反馈给控制器，并不能直接影响系统的输出，因此并不是执行器。</p>
<p>由于执行器一词并不在本文的讨论范围内，故此处不会展开说明。</p>
</blockquote>
<p>不过这个问题虽然搞懂了，但是<strong>事情似乎开始不太对了</strong>：</p>
<p><strong>内核</strong>是啥？<strong>外设</strong>又是啥？</p>
<p>最终思考无果，笔者无奈地认为：<em>单片机就是控制系统的控制器，电机等为控制系统的执行器，而控制器就是内核，执行器就是外设。</em></p>
<h2 id="未曾设想的降维打击"><a href="#未曾设想的降维打击" class="headerlink" title="未曾设想的降维打击"></a>未曾设想的降维打击</h2><p><strong>单片机里面有什么？</strong></p>
<p>某一天，这样一个想法出现在笔者脑中挥之不去。看到这里，相信读者已经发现了一件事：</p>
<p>笔者的思考一直停留在控制系统的维度，一切的认知都停留在对于控制系统组成的理解，在每次思考中，单片机仿佛就自然而然地应该是一个整体。</p>
<p>然而其实并不应该是这样的，也就是说此前笔者的思维一直被封锁在了<strong>控制系统的维度</strong>。</p>
<p>思维继续向下延伸：如果内核和外设并不是相对于控制系统呢？</p>
<p><strong>内核是单片机的内核，外设是单片机的外设</strong></p>
<p>内核和外设都是单片机维度下的东西，而不是控制系统维度下的东西。</p>
<p>想通了这里，笔者意识到自己<strong>原来的想法受到了降维打击</strong>，一个新世界似乎出现在了眼前。</p>
<h2 id="单片机是个电脑？"><a href="#单片机是个电脑？" class="headerlink" title="单片机是个电脑？"></a>单片机是个电脑？</h2><p>显然将一个控制系统比作一个计算机是不合适的，毕竟你不能说一个身上插满杜邦线、脚下有四个轮子、会自己随便乱跑的怪物是计算机。</p>
<p>同时将单片机比作电脑的CPU也是不合适的，因为CPU主要执行计算的工作，而不是像单片机一样可以采集电压，可以定时，可以输出电平……</p>
<p>那么什么可以被类比为电脑？</p>
<p>相信读者能够猜到了：单片机。</p>
<p>背后的的原因也很简单：和之前说的一样，电脑和控制系统并不是同一个维度，而<strong>单片机和计算机才是同一个维度的东西</strong>。</p>
<p>理解了这个问题就会水到渠成地认为<strong>单片机的内核</strong>其实就相当于<strong>电脑的CPU</strong>，而<strong>单片机的外设</strong>其实就相当于<strong>电脑的其他部分</strong>。</p>
<blockquote>
<p>例如：STM32F1系列的单片机就是Cotex-M3内核，而GPIO、定时器、ADC等都是单片机的片上外设。</p>
</blockquote>
<h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p><strong>控制器</strong>是控制系统的组成部分，<strong>单片机</strong>可以作为控制系统的控制器，<strong>内核</strong>是单片机的核心，而<strong>外设</strong>则是我们平时大量使用的单片机内除内核外的其他功能模块。</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>废话</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈LVGL学习、移植与使用</title>
    <url>/2021/7dd8d670d9f4/</url>
    <content><![CDATA[<p>前段时间做了一个信号源的项目，为了使整机看起来更有现代感，我们为其加上了屏幕显示模块，并且在项目中试着使用了LVGL来编写一些简单的GUI。</p>
<p>时间会吞噬人对于技术的记忆，因此现在正是回顾移植过程的好时机。</p>
<span id="more"></span>

<h2 id="万恶之源"><a href="#万恶之源" class="headerlink" title="万恶之源"></a>万恶之源</h2><p>俗话说的好：<strong>羊毛出在羊身上。</strong></p>
<p>笔者在这里也想说一句：<strong>移植出在文档上。</strong></p>
<p>既然库作者编写了开源库，并且希望该开源库被大家广泛地采用，就一定会：</p>
<ul>
<li>将库接口写得简单</li>
<li>为移植创作一份完善的移植文档</li>
</ul>
<p>因此，在一直开源库的时候最右参考意义的应该是该库的文档。</p>
<p>我们先去LVGL的<a href="https://github.com/lvgl/lvgl">仓库</a>看看：</p>
<blockquote>
<p>值得一提的是lvgl的仓库分支结构：</p>
<p>Master分支用于存放当前的测试内容（即Beta版本代码）</p>
<p>而所有的稳定版本代码都会以release/版本号的方式建立一个新的分支来发布</p>
</blockquote>
<p>我们来到v8版本的release分支，查看README文档，可以发现作者给出了建议的学习路线：</p>
<p><img src="/images/%E6%B5%85%E8%B0%88lvgl%E7%A7%BB%E6%A4%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20211018151907429.png" alt="image-20211018151907429"></p>
<p>我们按照官方推荐的方式来学习库的使用。</p>
<h2 id="一些无关紧要的操作"><a href="#一些无关紧要的操作" class="headerlink" title="一些无关紧要的操作"></a>一些无关紧要的操作</h2><p><del>其实也不是无关紧要</del></p>
<p>首先进入官方的<a href="https://lvgl.io/demos">在线Demo</a>来把玩一下用lvgl写出来的UI，感受一下那份流畅与跃动的感觉在你的鼠标之间旋转跳跃，再幻想一下你的嵌入式设备的屏幕上出现了一模一样的UI，你的内心瞬间被成就感填满……</p>
<p>好吧，其实这一步没什么用。</p>
<p>把玩过之后点进<a href="https://docs.lvgl.io/latest/en/html/intro/index.html#">Introduction</a>中了解一下lvgl的关键特点、硬件需求、许可证以及仓库的结构等等。</p>
<p>好吧，其实这一步也没什么用。</p>
<p>一顿操作之后，直到完成第五步，你都没有让lvgl与你的开发平台产生任何的联系。唯一的作用就是：</p>
<p><strong>你对lvgl更加了解了</strong></p>
<p>没错，这就是库作者希望的结果，当然也是笔者希望的结果。</p>
<blockquote>
<p><del>其实笔者真正希望的结果是读者自行看懂PortGuide，然后直接快进到文档结束</del></p>
</blockquote>
<h2 id="库文件的移植"><a href="#库文件的移植" class="headerlink" title="库文件的移植"></a>库文件的移植</h2><blockquote>
<p>一些说明：</p>
<ol>
<li><p>笔者在之前的工程中使用的lvgl版本为v7，为了能让自己更实际的体会到库文件的移植过程，特选择v8.0版本进行移植。</p>
</li>
<li><p>移植并使用lvgl的前提：</p>
<p>读者已经拥有一个能够使用的彩屏/单色屏的屏幕驱动，并且至少可以实现在屏幕的固定座标上进行画点操作。</p>
</li>
<li><p>整个移植过程均参考官方的<a href="https://docs.lvgl.io/latest/en/html/porting/index.html">PortingGuide</a>（下称移植手册），如有疑问请参照移植手册原文，仍有问题请与库作者沟通。<del>（笔者不背锅）</del></p>
</li>
</ol>
</blockquote>
<h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><p>如题，使用的开发环境为：</p>
<p><strong>STM32CubeMX+Clion</strong></p>
<p>MCU型号为：</p>
<p><strong>STM32H750VBT6</strong></p>
<p>工程创建与屏幕驱动移植过程略。</p>
<hr>
<h3 id="本体移植"><a href="#本体移植" class="headerlink" title="本体移植"></a>本体移植</h3><p>首先将<a href="https://github.com/lvgl/lvgl/tree/release/v8.0">release/v8.0</a>的仓库Clone到本地。</p>
<p>按照移植手册的说法：</p>
<blockquote>
<p>The graphics library is the <strong>lvgl</strong> directory which should be copied into your project.</p>
</blockquote>
<p>得知应该将lvgl文件夹拷贝到工程目录下，但是在克隆来的分支中并没有名为lvgl的文件夹<del>，于是笔者移植失败，并骂一句什么**垃圾作者。</del></p>
<p>事实上名为src的文件夹很明显就是源代码目录，故在使用的工程中新建lvgl目录用于存放库文件，并<strong>将src目录直接复制到lvgl目录下</strong>。</p>
<p>继续耐着性子读下去，发现工程中应该有一个配置文件名为：<code>lv_conf_template.h</code>并且有如下的说明：</p>
<blockquote>
<p>Copy <strong>lvgl/lv_conf_template.h</strong> next to the <em>lvgl</em> directory and rename it to <em>lv_conf.h</em>.</p>
</blockquote>
<p>故将<code>lv_conf_template.h</code>复制到lvgl目录中并更名为<code>lv_conf.h</code>。</p>
<p>顺便将<code>#if 0</code>改为<code>#if 1</code>来使能文件的内容。</p>
<blockquote>
<p>lvgl的每个接口库文件和配置库文件都有<code>#if 0</code>开关，使用时需要注意。</p>
</blockquote>
<p>接着将lvgl.h复制到lvgl目录下，该头文件包含了所有相关的lvgl所需要的头文件，因此写程序时只需要包含lvgl.h即可。</p>
<hr>
<h3 id="接口移植"><a href="#接口移植" class="headerlink" title="接口移植"></a>接口移植</h3><p>接口的移植主要分为两部分：</p>
<p><strong>屏幕显示接口</strong>和<strong>输入设备接口</strong>。</p>
<p>其中屏幕显示是不可忽略的部分，而输入设备则可以根据自己需求来更改不同的设备。</p>
<p>接口文件都在Clone下来的目录下的example中的porting目录下：</p>
<p><img src="/images/%E6%B5%85%E8%B0%88lvgl%E7%A7%BB%E6%A4%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20211019143944148.png" alt="image-20211019143944148"></p>
<p>分别为<strong>屏幕显示接口</strong>、<strong>文件系统接口</strong>和<strong>输入设备接口</strong>。</p>
<h4 id="屏幕显示接口"><a href="#屏幕显示接口" class="headerlink" title="屏幕显示接口"></a>屏幕显示接口</h4><p>将<code>lv_port_disp_template.c</code>和<code>lv_port_disp_template.h</code>复制到lvgl目录下，与src文件夹同级，然后将两个文件名字中的template删除，并打开<code>#if 0</code>开关。</p>
<p>顺便将接口源文件中的头文件包含改为正确的名字：</p>
<p><code>#include &quot;lv_port_disp.h&quot;</code></p>
<p>接着将该两个文件添加到工程当中（以Cmake为例）：</p>
<p>仅需更改模板文件中的两个语句后重新生成Cmake即可。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;includes&#125;</span> </span><br><span class="line">					ST7735/Inc<span class="comment">#此处为ST7735屏幕驱动所需的包含路径</span></span><br><span class="line">                    lvgl/src/core</span><br><span class="line">                    lvgl/src/draw</span><br><span class="line">                    lvgl/src/extra</span><br><span class="line">                    lvgl/src/font</span><br><span class="line">                    lvgl/src/gpu</span><br><span class="line">                    lvgl/src/hal</span><br><span class="line">                    lvgl/src/misc</span><br><span class="line">                    lvgl/src/widgets</span><br><span class="line">                    lvgl</span><br><span class="line">                    )</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCES <span class="variable">$&#123;sources&#125;</span> <span class="string">&quot;ST7735/*.*&quot;</span> <span class="string">&quot;lvgl/*.*&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>将文件纳入工程后，很明显接口头文件开头的包含路径与我们不一致，故将包含路径稍作修改：<code>#include &quot;lvgl.h&quot;</code></p>
<p>修改后文件的移植工作就完成了，接下来我们对代码进行一些修改。</p>
<h5 id="配置文件修改"><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h5><p>首先打开<code>lv_conf.h</code>：</p>
<p>按照自己的硬件条件对下面的内容进行必要的修改。</p>
<ul>
<li><p>修改屏幕颜色深度宏：<code>LV_COLOR_DEPTH</code></p>
</li>
<li><p><strong>（非必要）</strong>修改RGB565颜色高低位交换宏：<code>LV_COLOR_16_SWAP</code></p>
</li>
<li><p><del>v7版本的库还需要更改一下屏幕分辨率</del></p>
</li>
</ul>
<blockquote>
<p>该文件中设置项较多，因此在使用的过程中可以按照需求对宏进行修改，每条宏都有对应的注释进行解释。</p>
</blockquote>
<h5 id="显示接口文件修改"><a href="#显示接口文件修改" class="headerlink" title="显示接口文件修改"></a>显示接口文件修改</h5><p>首先需要在接口头文件中定义两个与屏幕分辨率有关的宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment"> *      DEFINES</span></span><br><span class="line"><span class="comment"> *********************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_DISP_HOR_RES 80	<span class="comment">//屏幕高度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_DISP_VER_RES 160 <span class="comment">//屏幕宽度</span></span></span><br></pre></td></tr></table></figure>

<p>顺便将下面的代码中的分辨率设置改为我们定义的宏以方便以后的使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Set the resolution of the display*/</span></span><br><span class="line">disp_drv.hor_res = MY_DISP_HOR_RES;</span><br><span class="line">disp_drv.ver_res = MY_DISP_VER_RES;</span><br></pre></td></tr></table></figure>

<p>接下来必须要修改的内容是对于缓冲区的修改：</p>
<p>lvgl中提供了三种缓冲区的使用方式：</p>
<p>单部分缓冲区、双部分缓冲区和双全屏缓冲区</p>
<p>此处使用单部分缓冲区，直接将接口源文件中的另两个示例代码注释掉即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Example for 1) */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">lv_disp_draw_buf_t</span> draw_buf_dsc_1;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">lv_color_t</span> buf_1[MY_DISP_HOR_RES * <span class="number">10</span>];<span class="comment">/*A buffer for 10 rows*/</span></span><br><span class="line">	lv_disp_draw_buf_init(&amp;draw_buf_dsc_1, buf_1, <span class="literal">NULL</span>, MY_DISP_HOR_RES * <span class="number">10</span>);   <span class="comment">/*Initialize the display buffer*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    /* Example for 2) */</span></span><br><span class="line"><span class="comment">//    static lv_disp_draw_buf_t draw_buf_dsc_2;</span></span><br><span class="line"><span class="comment">//    static lv_color_t buf_2_1[MY_DISP_HOR_RES * 10];/*A buffer for 10 rows*/</span></span><br><span class="line"><span class="comment">//    static lv_color_t buf_2_2[MY_DISP_HOR_RES * 10];/*An other buffer for 10 rows*/</span></span><br><span class="line"><span class="comment">//    lv_disp_draw_buf_init(&amp;draw_buf_dsc_2, buf_2_1, buf_2_2, MY_DISP_HOR_RES * 10);   /*Initialize the display buffer*/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    /* Example for 3) also set disp_drv.full_refresh = 1 below*/</span></span><br><span class="line"><span class="comment">//    static lv_disp_draw_buf_t draw_buf_dsc_3;</span></span><br><span class="line"><span class="comment">//    static lv_color_t buf_3_1[MY_DISP_HOR_RES * MY_DISP_VER_RES];            /*A screen sized buffer*/</span></span><br><span class="line"><span class="comment">//    static lv_color_t buf_3_2[MY_DISP_HOR_RES * MY_DISP_VER_RES];            /*An other screen sized buffer*/</span></span><br><span class="line"><span class="comment">//    lv_disp_draw_buf_init(&amp;draw_buf_dsc_3, buf_3_1, buf_3_2, MY_DISP_VER_RES * LV_VER_RES_MAX);   /*Initialize the display buffer*/</span></span><br></pre></td></tr></table></figure>

<p>更改完之后来修改屏幕刷新函数。</p>
<p>最简单的修改方式可以使用逐点刷新：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">disp_flush</span><span class="params">(<span class="keyword">lv_disp_drv_t</span> *disp_drv, <span class="keyword">const</span> <span class="keyword">lv_area_t</span> *area, <span class="keyword">lv_color_t</span> *color_p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> x;</span><br><span class="line">    <span class="keyword">int32_t</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (y = area-&gt;y1; y &lt;= area-&gt;y2; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (x = area-&gt;x1; x &lt;= area-&gt;x2; x++) &#123;</span><br><span class="line">            ST7735_DrawPixel(x, y, color_p-&gt;full);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    lv_disp_flush_ready(disp_drv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可采用逐帧刷新的方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">disp_flush</span><span class="params">(<span class="keyword">lv_disp_drv_t</span> *disp_drv, <span class="keyword">const</span> <span class="keyword">lv_area_t</span> *area, <span class="keyword">lv_color_t</span> *color_p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> width = area-&gt;x2 - area-&gt;x1;</span><br><span class="line">    <span class="keyword">int32_t</span> height = area-&gt;y2 - area-&gt;y1;</span><br><span class="line">    </span><br><span class="line">    ST7735_DrawImage(area-&gt;x1, area-&gt;y1, width, height, (<span class="keyword">uint16_t</span> *) color_p);</span><br><span class="line">    </span><br><span class="line">    lv_disp_flush_ready(disp_drv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于屏幕刷新率值得一提的主要原因有两方面：</p>
<ul>
<li>逐点刷新效率过低</li>
<li>单缓冲区刷新对MCU资源占用很严重</li>
</ul>
<p>针对这两点有几种方式来提高刷新率：</p>
<ul>
<li>采用逐帧刷新</li>
<li>增加缓冲区大小或者个数</li>
<li>采用片上GPU或者DMA2D对帧率进行优化</li>
</ul>
<p>但是奈何工程中用片出于成本考虑往往没有片上GPU，SRAM大小也不足以负载更多的缓冲区，因此建议采用逐帧刷新的方式。</p>
</blockquote>
<p>做完以上的修改之后记得将<code>lv_port_disp_init</code>函数的声明添加到接口头文件中</p>
<blockquote>
<p>（这个锅从v7一直延续到v8，不知是官方有意为之还是如何</p>
</blockquote>
<h5 id="让lvgl的心脏跳动起来"><a href="#让lvgl的心脏跳动起来" class="headerlink" title="让lvgl的心脏跳动起来"></a>让lvgl的心脏跳动起来</h5><blockquote>
<p>这部分的内容对应移植手册中的<a href="https://docs.lvgl.io/8.0/porting/project.html#initialization">Initialization</a>部分</p>
</blockquote>
<p>要想让屏幕亮起来首先要让库里面的代码正常工作，OS中有一个属于自己的心跳，而lvgl也有属于自己的心跳：<code>lv_tick_inc(x)</code></p>
<p>我们需要以一个大于该函数执行时间的固定时间间隔调用该函数来让lvgl的心脏跳起来，其中x是心跳的周期（单位为ms）。</p>
<p>最通常的做法应该是开启一个定时器中断，然后在中断回调函数里面调用该函数，不过ST的HAL库为了使用延时而默认开启了systick中断，中断周期刚好为1ms，这大好资源怎么能放着不用呢？</p>
<p>打开中断服务函数源文件<code>stm32h7xx_it.c</code>；</p>
<p>添加lvgl包含：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lvgl.h&quot;</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br></pre></td></tr></table></figure>

<p>在systick终端服务函数中添加心跳：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief This function handles System tick timer.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_Handler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN SysTick_IRQn 0 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE END SysTick_IRQn 0 */</span></span><br><span class="line">    HAL_IncTick();</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN SysTick_IRQn 1 */</span></span><br><span class="line">    lv_tick_inc(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* USER CODE END SysTick_IRQn 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来要在循环之前调用<code>lv_init()</code>进行库初始化，接着调用<code>lv_port_disp_init()</code>进行显示接口初始化，并循环调用<code>lv_task_handler()</code>来执行任务即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">ST7735_Init();</span><br><span class="line">lv_init();</span><br><span class="line">lv_port_disp_init();</span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    lv_task_handler();</span><br><span class="line">    HAL_GPIO_TogglePin(GPIOE, GPIO_PIN_3);<span class="comment">//循环闪灯以确定程序在正常运行</span></span><br><span class="line">    HAL_Delay(<span class="number">500</span>);</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure>

<p>至此，lvgl的屏幕显示接口移植完成。</p>
<p>由于设备遇到了一些问题，这些问题刚好触及到了一个笔者很感兴趣的领域，故转而鸽掉教程去解决问题，当然结局问题的过程中会撰写一篇过程记录，lvgl待更内容且记录如下。</p>
<h2 id="待更新内容"><a href="#待更新内容" class="headerlink" title="待更新内容"></a>待更新内容</h2><ul>
<li>lvgl输入设备接口移植<ul>
<li>按键接口移植</li>
<li>编码器接口移植</li>
</ul>
</li>
<li>lvgl v7食用方法（Edgeline）</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式GUI</category>
      </categories>
      <tags>
        <tag>嵌入式GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>记编码器的学习历程</title>
    <url>/2021/3bf5a8363ca6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于积分赛要求最近在学电机控制，其中包括PID算法，当然就少不了用编码器来监测电机当前运动状态了，为防止遗忘，特将编码器的学习过程记录如下。</p>
<span id="more"></span>

<h2 id="编码器以及其原理"><a href="#编码器以及其原理" class="headerlink" title="编码器以及其原理"></a>编码器以及其原理</h2><p>首先关于编码器概述不用说太多，网上一搜一大把（以下介绍为复制内容）：</p>
<p>编码器分为光电和霍尔编码器是一种将角位移或者角速度转换成一连串电数字脉冲的旋转式传感器，我们可以通过编码器测量到位移或者速度信息。编码器从输出数据类型上分，可以分为增量式编码器和绝对式编码器。</p>
<p>从编码器检测原理上来分，还可以分为光学式、磁式、感应式、电容式。常见的是光电编码器（光学式）和霍尔编码器（磁式）。两种（以下介绍为复制内容）：</p>
<p>光电编码器是一种通过光电转换将输出轴上的机械几何位移量转换成脉冲或数字量的传感器。光电编码器是由光码盘和光电检测装置组成。光码盘是在一 定直径的圆板上等分地开通若干个长方形孔。由于光电码盘与电动机同轴，电动机旋转时，检测装置检测输出若干脉冲信号，为判断转向，一般输出两组存在一 定相位差的方波信号。</p>
<p>霍尔编码器是一种通过磁电转换将输出轴上的机械几何位移量转换成脉冲或数字量的传感器。霍尔编码器是由霍尔码盘和霍尔元件组成。霍尔码盘是在一 定直径的圆板上等分地布置有不同的磁极。霍尔码盘与电动机同轴，电动机旋转时，霍尔元件检测输出若干脉冲信号，为判断转向，一般输出两组存在一定相位差的方波信号。</p>
<p>下图为正交编码器的输出波形图：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478338406.png" alt="1620478338406"></p>
<p>除了这些还有一个参数对我们很有用，那就是编码器的线数。  </p>
<p>线数是什么呢？  </p>
<p>我们可以简单的理解为线数是多少，那么编码器每转动一圈就会产生多少个脉冲信号。  </p>
<hr>
<h2 id="程序实现（废话不说纯享版）"><a href="#程序实现（废话不说纯享版）" class="headerlink" title="程序实现（废话不说纯享版）"></a>程序实现（废话不说纯享版）</h2><p>实例环境：<strong>STM32F401CCU6+CubeMX+HAL库</strong></p>
<p>首先随便打开一个定时器，打开编码器模式：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478445392.png" alt="1620478445392"></p>
<p>  设置为TI1和TI2共同触发：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478459280.png" alt="1620478459280"></p>
<p>打开串口一以便接收数据<del>（真的不是懒得配置屏幕显示）</del></p>
<p>接下来我们需要额外打开一个定时器来测出单位时间产生了多少脉冲,我用了TIM4来进行定时:  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478474987.png" alt="1620478474987"></p>
<p>  并且打开定时器中断：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478513729.png" alt="1620478513729"></p>
<p>  再打开一个定时器用于产生PWM波（20kHz占空比50%）进而控制电机转动。  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478530063.png" alt="1620478530063"></p>
<p>电机驱动为TB6612，使用并不麻烦，此处不再赘述。</p>
<p>为了方便调试，我们再打开两个连接着开关的IO口用于控制PWM的输出（一个用于控制电机转动与停止，另一个调节占空比），接着生成工程。</p>
<p>敲代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变量定义</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"><span class="keyword">float</span> freq=<span class="number">0</span>，CNT_prevalue=<span class="number">0</span>，period=<span class="number">0</span>，velocity=<span class="number">0</span>，position=<span class="number">0</span>；</span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="comment">//包含头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;math.h&quot;</span></span></span><br><span class="line"><span class="comment">//串口重定向</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">PUTCHAR_PROTOTYPE&#123;</span><br><span class="line">    HAL_UART_Transmit(&amp;huart1, (<span class="keyword">uint8_t</span> *)&amp;ch, <span class="number">1</span> , <span class="number">0xffff</span>);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定时器中断回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span>&#123;</span><br><span class="line">	velocity=(TIM1-&gt;CNT*<span class="number">1.0f</span>-CNT_prevalue)*<span class="number">1.0f</span>*<span class="number">1000</span>/(<span class="number">13</span>*<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//公式应该是：</span></span><br><span class="line">    <span class="comment">// （CNT2-CNT1）*计数器溢出频率/（编码器线数*采集边沿数）</span></span><br><span class="line">    <span class="comment">//PS：因为设置了TI1和TI2共同采样，所以采集边沿为4个。</span></span><br><span class="line">    period = <span class="built_in">fabs</span>( velocity * <span class="number">360</span> );</span><br><span class="line">    position = (<span class="keyword">int</span>)period % <span class="number">360</span>;</span><br><span class="line">    value = TIM1 -&gt; CNT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环前后</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">    HAL_TIM_Base_Start_IT(&amp;htim4);<span class="comment">//开启定时器4中断</span></span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3,TIM_CHANNEL_1);<span class="comment">//开启PWM通道</span></span><br><span class="line">    HAL_TIM_Encoder_Start(&amp;htim1,TIM_CHANNEL_2);<span class="comment">//开启定编码器接口通道</span></span><br><span class="line">    HAL_TIM_Encoder_Start(&amp;htim1,TIM_CHANNEL_1);<span class="comment">//同上</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//控制电机</span></span><br><span class="line">    <span class="keyword">if</span>(!HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1))</span><br><span class="line">    	HAL_GPIO_WritePin(GPIOA,GPIO_PIN_2,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	HAL_GPIO_WritePin(GPIOA,GPIO_PIN_2,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//输出计算结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; v=%.1f r/s\n period=%.1f degrees/s\n position=%.0f degrees\n&quot;</span>,velocity,period,position);</span><br><span class="line">    <span class="comment">//调节方波占空比</span></span><br><span class="line">    <span class="keyword">if</span>(!HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0))</span><br><span class="line">    &#123;</span><br><span class="line">    	TIM3-&gt;CCR1+<span class="number">210</span>&gt;<span class="number">4200</span>?TIM3-&gt;CCR1=<span class="number">0</span>:TIM3-&gt;CCR1+=<span class="number">210</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_Delay(<span class="number">200</span>);</span><br><span class="line"><span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure>

<p>  烧录，测试，结果如图：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478729839.png" alt="1620478729839"></p>
<p>  教程结束。  </p>
<hr>
<h2 id="程序实现（墨迹墨迹解读版）"><a href="#程序实现（墨迹墨迹解读版）" class="headerlink" title="程序实现（墨迹墨迹解读版）"></a>程序实现（墨迹墨迹解读版）</h2><p>方法其实很好理解，只要测量单位时间内输出的脉冲个数即可间接得知转速。</p>
<p>那么如果想测得脉冲个数，相信大家一定会很容易想到输入捕获。</p>
<p><del>输入捕获大家应该都会，好的教程结束，大家加油！</del></p>
<p>我也是第一个想到了输入捕获，不过出现这个想法的时候就有一个问题一直难以解决：</p>
<p>如何判断电机的转向呢？这是个值得思考的问题，因为我们后面想要实现很多功能都需要知道电机的转向，然而仅仅使用输入捕获只能测出脉冲的个数进而测出速度，确实没办法知道电机的转向。此路不通的情况下，就要开始思考其他的方法了。</p>
<p>好在经过好心人的提醒我得知：STM32具有专门的硬件编码器接口，于是立刻跑去翻手册。那么让我们先来看看STM32的硬件编码器接口是怎么回事：</p>
<p>（PS：如果其他的单片机没有如果没有编码器外设的话，我们可以使用GPIO中断进行，在中断里面判断另一相的电平来判断方向，该方法感兴趣的读者可以自己尝试  ）</p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478834327.png" alt="1620478834327"></p>
<p>好家伙，选择接口模式之后直接就选择计数边沿，<del>有输入捕获内味了嗷</del>（可是为什么只选择TI1和TI2的边沿却不是选择TI3、TI4呢？）。</p>
<p>我们打开CubeMX试着配置一下：  </p>
<p>首先随便打开一个定时器（此处其实建议使用片内32位定时器），打开编码器模式：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620478949658.png" alt="1620478949658"></p>
<p>可以看到选下编码器模式之后上面五个配置选项就锁定了。也就是说编码器模式的设置以及频道的使用其实是早就内定好的，并不像其他的模式一样可以自己选择通道。</p>
<p>这件事情其实在参考手册的通用定时器框图里面也得到了验证：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479003499.png" alt="1620479003499">至于手册说的边沿选择这句话  ：</p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479026932.png" alt="1620479026932"></p>
<p>  是在这里设置的：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479037219.png" alt="1620479037219"></p>
<p>正如手册所说，可以选择仅TI1、仅TI2和TI与TI2共同使用三种方式。</p>
<p>继续阅读手册：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479059771.png" alt="1620479059771"></p>
<p>极性？我们回忆一下PWM波中的极性，表示的是OCxREF和实际输出OCx之间的关系（即极性相同或相反）。好的，此处拓展想一下，这里的极性应该也是选择一个二值的量，很明显就是检测边沿。  </p>
<p>对应到CubeMX里面：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479200390.png" alt="1620479200390"></p>
<p>CubeMX里面接下来的IC Selection选项里面只有直接选项，从图里面就可以明确的看出来。继续看手册：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479223708.png" alt="1620479223708"></p>
<p>输入滤波器的编程对应的应该就是这里：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479251663.png" alt="1620479251663"></p>
<p>  至此，CubeMX里面的可设置项就看完了，我们继续看看手册里面还说了什么：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479273239.png" alt="1620479273239"></p>
<p>上面的内容挺让人头大的，不过好在重点就两句。第一句的意思其实就是说<strong>只有当编码器产生脉冲的时候，CNT的值才会改变</strong>。第二句的意思就是说输入改变的时候会更改计数器的计数方向。  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479305031.png" alt="1620479305031"></p>
<p>看到这里我们就懂了，这模式不但能计数，还能辨别转动方向。</p>
<p>后面给出了一个实例我们来看一下：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479327782.png" alt="1620479327782"></p>
<p>上面给出的波形就是编码器的波形，很容易看出编码器正转时CNT递增，反之递减。</p>
<p>因此，我们只需要在中断里面连续进行两次采样，对两次采样的CNT值做差，如果结果为正说明CNT正向计数，即电机正向旋转，反之反向。除此之外，我们还可以通过读取TIMx_CR1寄存器的DIR位来获得计数方向进而得知电机转向：  </p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1620479372193.png" alt="1620479372193"></p>
<p>  实现代码前面给过了，就不赘述了。  </p>
<hr>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>2021.5.17补充：</p>
<p>关于利用GPIO中断写出软件编码器的实现方法：</p>
<p>由于最近在学MSP432，其上并没有硬件编码器接口，因此只能自己写软件编码器，实现了一下发现其实并不难，写在此作为之前内容的补充。</p>
<p>PS：以下实现代码为使用MSP432的函数实现的，STM32版本如果有机会写的话<del>其实就是没机会了</del>会写的。</p>
<p>首先是分析：</p>
<p><img src="/images/%E8%AE%B0%E7%BC%96%E7%A0%81%E5%99%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/1621253575694.png" alt="1621253575694"></p>
<p>观察编码器AB相的输出不难看出，当电机正向旋转时，下方相位领先上方90°，反转反之。</p>
<p>因此，要判断旋转方向其实就是判断两侧输入的相位差，但是单片机并不是示波器，它没法看出两个波形的全貌，只能看到某一瞬间两个波形的高低电平状况。那么有没有好的方法可以<strong>利用瞬间的电平状态</strong>判断出两个波形的相位差呢？答案是有的。</p>
<p>其实很简单，我们观察下<strong>当上方波形出现上升沿的时候，对应下方波形的电平</strong>就会发现：</p>
<p><strong>正向旋转的时候对应为低电平；</strong></p>
<p><strong>反向旋转的时候对应位高电平。</strong></p>
<p>如此我们便实现了对方向的判断。</p>
<p>与此同时，上升沿的个数其实也对应着波形中出现的高电平个数，因此可以利用计数上升沿个数的方法来实现对速度的测量。</p>
<p>MSP432实现代码如下(IDE:Clion):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZheWana on 2021/5/17.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ti/devices/msp432p4xx/driverlib/driverlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UARTRetarget.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Standard Includes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义技术脉冲个数的计数变量CNT</span></span><br><span class="line"><span class="keyword">int32_t</span> CNT;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO中断处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> temp = GPIO_getInputPinValue(GPIO_PORT_P3, GPIO_PIN2);</span><br><span class="line">    <span class="keyword">uint32_t</span> status;</span><br><span class="line">    status = MAP_GPIO_getEnabledInterruptStatus(GPIO_PORT_P3);</span><br><span class="line">    MAP_GPIO_clearInterruptFlag(GPIO_PORT_P3, status);</span><br><span class="line">    <span class="keyword">if</span> (status &amp; GPIO_PIN3) &#123;</span><br><span class="line">        MAP_GPIO_toggleOutputOnPin(GPIO_PORT_P1, GPIO_PIN0);</span><br><span class="line">        <span class="keyword">if</span> (temp == GPIO_INPUT_PIN_HIGH) &#123;</span><br><span class="line">            CNT++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == GPIO_INPUT_PIN_LOW) &#123;</span><br><span class="line">            CNT--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    WDT_A_holdTimer();</span><br><span class="line"></span><br><span class="line">    GPIO_setAsOutputPin(GPIO_PORT_P1, GPIO_PIN0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用P3.3和P3.2作为AB相输入</span></span><br><span class="line">    GPIO_setAsInputPinWithPullUpResistor(GPIO_PORT_P3, GPIO_PIN3);</span><br><span class="line">    GPIO_setAsInputPinWithPullUpResistor(GPIO_PORT_P3, GPIO_PIN2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将P3.3作为中断引脚</span></span><br><span class="line">    GPIO_clearInterruptFlag(GPIO_PORT_P3, GPIO_PIN3);</span><br><span class="line">    GPIO_enableInterrupt(GPIO_PORT_P3, GPIO_PIN3);</span><br><span class="line">    GPIO_interruptEdgeSelect(GPIO_PORT_P3, GPIO_PIN3, GPIO_LOW_TO_HIGH_TRANSITION);</span><br><span class="line"></span><br><span class="line">    Interrupt_enableInterrupt(INT_PORT3);</span><br><span class="line">    Interrupt_enableMaster();</span><br><span class="line">    Interrupt_registerInterrupt(INT_PORT3, GPIO_IRQHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>硬件</category>
        <category>模块</category>
      </categories>
      <tags>
        <tag>编码器</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>记我与机械键盘的一次斗争</title>
    <url>/2021/5291dda0b599/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参加了一个DIY机械键盘的活动，虽然很想自己做一个机械键盘，但是奈何我已经有了一把键盘，再加上经费有限，最终还是没有做。不过我看上凯华的BOX白好久了，于是便借着这次机会换一波轴体。</p>
<span id="more"></span>

<h2 id="一个有趣的小故事"><a href="#一个有趣的小故事" class="headerlink" title="一个有趣的小故事"></a>一个有趣的小故事</h2><p>首先有了换轴的想法之后当然是首先关心一下自己的轴能不能热插拔，于是到当初买轴的地方看了看：</p>
<p><img src="/images/%E8%AE%B0%E6%88%91%E4%B8%8E%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E6%AC%A1%E6%96%97%E4%BA%89/Screenshot_2021-06-16-18-04-46-628_com.taobao.tao-1623901120401.jpg" alt="Screenshot_2021-06-16-18-04-46-628_com.taobao.tao"></p>
<p>好家伙！我直接狂喜！</p>
<p>于是了解了一下拔轴的方法之后就开始自己操作了。</p>
<p>首先是<strong>拔下键帽</strong>：</p>
<p>我使出上古洪荒之力，终于在不借助任何工具的情况下拔下了所有键帽：</p>
<p><img src="/images/%E8%AE%B0%E6%88%91%E4%B8%8E%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E6%AC%A1%E6%96%97%E4%BA%89/1623837920254-1623901133530.jpg" alt="1623837920254"></p>
<p>接着开始拔轴：</p>
<p><strong>用拔轴器分别对准轴体上面和下面的两个卡口，将卡口按下后用力即可将轴体拔出。</strong></p>
<p>念叨着拔轴的诀窍，我拔下了一个又一个轴。</p>
<p>看这拔完轴后剩下的“轴座”，果然是极致的省钱了啊：</p>
<p><img src="/images/%E8%AE%B0%E6%88%91%E4%B8%8E%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E6%AC%A1%E6%96%97%E4%BA%89/65a29b1cacae971c.-1623901149985.jpg" alt="65a29b1cacae971c."></p>
<blockquote>
<ul>
<li>1mm的鸡铜眼作为轴座，可谓是将可拓展空间降低到了极致，这种方案也算是热插拔方案里面最不能热插拔了。</li>
<li>灯用的就是最普通的反贴白色二极管，也是省钱首选。</li>
<li>没有做任何的其他轴体的适应孔位，真就铁了心用这个省钱的方案。</li>
</ul>
</blockquote>
<p>后来拔着拔着发现：<strong>居然有的轴是拔不下来的！！！</strong></p>
<p><img src="/images/%E8%AE%B0%E6%88%91%E4%B8%8E%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E6%AC%A1%E6%96%97%E4%BA%89/Cache_-1eec80bc2896130a.-1623901159717.jpg" alt="Cache_-1eec80bc2896130a."></p>
<p>开始我天真的以为是因为轴体卡的太紧导致无法拔出。</p>
<p>于是我开始期待大力出奇迹，可是无论我如何大力都没有奇迹出现。</p>
<p>后来我就抱着破罐子破摔的心态直接用钳子对其中的一个轴体做了毁灭性的拔除，结果发现了个惊天大秘密！</p>
<p><img src="/images/%E8%AE%B0%E6%88%91%E4%B8%8E%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E6%AC%A1%E6%96%97%E4%BA%89/Cache_-65a29b1cacae971c.-1623901168601.jpg" alt="Cache_-65a29b1cacae971c."></p>
<p>轴下面的电路板上面根本就连鸡铜眼都没有，轴上面断掉的引脚还在焊盘上留着。当然我也考虑过会不会是鸡铜眼被我带掉了的情况，因此抱着严谨的态度我拆掉了键盘，打算看一下背面PCB的焊点。</p>
<p>结果果然和我想得一模一样：这把键盘不但轴座上采用了最省钱的鸡铜眼方案，而且<strong>甚至连鸡铜眼都没有完全的采用</strong>，而是反人类的“半热插拔”（就是<strong>一半轴下面有鸡铜眼，另一半轴下方则是将引脚直接焊接上去的</strong>）</p>
<p>只需要看一下焊盘就可以看得出来：</p>
<p><img src="/images/%E8%AE%B0%E6%88%91%E4%B8%8E%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E6%AC%A1%E6%96%97%E4%BA%89/1623837911991-1623901177190.jpg" alt="1623837911991"></p>
<p>鸡铜眼下方的<strong>焊点头部圆润饱满</strong>，这是由于鸡铜眼本身比较粗的缘故，但是引脚焊接是绝对焊不出这种头部的。</p>
<p>下面我们来看看拔不下来的轴下面的焊点：</p>
<p><img src="/images/%E8%AE%B0%E6%88%91%E4%B8%8E%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E6%AC%A1%E6%96%97%E4%BA%89/1623837905852-1623901184851.jpg" alt="1623837905852"></p>
<p>焊点头部明显是<strong>尖的</strong>，仔细看还能看出引脚的形状。后续用烙铁融化焊盘上的锡浆之后用吸锡器将它吸干净，<strong>可以清楚的看到轴体引脚上面的锡浆。</strong></p>
<p>好了无良商家实锤了。</p>
<p>但是该换的轴还是要换的，最后我还是花了半个下午的时间将原本的轴体拆焊了下来并且将原本的鸡铜眼拆焊下来（主要是由于原本1mm的鸡铜眼小于凯华的轴座引脚直径，导致凯华轴座没法完美的插进去，想着反正都要焊接的，就直接一次性全部解决了吧。），最后将轴体焊接上去，最终完成了轴体的更换。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>机械键盘这东西和很多东西一样，一分钱一分货。大家一定不要像我一样图便宜最终买到了虚假宣传的产品，虽然问题的解决很简单，但是其中浪费的时间成本终究还是得不偿失的。</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>DIY</tag>
      </tags>
  </entry>
  <entry>
    <title>记超声波模块的学习过程</title>
    <url>/2020/726d60366c9d/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天<del>亲身尝试了可怜的打工生活</del>帮助同学搞了一辆智能车，看着上面要求的指标，我意识到似乎我该学一学超声波模块了。  </p>
<span id="more"></span>

<hr>
<h2 id="关于HC-SR04的那些事（想看HC-SR04教程-你在想peach。请后翻）"><a href="#关于HC-SR04的那些事（想看HC-SR04教程-你在想peach。请后翻）" class="headerlink" title="关于HC-SR04的那些事（想看HC-SR04教程?你在想peach。请后翻）"></a>关于HC-SR04的那些事（<del>想看HC-SR04教程?你在想peach。</del>请后翻）</h2><p>当时手里拿的是HC-SR04模块，于是就去查了它的资料,通过CSDN上的一些博客得知它的工作原理之后，我便开始自行操作了。</p>
<p><strong>错误示范</strong></p>
<p>首先，我满怀信心的打开CubeMX,配置了Trig引脚作为输出引脚（下拉），Echo引脚作为输入引脚（下拉）。</p>
<p>接下来，打开一个定时器，纠结了一番后，我打开了定时器中断，<del>别骂了别骂了，在改了在改了</del>将PSC设置为83，将ARR设置为0，于是美滋滋的得到了一个1us触发一次的中断用于计时。只要在中断回调函数里面每次让一个计时变量加一，就可以做到计时了（gepi）。</p>
<p><strong>以下内容虽然整体是错误的，但是还是有一点有用的地方的</strong></p>
<p>再接下来，我需要发出一个超过10us的信号来触发模块工作，于是就产生了一个有趣的问题：<strong>微秒级延时</strong>。在网上找了好多资料都由于我太菜看不懂无果，于是我开始向我们亲爱的学长求助，了解到有一个计数频率等于单片机主频的寄存器，我们可以通过读取其中的值来获得微秒级别的延时。</p>
<p>代码如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay_us</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; i</span><br><span class="line">nt a;</span><br><span class="line">a=SysTick-&gt;VAL;<span class="comment">//读取寄存器的当前值</span></span><br><span class="line"><span class="keyword">while</span>(SysTick-&gt;VAL-a&lt;<span class="number">84</span>*n);<span class="comment">//等待n us</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了好了，接下来就是敲一段简单的主函数代码之后享受胜利的喜悦了。</p>
<p><del>今天学会了超声波模块，真是开心的一天！</del></p>
<p>屁啦！Debug一下发现距离的值根本不会动啊！</p>
<p>询问了学长，得知是定时器中断的频率太快，<del>这谁受得了啊</del>建议用输入捕获来计时。</p>
<p>于是，我又回去卑微的看了一遍参考手册，加上学长的指导，自己有了一些体会：<strong>串口通信真香！</strong></p>
<hr>
<h2 id="关于US-100的那些事"><a href="#关于US-100的那些事" class="headerlink" title="关于US-100的那些事"></a>关于US-100的那些事</h2><p>其实会有以上奇怪的体会还是因为学长<del>满脸嫌弃</del>细心认真的指导：干嘛用那种东西，US-100它不香嘛？  </p>
<p>换了US-100之后我发现，<strong>串口模式的确很香</strong>。  </p>
<p>模块拿到手，首先是万年不变的查资料过程。（PS：请注意观察模块的引脚连线部分内容，一般的串口通信都是Tx连接Rx，Rx连接Tx，而这个模块<strong>刚好相反</strong>。）  </p>
<p>了解了模块的使用方法之后，我便开始操作（梅开二度）了：  </p>
<p>首先，打开CubeMX进行引脚的配置，此处需要打开一组串口并使能串口中断以确保收发数据时不会被打断，我用的是USART1。  </p>
<p>定义两个变量，一个用来发送触发信号，一个用来接收两个字节的反馈信息：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> receive[<span class="number">2</span>];<span class="comment">//存储接收的数据</span></span><br><span class="line"><span class="keyword">double</span> dis;<span class="comment">//存储计算得到的距离</span></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">256</span>];<span class="comment">//显示变量所需要的缓冲变量</span></span><br><span class="line"><span class="keyword">uint8_t</span> sign=<span class="number">0x55</span>;<span class="comment">//触发信号</span></span><br></pre></td></tr></table></figure>

<p>在正确配置屏幕之后，在循环语句前后敲上以下代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">    u8g2_Setup_ssd1306_128x64_noname_1(&amp;u8g2, U8G2_R0, u8x8_byte_4wire_hw_spi,</span><br><span class="line">    u8x8_gpio_and_delay);</span><br><span class="line">    u8g2_InitDisplay(&amp;u8g2);</span><br><span class="line">    u8g2_SetPowerSave(&amp;u8g2, <span class="number">0</span>); <span class="comment">//u8g2屏幕的初始化</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    HAL_UART_Transmit_IT(&amp;huart1,&amp;sign,<span class="number">1</span>);</span><br><span class="line">    HAL_UART_Receive_IT(&amp;huart1,receive,<span class="number">2</span>);</span><br><span class="line">    u8g2_FirstPage(&amp;u8g2);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        u8g2_SetFont(&amp;u8g2, u8g2_font_courR18_tf);</span><br><span class="line">        <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%.2lf&quot;</span>,dis);</span><br><span class="line">        u8g2_DrawStr(&amp;u8g2, <span class="number">0</span>, <span class="number">15</span>, buffer);</span><br><span class="line">        u8g2_DrawStr(&amp;u8g2, <span class="number">80</span>, <span class="number">31</span>, <span class="string">&quot;cm&quot;</span> );</span><br><span class="line">    &#125; <span class="keyword">while</span> (u8g2_NextPage(&amp;u8g2));</span><br><span class="line">    HAL_Delay(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure>

<p>最后定义中断回调函数并在其中计算距离：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dis=((<span class="keyword">double</span>)receive[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>+(<span class="keyword">double</span>)receive[<span class="number">1</span>])/<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就可以在我们的屏幕上面显示模块测量的距离值了。<br><del>什么你问HC-SR04？你就是为了它才来的？没门！</del><br>我这就去学输入捕获………  </p>
<p><strong>A FEW THOUSEND YEARS LATER……..</strong></p>
<hr>
<h2 id="关于HC-SR04"><a href="#关于HC-SR04" class="headerlink" title="关于HC-SR04"></a>关于HC-SR04</h2><p>经过不断的请教之后，我终于弄懂了我心心念念的输入捕获。<br>是这样的，在F4参考手册里面有这样的一个图：  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620482530457.png" alt="1620482530457"></p>
<p>这张图对于我们弄懂输入捕获至关重要，在尝试期间我出现过了许多<del>玄学错误</del>由于不懂原理而出现的错误，下面一一与大家分享。（观前提示：以下错误均是在TIM引脚的配置上出现的，我使用的是TIM2。）  </p>
<p><strong>一大波错误示范如期而至</strong></p>
<p><strong>(对于其中原理不感兴趣的童鞋请直接移步下一部分,会提供完整的代码供移植)</strong></p>
<p>首先屏幕和IO口的配置就不赘述了 ：  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620482586012.png" alt="1620482586012"></p>
<p>看了参考手册里面关于输入捕获的介绍之后，我便开始了操作：</p>
<p>此时对于输入捕获，我的理解是这样的：</p>
<p>首先我看到了这张图  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620482641174.png" alt="1620482641174"></p>
<p>  哦！检测到跳变沿后<strong>CCRx会获取CNT寄存器的值并且锁存</strong>，因此我们只需要读取CCRx的值就可以得到从<strong>CNT为0</strong>一直到<strong>跳变沿发生</strong>经过的时间，那么问题来了，CNT什么时候为０呢？于是我继续看到了这张图：</p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620482728662.png" alt="1620482728662"></p>
<p>好嘛!这不是写的明明白白的嘛!第一个上升沿时IC1和IC2共同捕获,并且将计数器(CNT寄存器)复位，到达下降沿时IC2再次捕获，将CNT的值锁存到CCR2寄存器里面,下次上升沿来的时候重复以上操作.<br><del>被快乐冲昏了头脑</del>我配置了TIM引脚如下:  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620482766886.png" alt="1620482766886"></p>
<p>生成代码后完成一番配置,接着在循环前后敲下如下代码:  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_IC_Start(&amp;htim2,TIM_CHANNEL_1);<span class="comment">//使能输入捕获</span></span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       Trig();<span class="comment">//发出触发信号</span></span><br><span class="line">       HAL_Delay(<span class="number">100</span>);<span class="comment">//延时是为了给模块完成回响信号的发送的时间</span></span><br><span class="line">       a=TIM2-&gt;CCR2;<span class="comment">//读取CCR2的值</span></span><br><span class="line">       dis=a/<span class="number">84000</span>*<span class="number">17</span>;<span class="comment">//根据声速公式进行计算(PS:CNT寄存器计时的频率等于总线频率经过预分频</span></span><br><span class="line">       后的结果)</span><br><span class="line">       u8g2_FirstPage(&amp;u8g2);</span><br><span class="line">       <span class="keyword">do</span></span><br><span class="line">       &#123; </span><br><span class="line">           u8g2_SetFont(&amp;u8g2, u8g2_font_courR18_tf);</span><br><span class="line">           <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%.2lf&quot;</span>,dis);</span><br><span class="line">           u8g2_DrawStr(&amp;u8g2, <span class="number">0</span>, <span class="number">15</span>, buffer);	</span><br><span class="line">       &#125; <span class="keyword">while</span> (u8g2_NextPage(&amp;u8g2));</span><br><span class="line">       <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line">       <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure>

<p>变量定义:  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trig</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">double</span> a,dis;</span><br></pre></td></tr></table></figure>

<p>触发函数Trig():  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trig</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HAL_GPIO_WritePin(GPIOA,GPIO_PIN_1,GPIO_PIN_SET);</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a=SysTick-&gt;VAL;</span><br><span class="line">    <span class="keyword">while</span>(SysTick-&gt;VAL-a&lt;<span class="number">840</span>);<span class="comment">//延时10us</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOA,GPIO_PIN_1,GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(以上代码可以放心移植,因为问题不出在代码上,不过后面会有点小调整.)<br>烧完了程序,玄学现象出现了:屏幕上的数字一直是0.00…….<br>作为一个菜狗  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620482979560.png" alt="1620482979560"></p>
<p>我想了好久才想到是怎么回事,我看到了之前的那张图:  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620482996852.png" alt="1620482996852"></p>
<p>意识到频道一的值似乎应该用CCR1啊,又注意到PWM输入时序图上面写的是PWM输入不是输入捕获，我瞬间懂了，看来我想的是对的，就是应该用CCR1的值,于是就改成了读取CCR1的值.<strong>（一个错误的结论）</strong><br>再次运行………<br>屏幕上的数字不再是0.00了我十分兴奋,<del>今天搞懂了HC-SR04 ,真是开心！</del>不过我很快就意识到了问题:<br>数字在不断的上涨,没有一点停止的迹象.  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483068136.png" alt="1620483068136"></p>
<p>不知所措的我再次向手册求助,问题还是出在了这张图上面：</p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483088539.png" alt="1620483088539"></p>
<p>注意到了TI1FP1和IC１以及CCR1的关系:  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483101258.png" alt="1620483101258"></p>
<p>我意识到自己根本没有进行TI1FP1的配置,于是回到MX里面进行配置，很快就又发现：  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483115539.png" alt="1620483115539"></p>
<p>这唤起了我的记忆,好像是要配置一个Reset Mode来着?  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483131833.png" alt="1620483131833"></p>
<p>点下Reset Mode的一瞬间,我悟了,马上去手册里面翻看,果然发现了:  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483146068.png" alt="1620483146068"></p>
<p>复位模式是需要进行配置的,而这个Reset Mode显然就是对此进行了配置,而之前数值不断上升的现象显然是CNT寄存器没有重置导致的.<br>好嘞!生成代码烧程序<del>收工!</del><br>这次数字果然没有一直增加,然而却会一直乱跳,即使我完全没有碰模块,也会一直乱跳.  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483187822.png" alt="1620483187822"></p>
<p>转念一想,PWM时序图里面测量脉冲长度的是啥来着?CCR2吧,可是我读CCR2是0,读取CCR1又出现这么奇怪的读数,果然还是串口香,HC-SR04算个屁,教程结束!问题应该还是出在那张我看不懂的乱七八糟关系图上,于是我硬着头皮开始硬看,好在看懂了,不然就劝退了.</p>
<p><strong>以下为正确内容</strong></p>
<p>其实我们只需要关注这么一小部分就可以:  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483231142.png" alt="1620483231142"></p>
<p>首先,最上面一行告诉我们了CNT计数器的频率是主频经过PSC分频之后得到的频率，这为我们计算脉冲宽度（时间）提供了时间基准．</p>
<p>接下来，想想我们之前说的话:  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483264848.png" alt="1620483264848"></p>
<p>捕获脉冲宽度的是IC2而不是IC1,所以的确是应该读取CCR2的值的,可是为什么之前的实验得到的值是0呢?我们再来看图:  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483287339.png" alt="1620483287339"></p>
<p>显然IC2的输入大部分是从CH2里面过来的,我们用的是CH1啊,根本就没有输入怎么会有值呢?可是总不能再分一路到CH2去吧?</p>
<p>别慌,仔细看图就会发现IC2的输入里面有一个<strong>卧底</strong>,那就是TI1FP2:  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483332852.png" alt="1620483332852"></p>
<p>可以看出它不是直接由CH2输入到IC2的,换句话说就是从CH1间接输入到CH2的.</p>
<p>好的,相信大家都想到了我们之前讲的CH2间接模式(其实大家应该很早就想到了,只有我这样的菜狗才会这么晚才意识到问题所在orz):  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483356038.png" alt="1620483356038"></p>
<p>到了这里,我们已经离成功不远了,需要注意的是(别问我怎么注意到的):CH2有一个单独的边沿设置选项,默认为上升沿捕获,  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483372851.png" alt="1620483372851"></p>
<p>而我们希望IC2捕获下降沿,所以记得更改捕获边沿为下降沿.</p>
<p>接下来敲代码,完成.  </p>
<hr>
<h2 id="仅供参考的例程"><a href="#仅供参考的例程" class="headerlink" title="仅供参考的例程"></a>仅供参考的例程</h2><p>1.屏幕的配置略</p>
<p>2.CubeMX配置:  </p>
<p>打开TIM2_CH1连接ECHO引脚以便捕获回响信号;<br>将A1设置为GPIO输出模式并下拉，用作触发引脚．  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483454734.png" alt="1620483454734"></p>
<p>定时器配置如图：(箭头指向为非默认选项)  </p>
<p><img src="/images/%E8%AE%B0%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1620483468995.png" alt="1620483468995"></p>
<p>3.代码内容:</p>
<p>变量定义和函数声明:  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trig</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">double</span> a,dis;</span><br></pre></td></tr></table></figure>

<p>触发函数Trig()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trig</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HAL_GPIO_WritePin(GPIOA,GPIO_PIN_1,GPIO_PIN_SET);</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a=SysTick-&gt;VAL;</span><br><span class="line">    <span class="keyword">while</span>(SysTick-&gt;VAL-a&lt;<span class="number">840</span>);<span class="comment">//延时10us</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOA,GPIO_PIN_1,GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数循环前后:  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_IC_Start(&amp;htim2,TIM_CHANNEL_1);<span class="comment">//使能输入捕获</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Trig();<span class="comment">//发出触发信号</span></span><br><span class="line">        HAL_Delay(<span class="number">100</span>);<span class="comment">//延时是为了给模块完成回响信号的发送的时间</span></span><br><span class="line">        a=TIM2-&gt;CCR2;<span class="comment">//读取CCR2的值</span></span><br><span class="line">        dis=a/<span class="number">84000</span>*<span class="number">17</span>;<span class="comment">//根据声速公式进行计算(PS:CNT寄存器计时的频率等于总线频率经过预分频后的结果)</span></span><br><span class="line">        u8g2_FirstPage(&amp;u8g2);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123; </span><br><span class="line">            u8g2_SetFont(&amp;u8g2, u8g2_font_courR18_tf);</span><br><span class="line">            <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%.2lf&quot;</span>,dis);</span><br><span class="line">            u8g2_DrawStr(&amp;u8g2, <span class="number">0</span>, <span class="number">15</span>, buffer);</span><br><span class="line">        &#125; <span class="keyword">while</span> (u8g2_NextPage(&amp;u8g2));</span><br><span class="line">        <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line">        <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">    &#125; </span><br><span class="line">	<span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>谨以此文记录自己学习超声波模块的曲折过程，分享给大家希望能给正在研究超声波模块的人以帮助.</p>
]]></content>
      <categories>
        <category>硬件</category>
        <category>模块</category>
      </categories>
      <tags>
        <tag>超声波模块</tag>
      </tags>
  </entry>
  <entry>
    <title>通过串口空闲中断结合DMA的方式实现不定长数据的接受</title>
    <url>/2021/2ec127a02bc8/</url>
    <content><![CDATA[<p>本文为我自己写的串口收发函数的使用说明，采用了串口空闲中断+DMA的方式来实现不定长数据的接收。</p>
<p>环境：<strong>STM32F401CCU6+CubeMX+HAL库</strong></p>
<span id="more"></span>

<p>首先打开串口并打开串口的收发DMA。</p>
<p>接下来全部编译一遍文件。</p>
<p>找到main.h文件，在对应位置插入回调函数函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN EFP */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_UART_IDLECallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span>;</span><br><span class="line"><span class="comment">/* USER CODE END EFP */</span></span><br></pre></td></tr></table></figure>

<p>进入stm32f4xx_it.c文件，在串口中断函数里面插入空闲中断服务函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* USER CODE BEGIN USART1_IRQn 1 */</span></span><br><span class="line"><span class="comment">//判断是否是串口1</span></span><br><span class="line"><span class="keyword">if</span>(USART1 == huart1.Instance)                                   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断是否是空闲中断</span></span><br><span class="line">	<span class="keyword">if</span>(RESET != __HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_IDLE))   </span><br><span class="line">    &#123;	</span><br><span class="line">        <span class="comment">//清除空闲中断标志（否则会一直不断进入中断）</span></span><br><span class="line">        __HAL_UART_CLEAR_IDLEFLAG(&amp;huart1);                     </span><br><span class="line">        <span class="comment">//调用中断回调函数</span></span><br><span class="line">        My_UART_IDLECallback(&amp;huart1);                         </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/* USER CODE END USART1_IRQn 1 */</span></span><br></pre></td></tr></table></figure>

<p>最后在main.c文件里面加入我们自己的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN PD */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 20</span></span><br><span class="line"><span class="comment">/* USER CODE END PD */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myuart</span>&#123;</span></span><br><span class="line">	<span class="keyword">uint8_t</span>* buffer_addr;<span class="comment">//缓冲区首地址</span></span><br><span class="line">	<span class="keyword">uint32_t</span> date_size;<span class="comment">//传输数据长度</span></span><br><span class="line">&#125;myuart_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口结构体初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_UART_IDLEIT_DMA_Init</span><span class="params">(<span class="keyword">uint8_t</span>* Address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myuart_1.buffer_addr=Address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口接收函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_UART_IDLEIT_DMA_Receive</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">uint8_t</span> *pData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__HAL_UART_ENABLE_IT(huart, UART_IT_IDLE);<span class="comment">//开启空闲中断</span></span><br><span class="line">	HAL_UART_Receive_DMA(huart, pData, BUFFER_SIZE);<span class="comment">//开启DMA接收函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口发送函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_UART_IDLEIT_DMA_Transmit</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">uint8_t</span> *pData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__HAL_UART_ENABLE_IT(huart, UART_IT_IDLE);<span class="comment">//开启空闲中断</span></span><br><span class="line">	HAL_UART_Transmit_DMA(huart, pData, BUFFER_SIZE);<span class="comment">//开启DMA发送函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空闲中断回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_UART_IDLECallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HAL_UART_DMAStop(huart);<span class="comment">//停止DMA传输</span></span><br><span class="line">	</span><br><span class="line">	myuart_1.date_size = BUFFER_SIZE - 	__HAL_DMA_GET_COUNTER(huart-&gt;hdmarx);<span class="comment">//计算数据长度</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*数据处理函数开始*/</span></span><br><span class="line">	<span class="comment">/*bla  bla ....*/</span></span><br><span class="line">	<span class="comment">/*数据处理函数结束*/</span></span><br><span class="line">	<span class="built_in">memset</span>(myuart_1.buffer_addr, <span class="number">0</span>, myuart_1.date_size);<span class="comment">//重置缓冲区</span></span><br><span class="line">	</span><br><span class="line">	HAL_UART_Receive_DMA(huart, myuart_1.buffer_addr, BUFFER_SIZE);<span class="comment">//开启DMA接受函数</span></span><br><span class="line">	__HAL_UART_ENABLE_IT(huart, UART_IT_IDLE);<span class="comment">//开启空闲中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>单片机</category>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ExternalFlash缝合记</title>
    <url>/2021/93640b71849b/</url>
    <content><![CDATA[<p>在撰写<a href="https://zhewana.cn/2021/7dd8d670d9f4/">浅谈LVGL学习、移植与使用</a>的过程中发现STM32H750VBT6的FLASH仅有128k大小，做了简单的lvgl移植之后Flash竟然被写爆了，因此不得不将写到一半的教程停手，转而解决这个问题，特此记录。</p>
<span id="more"></span>

<blockquote>
<p>观前提醒：</p>
<p>作为一篇<strong>问题随记</strong>大概率是又臭又长，而且过程中会有一大堆的弯路错路，对于看到的内容请读者仔细甄别。</p>
<p>问题随记不定时更新，直到问题解决完结（毕竟你不能要求笔者解决了问题再来重新写</p>
</blockquote>
<h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>问题描述：STM32H750VBT6的<strong>Flash空间过小</strong>，代码稍微多一点就会将其塞爆。</p>
<p>笔者目的：将板载的一块W25Q64通过<strong>QSPI内存映射</strong>的方式作为InterFlash的拓展。</p>
<p>实现平台：<strong>Clion</strong></p>
<p>解决思路：</p>
<ol>
<li>修改OpenOCD：根据有类似应用的Board脚本修改stm32h7xx.cfg文件</li>
<li>修改ld文件：根据所需的内存布局修改连接脚本文件</li>
<li>问题解决</li>
</ol>
<h2 id="问题探索"><a href="#问题探索" class="headerlink" title="问题探索"></a>问题探索</h2><h3 id="修改OpenOCD"><a href="#修改OpenOCD" class="headerlink" title="修改OpenOCD"></a>修改OpenOCD</h3><p>所找到的参考文件为：<code>...\openocd\scripts\board\stm32l476g-disco.cfg</code></p>
<p>内容也不过寥寥几十行：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This is an STM32L476G discovery board with a single STM32L476VGT6 chip.</span></span><br><span class="line"><span class="comment"># http://www.st.com/en/evaluation-tools/32l476gdiscovery.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is for using the onboard STLINK</span></span><br><span class="line"><span class="keyword">source</span> [find interface/stlink.cfg]</span><br><span class="line"></span><br><span class="line">transport select hla_swd</span><br><span class="line"></span><br><span class="line"><span class="comment"># increase working area to 96KB</span></span><br><span class="line"><span class="keyword">set</span> WORKAREASIZE <span class="number">0x18000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># enable stmqspi</span></span><br><span class="line"><span class="keyword">set</span> QUADSPI <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">source</span> [find target/stm32l4x.cfg]</span><br><span class="line"></span><br><span class="line"><span class="comment"># QUADSPI initialization</span></span><br><span class="line"><span class="keyword">proc</span><span class="title"> qspi_init</span> &#123; &#125; &#123;</span><br><span class="line">	<span class="keyword">global</span> a</span><br><span class="line">	mmw <span class="number">0x4002104C</span> <span class="number">0x000001FF</span> <span class="number">0</span>				<span class="comment">;# RCC_AHB2ENR |= GPIOAEN-GPIOIEN (enable clocks)</span></span><br><span class="line">	mmw <span class="number">0x40021050</span> <span class="number">0x00000100</span> <span class="number">0</span>				<span class="comment">;# RCC_AHB3ENR |= QSPIEN (enable clock)</span></span><br><span class="line">	sleep <span class="number">1</span>									<span class="comment">;# Wait for clock startup</span></span><br><span class="line"></span><br><span class="line"><span class="comment">	# PE11: NCS, PE10: CLK, PE15: BK1_IO3, PE14: BK1_IO2, PE13: BK1_IO1, PE12: BK1_IO0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">	# PE15:AF10:V, PE14:AF10:V, PE13:AF10:V, PE12:AF10:V, PE11:AF10:V, PE10:AF10:V</span></span><br><span class="line"></span><br><span class="line"><span class="comment">	# Port E: PE15:AF10:V, PE14:AF10:V, PE13:AF10:V, PE12:AF10:V, PE11:AF10:V, PE10:AF10:V</span></span><br><span class="line">	mmw <span class="number">0x48001000</span> <span class="number">0xAAA00000</span> <span class="number">0x55500000</span>    <span class="comment">;# MODER</span></span><br><span class="line">	mmw <span class="number">0x48001008</span> <span class="number">0xFFF00000</span> <span class="number">0x00000000</span>    <span class="comment">;# OSPEEDR</span></span><br><span class="line">	mmw <span class="number">0x48001024</span> <span class="number">0xAAAAAA00</span> <span class="number">0x55555500</span>    <span class="comment">;# AFRH</span></span><br><span class="line"></span><br><span class="line">	mww <span class="number">0xA0001030</span> <span class="number">0x00001000</span>				<span class="comment">;# QUADSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full</span></span><br><span class="line">	mww <span class="number">0xA0001000</span> <span class="number">0x01500008</span>				<span class="comment">;# QUADSPI_CR: PRESCALER=1, APMS=1, FTHRES=0, FSEL=0, DFM=0, SSHIFT=0, TCEN=1</span></span><br><span class="line">	mww <span class="number">0xA0001004</span> <span class="number">0x00170100</span>				<span class="comment">;# QUADSPI_DCR: FSIZE=0x17, CSHT=0x01, CKMODE=0</span></span><br><span class="line">	mmw <span class="number">0xA0001000</span> <span class="number">0x00000001</span> <span class="number">0</span>				<span class="comment">;# QUADSPI_CR: EN=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">	# memory-mapped read mode with 3-byte addresses</span></span><br><span class="line">	mww <span class="number">0xA0001014</span> <span class="number">0x0D002503</span>				<span class="comment">;# QUADSPI_CCR: FMODE=0x3, DMODE=0x1, DCYC=0x0, ADSIZE=0x2, ADMODE=0x1, IMODE=0x1, INSTR=READ</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_TARGETNAME</span> configure -event reset-init &#123;</span><br><span class="line">	mmw <span class="number">0x40022000</span> <span class="number">0x00000004</span> <span class="number">0x00000003</span>	<span class="comment">;# 4 WS for 72 MHz HCLK</span></span><br><span class="line">	sleep <span class="number">1</span></span><br><span class="line">	mmw <span class="number">0x40021000</span> <span class="number">0x00000100</span> <span class="number">0x00000000</span>	<span class="comment">;# HSI on</span></span><br><span class="line">	mww <span class="number">0x4002100C</span> <span class="number">0x01002432</span>				<span class="comment">;# 72 MHz: PLLREN=1, PLLM=4, PLLN=36, PLLR=2, HSI</span></span><br><span class="line">	mww <span class="number">0x40021008</span> <span class="number">0x00008001</span>				<span class="comment">;# always HSI, APB1: /1, APB2: /1</span></span><br><span class="line">	mmw <span class="number">0x40021000</span> <span class="number">0x01000000</span> <span class="number">0x00000000</span>	<span class="comment">;# PLL on</span></span><br><span class="line">	sleep <span class="number">1</span></span><br><span class="line">	mmw <span class="number">0x40021008</span> <span class="number">0x00000003</span> <span class="number">0x00000000</span>	<span class="comment">;# switch to PLL</span></span><br><span class="line">	sleep <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	adapter speed <span class="number">4000</span></span><br><span class="line"></span><br><span class="line">	qspi_init</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本着先看懂再模仿的原则，先对文件语言进行了解：</p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211021224043056.png" alt="image-20211021224043056"></p>
<blockquote>
<p>机译：</p>
<p>OpenOCD使用一个称为JimTcl的小型“Tcl解释器”。该编程语言提供了一个简单且可扩展的命令解释器。</p>
<p>本指南中提供的所有命令都是Jim Tcl的扩展。您可以将它们作为简单的命令使用，而无需了解有关Tcl的很多内容。或者，您可以使用它们编写Tcl程序。</p>
<p>你可以在Jim的网站上了解更多关于Jim的信息，<a href="http://jim.tcl.tk/">http://jim.tcl.tk</a>. 这里有一个积极响应的社区，如果您有任何问题，请加入邮件列表。Jim Tcl维护人员也潜伏在OpenOCD邮件列表中。</p>
</blockquote>
<p>文件使用的是Jim-Tcl，无需过多了解细节，直接冲向Tcl Crash Course：</p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211021224452411.png" alt="image-20211021224452411"></p>
<p>浏览了一下，内容只有6页，开始逐句啃……</p>
<h4 id="手册译文"><a href="#手册译文" class="headerlink" title="手册译文"></a>手册译文</h4><blockquote>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211021224804595.png" alt="image-20211021224804595"></p>
<h5 id="Tcl速成班"><a href="#Tcl速成班" class="headerlink" title="Tcl速成班"></a><strong>Tcl速成班</strong></h5><p>不是每个人都知道Tcl-这不是为了替代学习 Tcl，本章的目的是让您了解 Tcl 脚本的工作原理。</p>
<p>本章是为两类读者而写的：</p>
<p>(1) OpenOCD 用户需要更多地了解 Jim-Tcl 的工作原理，以便他们可以做一些有用的事情，以及 (2) 那些想要向 OpenOCD 添加新命令的用户。</p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211021225006109.png" alt="image-20211021225006109"></p>
<h5 id="Tcl规则-1"><a href="#Tcl规则-1" class="headerlink" title="Tcl规则#1"></a><strong>Tcl规则#1</strong></h5><p>有一个著名的笑话，它是这样说的：</p>
<ol>
<li>规则1：妻子总是对的。</li>
<li>规则2：如果你不这么认为，请参见规则1</li>
</ol>
<p>Tcl的等效说法如下：</p>
<ol>
<li>规则#1：一切都是一个字符串</li>
<li>规则2：如果你不这么认为，请参见规则1</li>
</ol>
<p>正如著名的笑话中所说，规则1的后果是深远的。一旦你理解了规则1，你就会理解Tcl。</p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022104909141.png" alt="image-20211022104909141"></p>
<h5 id="Tcl-规则-1b"><a href="#Tcl-规则-1b" class="headerlink" title="Tcl 规则#1b"></a><strong>Tcl 规则#1b</strong></h5><p>还有第二对规则。</p>
<ol>
<li><p>规则#1：控制流不存在。 只有命令 </p>
<p>例如：经典的 FOR 循环或 IF 语句不是控制流项，它们是命令，Tcl 中没有控制流这样的东西。</p>
</li>
<li><p>规则#2：如果您不这么认为，请参阅规则#1 </p>
<p>实际上发生的事情是这样的：按照惯例，有些命令的作用类似于其他语言中的控制流关键字。 其中一个命令是单词“for”，另一个命令是“if”。</p>
</li>
</ol>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022105045074.png" alt="image-20211022105045074"></p>
<h5 id="每个规则-1-所有结果都是字符串"><a href="#每个规则-1-所有结果都是字符串" class="headerlink" title="每个规则#1 - 所有结果都是字符串"></a><strong>每个规则#1 - 所有结果都是字符串</strong></h5><p>每个 Tcl 命令都会导致一个字符串。 “导致”这个词是故意使用的。 没有结果只是一个空字符串。 记住：规则#1 - 一切都是字符串</p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022105226180.png" alt="image-20211022105226180"></p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022105239612.png" alt="image-20211022105239612"></p>
<h5 id="Tcl-引用操作符"><a href="#Tcl-引用操作符" class="headerlink" title="Tcl 引用操作符"></a><strong>Tcl 引用操作符</strong></h5><p>在 Tcl 脚本的生命周期中，有两个重要的时间段，区别很细微。 </p>
<ol>
<li>解析时间 </li>
<li>评估时间</li>
</ol>
<p>这里的两个关键项目是“引用的东西”在 Tcl 中的工作方式。 Tcl 有三个主要的引用结构，[方括号]、{花括号}和“双引号”</p>
<p>现在您应该知道 <code>$VARIABLES</code> 总是以 <code>$</code> 符号开头。顺便说一句：要设置变量，您实际上使用命令“set”，就像在“set VARNAME VALUE”中一样，很像古老的 BASIC 语言“let x = 1”语句，但没有等号。 </p>
<ul>
<li><p><strong>[方括号]</strong> </p>
<p><strong>[方括号]</strong> 是命令替换。 它的操作很像 Unix Shell 的“反引号”。 [方括号] 操作的结果正好是 1 个字符串。 <em>记住规则#1 - 一切都是一个字符串</em>。 这两个语句大致相同： </p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bash example </span></span><br><span class="line">X=‘date‘ </span><br><span class="line">echo <span class="string">&quot;The Date is: $X&quot;</span> </span><br><span class="line"><span class="comment"># Tcl example </span></span><br><span class="line"><span class="keyword">set</span> X [date] </span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;The Date is: $X&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>“双引号”</strong> </p>
<p><strong>“双引号”</strong>只是简单的引用文本。 $VARIABLES 和 [squarebrackets] 扩展到位 - 然而结果正好是 1 个字符串。 记住规则#1 - 一切都是字符串</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> x <span class="string">&quot;Dinner&quot;</span> </span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;It is now \&quot;[date]\&quot;, $x is in 1 hour&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>{Curly-Braces}</strong> </p>
<p><strong>{Curly-Braces}</strong> 很神奇：$VARIABLES 和[方括号] 会被解析，但不会被扩展或执行。 {Curly-Braces} 就像 BASH shell 脚本中的“单引号”运算符，增加了一个特性：{curly-braces} 可以嵌套，单引号不能。</p>
<p>注意：[date] 是一个不好的例子； 在撰写本文时，Jim/OpenOCD 没有日期命令。</p>
</li>
</ul>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022112515437.png" alt="image-20211022112515437"></p>
<h5 id="规则1-2-3-4的后果"><a href="#规则1-2-3-4的后果" class="headerlink" title="规则1/2/3/4的后果"></a><strong>规则1/2/3/4的后果</strong></h5><p>规则1的后果是深远的。</p>
<h6 id="标记化和执行。"><a href="#标记化和执行。" class="headerlink" title="标记化和执行。"></a><strong>标记化和执行。</strong></h6><p>当然，空格、空行和#注释行是按正常方式处理的。在解析脚本时，脚本文件中的每一行（多行）都会根据引用规则进行标记。标记化后，该行立即执行。</p>
<p>多行语句以一个或多个“仍然打开的”{花括号}结尾，最终在几行之后关闭。</p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022112845267.png" alt="image-20211022112845267"></p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022113050840.png" alt="image-20211022113050840"></p>
<h6 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a><strong>命令执行</strong></h6><p>请记住前面的内容：Tcl中没有“控制流”语句。相反，有一些命令的作用与控制流操作符类似。</p>
<p>命令的执行方式如下：</p>
<ol>
<li><p>将下一行解析为（argc）和（argv[]）。</p>
</li>
<li><p>在表中查找（argv[0]），并调用其函数。</p>
</li>
<li><p>重复此操作，直到文件结束。</p>
</li>
</ol>
<p>它的工作原理是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">	ReadAndParse( &amp;argc, &amp;argv ); </span><br><span class="line">	cmdPtr = LookupCommand( argv[<span class="number">0</span>] ); </span><br><span class="line">	(*cmdPtr-&gt;Execute)( argc, argv );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当解析命令“proc”(创建一个过程函数)时，它在命令行上获得3个参数。</p>
<p><strong>1</strong>是 proc (function)的名称，<strong>2</strong>是参数列表，<strong>3</strong>是函数体。不是用词的问题: LIST 和 BODY。PROC 命令将这些项目存储在某个表中，以便“LookupCommand ()”可以找到它</p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022113444762.png" alt="image-20211022113444762"></p>
<h6 id="FOR-命令"><a href="#FOR-命令" class="headerlink" title="FOR 命令"></a><strong>FOR 命令</strong></h6><p>最有趣的命令是 FOR 命令。 在 Tcl 中，FOR 命令通常在 C 中实现。记住，FOR 是一个命令，就像任何其他命令一样。 当解析包含 FOR 命令的 ascii 文本时，解析器会生成 5 个参数字符串，<em>（如果有疑问：请参阅规则 #1）</em>它们是：</p>
<ol start="0">
<li><p>ascii 文本 ‘for’ </p>
</li>
<li><p>开始文本 </p>
</li>
<li><p>测试表达式 </p>
</li>
<li><p>下一个文本 </p>
</li>
<li><p>正文文本</p>
</li>
</ol>
<p>有点让你想起“main(int argc, char **argv)”，不是吗？ 记住规则#1 - 一切都是一个字符串。 关键是：通常许多这些参数都在 {curly-braces} 中 - 因此里面的变量直到以后才被扩展或替换。 </p>
<p>请记住，每个 Tcl 命令看起来都像 C 中经典的“main(argc, argv)”函数。在 JimTCL 中 - 它们实际上是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">MyCommand</span><span class="params">( Jim_Interp *interp, <span class="keyword">int</span> *argc, Jim_Obj * <span class="keyword">const</span> *argvs )</span></span>;</span><br></pre></td></tr></table></figure>

<p>真正的 Tcl 几乎相同。 虽然较新的版本引入了字节码解析器和解释器，但在核心上，它仍然以相同的基本方式运行。</p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022114026054.png" alt="image-20211022114026054"></p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022114119993-16348741421791.png" alt="image-20211022114119993"></p>
<h6 id="FOR-命令执行"><a href="#FOR-命令执行" class="headerlink" title="FOR 命令执行"></a><strong>FOR 命令执行</strong></h6><p>要理解 Tcl，查看 FOR 命令可能是最有帮助的。记住，它是一个 COMMAND 而不是一个控制流结构。</p>
<p>在 Tcl 中有两个底层的 c 辅助函数。</p>
<p>记住规则 # 1-你是一个字符串。</p>
<p><strong>第一个</strong>助手解析和执行在 ascii 字符串中找到的命令。命令可以用分号或换行符分隔。在解析时，通过引用规则扩展变量。</p>
<p><strong>第二个</strong>助手将ascii字符串作为数值表达式进行求值，并返回一个值。</p>
<p>下面是如何实现FOR命令的示例。下面的伪代码不显示错误处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Execute_AsciiString</span><span class="params">( <span class="keyword">void</span> *interp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span> )</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Evaluate_AsciiExpression</span><span class="params">( <span class="keyword">void</span> *interp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span> )</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyForCommand</span><span class="params">( <span class="keyword">void</span> *interp, <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( argc != <span class="number">5</span> )&#123; SetResult( interp, <span class="string">&quot;WRONG number of parameters&quot;</span>); </span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// argv[0] = the ascii string just like C</span></span><br><span class="line">	<span class="comment">// Execute the start statement. </span></span><br><span class="line">	Execute_AsciiString( interp, argv[<span class="number">1</span>] );</span><br><span class="line">	<span class="comment">// Top of loop test </span></span><br><span class="line">	<span class="keyword">for</span>(;;)&#123; </span><br><span class="line">    	i = Evaluate_AsciiExpression(interp, argv[<span class="number">2</span>]); </span><br><span class="line">    	<span class="keyword">if</span>( i == <span class="number">0</span> ) </span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// Execute the body </span></span><br><span class="line">    	Execute_AsciiString( interp, argv[<span class="number">3</span>] );</span><br><span class="line">		<span class="comment">// Execute the LOOP part </span></span><br><span class="line">    	Execute_AsciiString( interp, argv[<span class="number">4</span>] );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Return no error </span></span><br><span class="line">    SetResult( interp, <span class="string">&quot;&quot;</span> ); </span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有其他命令 IF、 WHILE、 FORMAT、 PUTS、 EXPR 都以相同的基本方式工作。</p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022115019117.png" alt="image-20211022115019117"></p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022115031609.png" alt="image-20211022115031609"></p>
<h5 id="OpenOCD-Tcl的使用"><a href="#OpenOCD-Tcl的使用" class="headerlink" title="OpenOCD Tcl的使用"></a><strong>OpenOCD Tcl的使用</strong></h5><h6 id="23-6-1源和查找命令"><a href="#23-6-1源和查找命令" class="headerlink" title="23.6.1源和查找命令"></a><strong>23.6.1源和查找命令</strong></h6><p>哪里：在许多配置文件中</p>
<p>示例：source [find FILENAME] </p>
<p>记住解析规则 </p>
<ol>
<li><p><strong>find</strong> 命令在方括号中，执行时带参数FILENAME。 它应该找到并返回具有该名称的文件的完整路径； 它使用内部搜索路径。 RESULT 是一个字符串，它被替换到命令行中以代替括号中的 <strong>find</strong> 命令。 （不要尝试使用包含“#”字符的 FILENAME。该字符开始 Tcl 注释。）</p>
</li>
<li><p>使用生成的文件名执行source命令； 它读取文件并作为脚本执行。</p>
</li>
</ol>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022120221601.png" alt="image-20211022120221601"></p>
<h6 id="格式化命令"><a href="#格式化命令" class="headerlink" title="格式化命令"></a><strong>格式化命令</strong></h6><p>哪里：一般发生在很多地方。 </p>
<p>Tcl 没有像 <strong>printf()</strong> 这样的命令，而是有<strong>format</strong>，这实际上更像 **sprintf()**。 </p>
<p>例子:</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> x <span class="number">6</span> </span><br><span class="line"><span class="keyword">set</span> y <span class="number">7</span> </span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">format</span> <span class="string">&quot;The answer: %d&quot;</span> [<span class="keyword">expr</span> <span class="variable">$x</span> * <span class="variable">$y</span>]]</span><br></pre></td></tr></table></figure>

<ol>
<li><p>SET 命令创建 2 个变量，X 和 Y。 </p>
</li>
<li><p>double [nested] EXPR 命令执行数学运算 </p>
<p>EXPR 命令产生字符串形式的数值结果。 </p>
<p>参考规则#1</p>
</li>
<li><p>执行格式命令，产生单个字符串 </p>
<p>参考规则#1。</p>
</li>
<li><p>PUTS 命令输出文本。</p>
</li>
</ol>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022120551494.png" alt="image-20211022120551494"></p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022120606033.png" alt="image-20211022120606033"></p>
<h6 id="正文或内联文本"><a href="#正文或内联文本" class="headerlink" title="正文或内联文本"></a><strong>正文或内联文本</strong></h6><p>哪里：各种 TARGET 脚本。</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1 Good </span></span><br><span class="line">    <span class="keyword">proc</span><span class="title"> someproc</span> &#123;&#125; &#123; </span><br><span class="line">        ... multiple lines of stuff ...</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="variable">$_TARGETNAME</span> configure -event FOO someproc</span><br><span class="line"><span class="comment">#2 Good - no variables </span></span><br><span class="line">    <span class="variable">$_TARGETNAME</span> configure -event foo <span class="string">&quot;this ; that;&quot;</span></span><br><span class="line"><span class="comment">#3 Good Curly Braces </span></span><br><span class="line">    <span class="variable">$_TARGETNAME</span> configure -event FOO &#123; </span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;Time: [date]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#4 DANGER DANGER DANGER </span></span><br><span class="line">	<span class="variable">$_TARGETNAME</span> configure -event foo <span class="string">&quot;puts \&quot;Time: [date]\&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>$TARGETNAME</code>是一个OpenOCD变量约定。<code>$TARGETNAME</code>表示上次创建的目标，每次值的修改都会创建一个新的目标。记住解析规则。 当解析 ascii 文本时，<code>$TARGETNAME</code> 变成一个简单的字符串，目标的名称恰好是一个 TARGET（对象）命令。</p>
</li>
<li><p>-event参数的第二个参数是<code>TCLBODY</code>。</p>
<p>有4个示例：</p>
<ol>
<li>TCLBODY是一个简单的字符串，恰好是一个proc名称</li>
<li>TCLBODY 是由分号分隔的几个简单命令</li>
<li>TCLBODY是一个多行{curly brace}带引号的字符串</li>
<li>TCLBODY是一个字符串，其中包含展开的变量。</li>
</ol>
<p>最后，当目标事件 FOO 发生时，将计算 TCLBODY。方法 # 1和 # 2在功能上是相同的。方法 # 3和 # 4更有趣。</p>
<p><em>什么是 TCLBODY？</em></p>
<p>记住解析规则。在案例#3中，{花括号}表示<code>$VARS</code>和[方括号]在事件发生后展开，并对文本进行求值。在第4种情况下，它们在执行“目标对象命令”之前被替换。这在替换<code>$TARGETNAME</code>的同时发生。万一发生这种情况，日期永远不会改变。{BTW:[date]是一个糟糕的例子；在本文中，Jim/OpenOCD没有date命令}</p>
</li>
</ol>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022121645056.png" alt="image-20211022121645056"></p>
<h6 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a><strong>全局变量</strong></h6><p>哪里: 在编写自己的 PROC 时，您可能会发现这一点</p>
<p>简而言之，在 PROC 中，如果您需要访问全局变量，您必须这样说。参见“ upvar”。例子:</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">proc</span><span class="title"> myproc</span> &#123; &#125; &#123; </span><br><span class="line">    <span class="keyword">set</span> y <span class="number">0</span> #Local <span class="keyword">variable</span> Y </span><br><span class="line">    <span class="keyword">global</span> x #Global <span class="keyword">variable</span> X </span><br><span class="line">    <span class="keyword">puts</span> [<span class="keyword">format</span> <span class="string">&quot;X=%d, Y=%d&quot;</span> <span class="variable">$x</span> <span class="variable">$y</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022132418269.png" alt="image-20211022132418269"></p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022132428486.png" alt="image-20211022132428486"></p>
<h5 id="其他-Tcl-技巧"><a href="#其他-Tcl-技巧" class="headerlink" title="其他 Tcl 技巧"></a><strong>其他 Tcl 技巧</strong></h5><p>动态变量创建</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dynamically create a bunch of variables. </span></span><br><span class="line"><span class="keyword">for</span> &#123; <span class="keyword">set</span> x <span class="number">0</span> &#125; &#123; <span class="variable">$x</span> &lt; <span class="number">32</span> &#125; &#123; <span class="keyword">set</span> x [<span class="keyword">expr</span> <span class="variable">$x</span> + <span class="number">1</span>]&#125; &#123; </span><br><span class="line"><span class="comment">    # Create var name </span></span><br><span class="line">    <span class="keyword">set</span> vn [<span class="keyword">format</span> <span class="string">&quot;BIT%d&quot;</span> <span class="variable">$x</span>] </span><br><span class="line"><span class="comment">    # Make it a global </span></span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$vn</span> </span><br><span class="line"><span class="comment">    # Set it. </span></span><br><span class="line">    <span class="keyword">set</span> <span class="variable">$vn</span> [<span class="keyword">expr</span> (<span class="number">1</span> &lt;&lt; <span class="variable">$x</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态过程/命令创建</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment"># One &quot;X&quot; function - 5 uart functions. </span></span><br><span class="line"><span class="keyword">foreach</span> who &#123;A B C D E&#125;</span><br><span class="line">	<span class="keyword">proc</span> [format &quot;show_uart%c&quot; $who] &#123; &#125; <span class="string">&quot;show_UARTx $who&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="参考代码解析"><a href="#参考代码解析" class="headerlink" title="参考代码解析"></a>参考代码解析</h4><p>阅读过了Tcl速成章节，再结合已知的知识，参考代码的很多部分都可以看懂了。</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选择调试器接口脚本为stlink.cfg</span></span><br><span class="line"><span class="keyword">source</span> [find interface/stlink.cfg]</span><br><span class="line"><span class="comment">#选择接口为hla_swd</span></span><br><span class="line">transport select hla_swd</span><br><span class="line"><span class="comment">#将QUADSPI标志位置位以便stm32l4x.cfg文件中使用</span></span><br><span class="line"><span class="keyword">set</span> QUADSPI <span class="number">1</span></span><br><span class="line"><span class="comment">#选择目标芯片脚本为stm32l4x.cfg</span></span><br><span class="line"><span class="keyword">source</span> [find target/stm32l4x.cfg]</span><br></pre></td></tr></table></figure>

<p>下面的代码定义了一个名为qspi_init的函数，虽然名字上面很明显的说明了是用于QSPI的初始化，不过要想搞懂里面干了什么还需要一点其他的内容配合：<strong>ST寄存器边界地址表</strong>、<strong>寄存器地图</strong>以及<strong>IO复用表</strong></p>
<p>RCC：</p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022170714824.png" alt="image-20211022170714824"></p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022170756020.png" alt="image-20211022170756020"></p>
<p>GPIOE：</p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022170935958.png" alt="image-20211022170935958"></p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022171003635.png" alt="image-20211022171003635"></p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022171030222.png" alt="image-20211022171030222"></p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022171057865.png" alt="image-20211022171057865"></p>
<p>QUADSPI：</p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022172639014.png" alt="image-20211022172639014"></p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022172735645.png" alt="image-20211022172735645"></p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022172758210.png" alt="image-20211022172758210"></p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022172853316.png" alt="image-20211022172853316"></p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211022172820659.png" alt="image-20211022172820659"></p>
<p>PORTE的IO复用表：</p>
<p><img src="/images/ExternalFlash%E7%BC%9D%E5%90%88%E8%AE%B0/image-20211023105744359.png" alt="image-20211023105744359"></p>
<blockquote>
<p><strong>一些目标指令</strong></p>
<p>mdd,mdw,mdh,mdb:</p>
<p>memory display <strong>doublewords</strong>(64bit)/<strong>words</strong>(32bit)/<strong>halfwords</strong>(16bit)/<strong>bytes</strong>(8bit)</p>
<p>mwd,mww,mwh,mwb:</p>
<p>memory write <strong>doublewords</strong>(64bit)/<strong>words</strong>(32bit)/<strong>halfwords</strong>(16bit)/<strong>bytes</strong>(8bit)</p>
<p>两类指令的格式都是：</p>
<p>mdd [phys] addr [count]</p>
<p>mrw,mmw:</p>
<p>memory <strong>read</strong>/<strong>modify</strong> word</p>
<p>指令格式：</p>
<p>mrw/mmw reg setbits clearbits</p>
</blockquote>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">proc</span><span class="title"> qspi_init</span> &#123; &#125; &#123;</span><br><span class="line"><span class="comment">	#定义全局变量a(没看出来有啥用</span></span><br><span class="line">	<span class="keyword">global</span> a</span><br><span class="line"><span class="comment">	#将RCC_AHB2ENR的低9位置位</span></span><br><span class="line"><span class="comment">	#使能GPIOA到GPIOI的时钟</span></span><br><span class="line">	mmw <span class="number">0x4002104C</span> <span class="number">0x000001FF</span> <span class="number">0</span></span><br><span class="line"><span class="comment">	#将RCC_AHB3ENR的QSPIEN位置位</span></span><br><span class="line"><span class="comment">	#使能QSPI时钟</span></span><br><span class="line">	mmw <span class="number">0x40021050</span> <span class="number">0x00000100</span> <span class="number">0</span></span><br><span class="line"><span class="comment">	#等待时钟开启</span></span><br><span class="line">	sleep <span class="number">1</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">	#将GPIOE_MODER寄存器的高12位隔位置位</span></span><br><span class="line"><span class="comment">	#将PIN10-15设置为模式10: Alternate function mode</span></span><br><span class="line">	mmw <span class="number">0x48001000</span> <span class="number">0xAAA00000</span> <span class="number">0x55500000</span></span><br><span class="line"><span class="comment">	#将GPIOE_OSPEED寄存器的高12位置位</span></span><br><span class="line"><span class="comment">	#将PIN10-15设置为速度等级11: Very high speed</span></span><br><span class="line">	mmw <span class="number">0x48001008</span> <span class="number">0xFFF00000</span> <span class="number">0x00000000</span></span><br><span class="line"><span class="comment">	#将GPIOx_AFRH寄存器的高24位隔位置位</span></span><br><span class="line"><span class="comment">	#将PIN10-15设置为AF10</span></span><br><span class="line">	mmw <span class="number">0x48001024</span> <span class="number">0xAAAAAA00</span> <span class="number">0x55555500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">	#将QUADSPI_LPTR寄存器的第15位置位</span></span><br><span class="line"><span class="comment">	#指示FIFO满后QUADSPI等待4096个时钟周期</span></span><br><span class="line">	mww <span class="number">0xA0001030</span> <span class="number">0x00001000</span></span><br><span class="line"><span class="comment">	#将QUADSPI_CR寄存器的PSC=1，APMS、TOIE、TCEN位置位</span></span><br><span class="line"><span class="comment">	#Qspi时钟2分频、出现匹配项时自动轮询停止、使能超时中断、使能超时计数器</span></span><br><span class="line">	mww <span class="number">0xA0001000</span> <span class="number">0x01500008</span></span><br><span class="line"><span class="comment">	#设置QUADSPI_DCR寄存器的FSIZE位与CSHT位</span></span><br><span class="line"><span class="comment">	#FLASH大小为16M，片选引脚拉高2个时钟周期，SPImode0</span></span><br><span class="line">	mww <span class="number">0xA0001004</span> <span class="number">0x00170100</span></span><br><span class="line"><span class="comment">	#将QUADSPI_CR寄存器的最低位置位</span></span><br><span class="line"><span class="comment">	#使能QSPI</span></span><br><span class="line">	mmw <span class="number">0xA0001000</span> <span class="number">0x00000001</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">	#设置QUADSPI_CCR寄存器:FMODE0b11、DMODE0b01、ADSIZE0b10、</span></span><br><span class="line"><span class="comment">	#ADMODE0b01、IMODE0b01、INSTRUCTION0b00000011</span></span><br><span class="line"><span class="comment">	#内存映射模式、单行数据、24位地址、</span></span><br><span class="line"><span class="comment">	#单行地址、单行指令、发送指令READ</span></span><br><span class="line">	mww <span class="number">0xA0001014</span> <span class="number">0x0D002503</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来再来看看最后的复位初始化干了什么：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_TARGETNAME</span> configure -event reset-init &#123;</span><br><span class="line"><span class="comment">	#设置FLASH_ACR的LATENCY为0b100</span></span><br><span class="line"><span class="comment">	#HCLK与FLASH之间等待4个状态</span></span><br><span class="line">	mmw <span class="number">0x40022000</span> <span class="number">0x00000004</span> <span class="number">0x00000003</span></span><br><span class="line"><span class="comment">	#等待设置生效</span></span><br><span class="line">	sleep <span class="number">1</span></span><br><span class="line"><span class="comment">	#将RCC_CR的HSION位置位</span></span><br><span class="line"><span class="comment">	#使能外部高速晶振</span></span><br><span class="line">	mmw <span class="number">0x40021000</span> <span class="number">0x00000100</span> <span class="number">0x00000000</span></span><br><span class="line"><span class="comment">	#设置RCC_PLLCFGR寄存器：PLLEN置位、PLLN0b0100100\</span></span><br><span class="line"><span class="comment">	#PLLM0b011、PLLSRC0b10-&gt;72MHz</span></span><br><span class="line"><span class="comment">	#PLLSAI3CLK输出使能、锁相倍频因子36、主PLL分频4、高速内部时钟源：PLL</span></span><br><span class="line">	mww <span class="number">0x4002100C</span> <span class="number">0x01002432</span></span><br><span class="line"><span class="comment">	#设置RCC_CFGR寄存器：STOPWUCK置位、SW0b01</span></span><br><span class="line"><span class="comment">	#HSI16振荡器选择为从停止时钟和CSS备份时钟唤醒</span></span><br><span class="line"><span class="comment">	#HSI16作为系统时钟</span></span><br><span class="line">	mww <span class="number">0x40021008</span> <span class="number">0x00008001</span></span><br><span class="line"><span class="comment">	#将RCC_CR的PLLON位置位</span></span><br><span class="line"><span class="comment">	#使能主锁相环</span></span><br><span class="line">	mmw <span class="number">0x40021000</span> <span class="number">0x01000000</span> <span class="number">0x00000000</span></span><br><span class="line"><span class="comment">	#等待设置生效</span></span><br><span class="line">	sleep <span class="number">1</span></span><br><span class="line"><span class="comment">	#设置RCC_CFGR寄存器：SW0b11</span></span><br><span class="line"><span class="comment">	#锁相环作为系统时钟</span></span><br><span class="line">	mmw <span class="number">0x40021008</span> <span class="number">0x00000003</span> <span class="number">0x00000000</span></span><br><span class="line"><span class="comment">	#等待设置生效</span></span><br><span class="line">	sleep <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">	#设置仿真器频率</span></span><br><span class="line">	adapter speed <span class="number">4000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">	#调用QSPI初始化函数</span></span><br><span class="line">	qspi_init</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类比参考代码自行撰写"><a href="#类比参考代码自行撰写" class="headerlink" title="类比参考代码自行撰写"></a>类比参考代码自行撰写</h4><p>全部看懂了之后，笔者开始模仿这段程序来撰写<strong>QSPI初始化</strong>函数和<strong>复位初始化</strong>函数：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span> [find interface/jlink.cfg]</span><br><span class="line"></span><br><span class="line">transport select swd</span><br><span class="line"></span><br><span class="line"><span class="comment"># increase working area to 96KB</span></span><br><span class="line"><span class="keyword">set</span> WORKAREASIZE <span class="number">0x18000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># enable stmqspi</span></span><br><span class="line"><span class="keyword">set</span> QUADSPI <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">source</span> [find target/stm32h7x.cfg]</span><br><span class="line"></span><br><span class="line"><span class="comment"># QUADSPI initialization</span></span><br><span class="line"><span class="keyword">proc</span><span class="title"> qspi_init</span> &#123; &#125; &#123;</span><br><span class="line">	<span class="keyword">global</span> a</span><br><span class="line"><span class="comment">    #RCC_AHB4ENR GPIOA-GPIOK</span></span><br><span class="line">	mmw <span class="number">0x580244E0</span> <span class="number">0x000007FF</span> <span class="number">0</span></span><br><span class="line"><span class="comment">    #RCC_AHB3ENR QSPI</span></span><br><span class="line">	mmw <span class="number">0x580244D4</span> <span class="number">0x00004000</span> <span class="number">0</span></span><br><span class="line"><span class="comment">    #等待</span></span><br><span class="line">	sleep <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">    #PB3-AF9 PB6-AF10 PD11-AF9 PD12-AF9 PD13-AF9</span></span><br><span class="line"><span class="comment">    #PE2-AF9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">	#GPIO模式设置</span></span><br><span class="line">	mmw <span class="number">0x58020400</span> <span class="number">0x00002080</span> <span class="number">0x00001040</span></span><br><span class="line">	mmw <span class="number">0x58020C00</span> <span class="number">0x0A800000</span> <span class="number">0x05400000</span></span><br><span class="line">	mmw <span class="number">0x58021000</span> <span class="number">0x00000020</span> <span class="number">0x00000010</span></span><br><span class="line"><span class="comment">	#GPIO输出速度</span></span><br><span class="line">	mmw <span class="number">0x58020408</span> <span class="number">0x000030C0</span> <span class="number">0x00000000</span></span><br><span class="line">	mmw <span class="number">0x58020C08</span> <span class="number">0x0FC00000</span> <span class="number">0x00000000</span></span><br><span class="line">	mmw <span class="number">0x58021000</span> <span class="number">0x00000030</span> <span class="number">0x00000000</span></span><br><span class="line"><span class="comment">	#GPIO复用功能</span></span><br><span class="line">	mmw <span class="number">0x58020420</span> <span class="number">0x0A009000</span> <span class="number">0x05006000</span></span><br><span class="line">	mmw <span class="number">0x58020C24</span> <span class="number">0x00999000</span> <span class="number">0x00666000</span></span><br><span class="line">	mmw <span class="number">0x58021020</span> <span class="number">0x00000900</span> <span class="number">0x00000600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">	#QSPI</span></span><br><span class="line">	mww <span class="number">0x52005030</span> <span class="number">0x00001000</span></span><br><span class="line">	mww <span class="number">0x52005000</span> <span class="number">0x01500008</span></span><br><span class="line">	mww <span class="number">0x52005004</span> <span class="number">0x00170100</span></span><br><span class="line">	mmw <span class="number">0x52005000</span> <span class="number">0x00000001</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	mww <span class="number">0x52005014</span> <span class="number">0x0D002503</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_TARGETNAME</span> configure -event reset-init &#123;</span><br><span class="line">	mmw <span class="number">0x40022000</span> <span class="number">0x00000004</span> <span class="number">0x00000003</span></span><br><span class="line">	sleep <span class="number">1</span></span><br><span class="line"><span class="comment">	#CR</span></span><br><span class="line">	mmw <span class="number">0x58024400</span> <span class="number">0x00000001</span> <span class="number">0x00000000</span></span><br><span class="line"><span class="comment">	#PLLCFGR</span></span><br><span class="line">	mww <span class="number">0x5802442c</span> <span class="number">0x01FF0009</span></span><br><span class="line"><span class="comment">	#CFGR</span></span><br><span class="line">	mww <span class="number">0x58024410</span> <span class="number">0x00000019</span></span><br><span class="line"><span class="comment">	#CR enPLLON</span></span><br><span class="line">	mmw <span class="number">0x58024400</span> <span class="number">0x01000000</span> <span class="number">0x00000000</span></span><br><span class="line">	sleep <span class="number">1</span></span><br><span class="line"><span class="comment">	#CFGR</span></span><br><span class="line">	mmw <span class="number">0x58024410</span> <span class="number">0x0000001B</span> <span class="number">0x00000000</span></span><br><span class="line">	sleep <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	adapter speed <span class="number">2000</span></span><br><span class="line"></span><br><span class="line">	qspi_init</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改链接脚本"><a href="#修改链接脚本" class="headerlink" title="修改链接脚本"></a>修改链接脚本</h3><h4 id="链接脚本介绍"><a href="#链接脚本介绍" class="headerlink" title="链接脚本介绍"></a>链接脚本介绍</h4>]]></content>
      <categories>
        <category>问题随记</category>
      </categories>
      <tags>
        <tag>问题随记</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP432学习笔记</title>
    <url>/2021/a441f005e981/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于积分赛限制了控制器，因此不能使用我们熟悉的STM32来进行开发，所以选择了MSP432作为控制器，并且也将从头学习一下MSP432。</p>
<blockquote>
<p>附完成的工程地址：</p>
<p><a href="https://wws.lanzoui.com/iseTCpmf4kb">https://wws.lanzoui.com/iseTCpmf4kb</a> </p>
</blockquote>
<span id="more"></span>

<p>这里是后期的我自己，文章的正文是在学习过程中随着进度一点一点写出来的，现在作品完成的接近尾声了，但是我觉得自己的了解并不够多，先说说自己的感受吧。</p>
<p>首先最大的感受就是使用TI的SDK库函数的时候的陌生感。这里就不得不对比一下HAL库和SDK了：</p>
<p>首先HAL给人最直观的感受就是封装度高，更适合新手上手，上手起来也很快。但是这也同样是HAL库的缺点。</p>
<p>在使用HAL库的时候，让人真的觉得就是在“使用”。因为你不知道里面干了什么，怎么干的，HAL的封装在你的面前就是一个巨大的黑盒子，使用的时候他在刻意的引导着我们让我们只关心“能用就行”，却忽略了背后的一些机制和原理。这不是HAL的问题，HAL的初心就是让程序员能脱离在机械化的初始化中浪费的时间，但是有一个巨大的前提—-这个程序员懂得其中的原理。而向我们这样的新手在用的时候就真的只会关心“能用就行”。</p>
<p>SDK则不一样，很多东西在不摸懂其中的原理之前是没办法调通的，这就逼迫着你去不断地翻阅参考手册、翻阅库函数手册、查资料等等，无形中增加了学习的深度以及对于原理的理解。</p>
<p>懂得不多，感受大概就这些，下面是正文。 </p>
<h2 id="系统时钟树以及滴答时钟"><a href="#系统时钟树以及滴答时钟" class="headerlink" title="系统时钟树以及滴答时钟"></a>系统时钟树以及滴答时钟</h2><h3 id="System-Timer-SysTick-—-系统滴答时钟"><a href="#System-Timer-SysTick-—-系统滴答时钟" class="headerlink" title="System Timer (SysTick)—-系统滴答时钟"></a>System Timer (SysTick)—-系统滴答时钟</h3><blockquote>
<p><strong>需要知道的内容：</strong></p>
<ul>
<li><p>Systick内部含有一个24位计数器，计数器最大值为1&lt;&lt;24</p>
</li>
<li><p>Systick计数频率等于系统主频（MCLK）</p>
</li>
<li><p>Systick计数器的计数方式为递减计数</p>
</li>
<li><p>Systick共含有三个寄存器功能分别如下：</p>
<ul>
<li>SysTick Control and Status Register (STCSR): A control and status register to configure its clock,enable the counter, enable the SysTick interrupt, and determine counter status.</li>
</ul>
<p>（系统设置寄存器即SysTick-&gt;CTRL）</p>
<ul>
<li>SysTick Reload Value Register (STRVR): The reload value for the counter, used to provide the counter’s wrap value.</li>
</ul>
<p>（计数周期寄存器即SysTick-&gt;LOAD，LOAD值等于period-1）</p>
<ul>
<li>SysTick Current Value Register (STCVR): The current value of the counter.  </li>
</ul>
<p>（当前计数值寄存器即SysTick-&gt;VAL）</p>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暂停看门狗</span></span><br><span class="line">WDT_A_holdTimer( <span class="keyword">void</span> );</span><br><span class="line"><span class="comment">//使能浮点运算单元</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FPU_enableModule</span> <span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*常用Systick相关函数*/</span></span><br><span class="line"><span class="comment">//SysTick使失能函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_enableModule</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_disableModule</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//SysTick中断使失能函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_enableInterrupt</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_disableInterrupt</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//获取Counter周期、当前值函数</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">SysTick_getPeriod</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">SysTick_getValue</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//设定Counter周期函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_setPeriod</span> <span class="params">(<span class="keyword">uint32_t</span> period)</span></span>;</span><br><span class="line"><span class="comment">//注册注销SysTick中断向量函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_registerInterrupt</span> <span class="params">(<span class="keyword">void</span>(∗intHandler)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_unregisterInterrupt</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="系统时钟树"><a href="#系统时钟树" class="headerlink" title="系统时钟树"></a>系统时钟树</h3><blockquote>
<p>  <strong>需要知道的内容：</strong></p>
<p>  **clock resources（时钟源）:  **</p>
<p>  • LFXTCLK: <strong>Low-frequency oscillator</strong> (LFXT) that can be used either with low-frequency 32768-Hz watch crystals, standard crystals, resonators, or external clock sources in the 32-kHz or below range. When in bypass mode, LFXTCLK can be driven with an external square wave signal in the 32-kHz or below range.</p>
<p>  （ <strong>低频振荡器</strong>（LFXT）可以与32kHz或以下范围的低频32768-Hz手表晶体，标准晶体，谐振器或外部时钟源一起使用。 在旁路模式下，可以使用32kHz或更低范围内的外部方波信号来驱动LFXTCLK。 ）</p>
<p>  • HFXTCLK: **High-frequency oscillator **(HFXT) that can be used with standard crystals or resonators in the 1-MHz to 48-MHz range. When in bypass mode, HFXTCLK can be driven with an external square wave signal.</p>
<p>  （ <strong>高频振荡器</strong>（HFXT），可与1MHz至48MHz范围内的标准晶体或谐振器一起使用。 在旁路模式下，可以使用外部方波信号驱动HFXTCLK。 ）</p>
<p>  • DCOCLK: <strong>Internal digitally controlled oscillator</strong> (DCO) with programmable frequencies and 3-MHz frequency by default</p>
<p>  （ <strong>内部数控振荡器</strong>（DCO），默认情况下具有可编程频率和3 MHz频率 ）</p>
<p>  • VLOCLK: <strong>Internal very-low-power low-frequency oscillator</strong> (VLO) with 9.4-kHz typical frequency</p>
<p>  （ <strong>内部超低功耗低频振荡器</strong>（VLO），典型频率为9.4kHz ）</p>
<p>  • REFOCLK : <strong>Internal, low-power low-frequency oscillator</strong> (REFO) with selectable 32.768-kHz or 128-kHz typical frequencies</p>
<p>  （ <strong>内部低功耗低频振荡器</strong>（REFO），具有可选的32.768 kHz或128 kHz典型频率 ）</p>
<p>  • MODCLK: <strong>Internal low-power oscillator</strong> with 25-MHz typical frequency</p>
<p>  （ <strong>内部低功耗振荡器</strong>，典型频率为25MHz ）</p>
<p>  • SYSOSC: <strong>Internal oscillator</strong> with 5-MHz typical frequency  </p>
<p>  （ <strong>内部振荡器</strong>，具有5-MHz典型频率 ）</p>
<p>  <strong>system clock signals（时钟信号）:</strong>    </p>
<p>  •ACLK: <strong>Auxiliary clock</strong>. ACLK is software selectable as LFXTCLK, VLOCLK, or REFOCLK. ACLK can be divided by 1, 2, 4, 8, 16, 32, 64, or 128. ACLK is software selectable by individual peripheral modules. ACLK is restricted to maximum frequency of operation of 128 kHz.</p>
<p>  ( <strong>辅助时钟</strong>。 ACLK可通过软件选择为LFXTCLK，VLOCLK或REFOCLK。 ACLK可以除以1、2、4、8、16、32、64或128。ACLK是可由各个外围模块选择的软件。 ACLK的最大工作频率限制为128 kHz。 )</p>
<p>  • MCLK: <strong>Master clock</strong>. MCLK is software selectable as LFXTCLK, VLOCLK, REFOCLK, DCOCLK,MODCLK, or HFXTCLK. MCLK can be divided by 1, 2, 4, 8, 16, 32, 64, or 128. MCLK is used by the CPU and peripheral module interfaces, as well as, used directly by some peripheral modules.</p>
<p>  ( <strong>主时钟</strong>。 MCLK可通过软件选择为LFXTCLK，VLOCLK，REFOCLK，DCOCLK，MODCLK或HFXTCLK。 MCLK可以除以1、2、4、8、16、32、64或128。MCLK由CPU和外围模块接口使用，以及直接由某些外围模块使用。 )</p>
<p>  • HSMCLK: <strong>Subsystem master clock</strong>. HSMCLK is software selectable as LFXTCLK, VLOCLK,REFOCLK, DCOCLK, MODCLK, HFXTCLK. HSMCLK can be divided by 1, 2, 4, 8, 16, 32, 64, or 128.HSMCLK is software selectable by individual peripheral modules.</p>
<p>  ( <strong>子系统主时钟</strong>。 HSMCLK可以选择为LFXTCLK，VLOCLK，REFOCLK，DCOCLK，MODCLK，HFXTCLK。 HSMCLK可以被1、2、4、8、16、32、64或128分频。HSMCLK是可由各个外围模块选择的软件。 )</p>
<p>  • SMCLK: <strong>Low-speed subsystem master clock</strong>. SMCLK uses the HSMCLK clock resource selection for its clock resource. SMCLK can be divided independently from HSMCLK by 1, 2, 4, 8, 16, 32, 64, or 128. SMCLK is limited in frequency to half of the rated maximum frequency of HSMCLK. SMCLK is software selectable by individual peripheral modules.</p>
<p>  (<strong>低速子系统主时钟</strong>。 SMCLK将HSMCLK时钟资源选择用于其时钟资源。 可以将SMCLK与HSMCLK分别分频为1、2、4、8、16、32、64或128。SMCLK的频率限制为HSMCLK额定最大频率的一半。 SMCLK是可由各个外围模块选择的软件。)    </p>
<p>  • BCLK:<strong>Low-speed backup domain clock</strong>. BCLK is software selectable as LFXTCLK and REFOCLK and is used primarily in the backup domain. BCLK is restricted to a maximum frequency of 32.768 kHz.  </p>
<p>  ( <strong>低速备份域时钟</strong>。 BCLK是软件可选的LFXTCLK和REFOCLK，主要用于备份域。 BCLK的最大频率限制为32.768 kHz。 )<img src="/images/MSP432%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1622276050150.png" alt="1622276050150"></p>
</blockquote>
<p>上述为MSP432时钟系统介绍的截图，为了便于区分已经利用不同的颜色标出了不同的时钟总线。</p>
<p>根据上图可总结出如下时钟信号和时钟源的关系：</p>
<table>
<thead>
<tr>
<th align="center">时钟源\时钟信号</th>
<th align="center">ACLK</th>
<th align="center">MCLK</th>
<th align="center">HSMCLK</th>
<th align="center">SMCLK</th>
<th align="center">BCLK</th>
<th align="center">能否直接被其他外设使用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>LFXTCLK</strong></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><strong>VLO</strong></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">-</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><strong>REFO</strong></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><strong>DCOCLK</strong></td>
<td align="center">-</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><strong>MODOSC</strong></td>
<td align="center">-</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">-</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><strong>HFXTCLK</strong></td>
<td align="center">-</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><strong>SYSOSC</strong></td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h3 id="常用系统时钟函数"><a href="#常用系统时钟函数" class="headerlink" title="常用系统时钟函数"></a>常用系统时钟函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*常用时钟树相关函数*/</span></span><br><span class="line"><span class="comment">//获取各种外部时钟源的频率（用于调试时钟树很方便）</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">CS_getACLK</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">CS_getBCLK</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">CS_getHSMCLK</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">CS_getMCLK</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">CS_getSMCLK</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//时钟信号初始化（用于设置时钟分频）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CS_initClockSignal</span><span class="params">(<span class="keyword">uint32_t</span> selectedClockSignal, <span class="keyword">uint32_t</span> clockSource, <span class="keyword">uint32_t</span> clockSourceDivider)</span></span>;</span><br><span class="line"><span class="comment">//设置DCOCLK频率范围中心（简单确定DCOCLK频率范围，后面需要加上一个频率设置函数确定具体频率）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CS_setDCOCenteredFrequency</span> <span class="params">(<span class="keyword">uint32_t</span> dcoFreq)</span></span>;</span><br><span class="line"><span class="comment">//设置DCOCLK频率值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CS_setDCOFrequency</span> <span class="params">(<span class="keyword">uint32_t</span> dcoFrequency)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="Digital-I-O（数字输入输出）"><a href="#Digital-I-O（数字输入输出）" class="headerlink" title="Digital I/O（数字输入输出）"></a>Digital I/O（数字输入输出）</h2><h3 id="Digital-I-O介绍"><a href="#Digital-I-O介绍" class="headerlink" title="Digital I/O介绍"></a>Digital I/O介绍</h3><p>虽然名字不同，但是和STM中的GPIO几乎完全相同。</p>
<p>甚至在DriverLib库的手册中直接用了GPIO的写法<del>（诶，我们不装了，摊牌了，就是一样的！）</del></p>
<p>不过有一点值得注意的是一个叫做外设GPIO的东西，它其实和GPIO完全不是一个东西。通俗的讲其实它是为其他的需要引脚来进行输入输出的外设选择了其需要的引脚并配置为相应的模式。例如IIC、SPI、PWM等等。</p>
<p>正是因此所以前面我说的内容其实并不严谨。应该是说：在<strong>通用输入输出功能</strong>上，他们虽然名字不同，但是和STM中的GPIO几乎完全相同。</p>
<p>但是仔细想一下，这两个手册中表现出的理解似乎并不一样：GPIO更像是<strong>功能性的叙述</strong>，说明该功能为通用输入输出；Digital I/O更像是<strong>硬件上的描述</strong>，只要是需要进行“数字输入输出“的功能都需要用到Digital I/O。</p>
<p>至于DriverLib中的相关函数，我对它们的评价是：通俗易懂。</p>
<p>真的就通俗易懂到只要翻译一下名字就知道是干什么的程度。</p>
<h3 id="常用GPIO函数汇总"><a href="#常用GPIO函数汇总" class="headerlink" title="常用GPIO函数汇总"></a>常用GPIO函数汇总</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GPIO模式设置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_setAsOutputPin</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort,<span class="keyword">uint_fast16_t</span> selectedPins)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_setAsInputPin</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span> selectedPins)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_setAsInputPinWithPullDownResistor</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">uint_fast16_t</span> selectedPins)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_setAsInputPinWithPullUpResistor</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">uint_fast16_t</span> selectedPins)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外设GPIO设置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_setAsPeripheralModuleFunctionInputPin</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort,<span class="keyword">uint_fast16_t</span> selectedPins,<span class="keyword">uint_fast8_t</span> mode)</span></span>;<span class="comment">//模式参数：GPIO_PRIMARY_MODULE_FUNCTION/GPIO_SECONDARY_MODULE_FUNCTION/GPIO_TERTIARY_MODULE_FUNCTION</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_setAsPeripheralModuleFunctionOutputPin</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort,<span class="keyword">uint_fast16_t</span> selectedPins,<span class="keyword">uint_fast8_t</span> mode)</span></span>;<span class="comment">//模式参数：GPIO_PRIMARY_MODULE_FUNCTION/GPIO_SECONDARY_MODULE_FUNCTION/GPIO_TERTIARY_MODULE_FUNCTION</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO输出设置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_setOutputHighOnPin</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">selectedPins)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_setOutputLowOnPin</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">selectedPins)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_toggleOutputOnPin</span><span class="params">(<span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">selectedPins)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO输入读取</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">GPIO_getInputPinValue</span> <span class="params">( <span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">selectedPins )</span></span>;<span class="comment">//返回：GPIO_INPUT_PIN_HIGH/GPIO_INPUT_PIN_LOW</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//GPIO中断设置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_clearInterruptFlag</span> <span class="params">( <span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">selectedPins )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_disableInterrupt</span> <span class="params">( <span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">selectedPins )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_enableInterrupt</span> <span class="params">( <span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">selectedPins )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_interruptEdgeSelect</span> <span class="params">( <span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">uint_fast16_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">selectedPins, <span class="keyword">uint_fast8_t</span> edgeSelect )</span></span>;<span class="comment">//模式参数：GPIO_HIGH_TO_LOW_TRANSITION/GPIO_LOW_TO_HIGH_TRANSITION</span></span><br><span class="line"><span class="function"><span class="keyword">uint_fast16_t</span> <span class="title">GPIO_getEnabledInterruptStatus</span> <span class="params">( <span class="keyword">uint_fast8_t</span> selectedPort )</span></span>;<span class="comment">//返回端口引脚的逻辑或结果</span></span><br><span class="line"><span class="comment">//中断向量处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_registerInterrupt</span> <span class="params">( <span class="keyword">uint_fast8_t</span> selectedPort, <span class="keyword">void</span>(∗)(<span class="keyword">void</span>) intHandler )</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_unregisterInterrupt</span> <span class="params">( <span class="keyword">uint_fast8_t</span> selectedPort )</span></span>;<span class="comment">//注销中断向量</span></span><br></pre></td></tr></table></figure>

<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="定时器介绍"><a href="#定时器介绍" class="headerlink" title="定时器介绍"></a>定时器介绍</h3><p>我认为MSP432与ST的定时器区别最大的地方在于它将32位定时器和16位定时器分开来，将PWM的功能仅仅赋予16位定时器。</p>
<p>本次比赛并未用到过32位定时器，因此我也不好多说，此处介绍我们用到的16位定时器的部分功能。</p>
<blockquote>
<p><strong>需要知道的东西：</strong></p>
<ul>
<li>定时器模块图：</li>
</ul>
<p><img src="/images/MSP432%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1622468114640.png" alt="1622468114640"></p>
<ul>
<li><p>UPMODE是从0计数到CCR0</p>
</li>
<li><p>UPDOWNMODE是先递增计数到CCR0再递减计数到0，其中CCR0=period*1/2</p>
</li>
<li><p>CONTINOUSMODE是从0计数到0xFFFF</p>
</li>
<li><p>定时器中并没有影子寄存器的说法，但是其实官方默认是具有类似ST中影子寄存器的功能的：</p>
<ul>
<li>UPMODE中的说明：</li>
</ul>
</li>
</ul>
<p> <img src="/images/MSP432%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1622467994167.png" alt="1622467994167"></p>
<ul>
<li>UPDOWNMODE中的说明：</li>
</ul>
<p> <img src="/images/MSP432%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1622468221716.png" alt="1622468221716"></p>
</blockquote>
<h3 id="定时器函数"><a href="#定时器函数" class="headerlink" title="定时器函数"></a>定时器函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*相关结构体*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Timer_A_ContinuousModeConfig</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockSource;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockSourceDivider;</span><br><span class="line">    <span class="comment">//注意：此处的分频是指在主频经过分频后得到的对应时钟频率的基础上进行分频</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerInterruptEnable_TAIE;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerClear;</span><br><span class="line">&#125; Timer_A_ContinuousModeConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Timer_A_UpDownModeConfig</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockSource;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockSourceDivider;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerPeriod;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerInterruptEnable_TAIE;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> captureCompareInterruptEnable_CCR0_CCIE;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerClear;</span><br><span class="line">&#125; Timer_A_UpDownModeConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Timer_A_UpModeConfig</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockSource;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockSourceDivider;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerPeriod;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerInterruptEnable_TAIE;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> captureCompareInterruptEnable_CCR0_CCIE;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerClear;</span><br><span class="line">&#125; Timer_A_UpModeConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Timer_A_PWMConfig</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockSource;</span><br><span class="line">    <span class="comment">//TIMER_A_CLOCKSOURCE_EXTERNAL_TXCLK</span></span><br><span class="line">    <span class="comment">//TIMER_A_CLOCKSOURCE_ACLK</span></span><br><span class="line">    <span class="comment">//TIMER_A_CLOCKSOURCE_SMCLK</span></span><br><span class="line">	<span class="comment">//TIMER_A_CLOCKSOURCE_INVERTED_EXTERNAL_TXCLK</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockSourceDivider;</span><br><span class="line">    <span class="comment">//TIMER_A_CLOCKSOURCE_DIVIDER_1，2，3，4，5，6，7，8，10，12，14</span></span><br><span class="line">    <span class="comment">//TIMER_A_CLOCKSOURCE_DIVIDER_16，20，24，28，32，40，48，56，64</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> timerPeriod;</span><br><span class="line">    <span class="comment">//selects the desired timer period</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> compareRegister;</span><br><span class="line">    <span class="comment">//TIMER_A_CAPTURECOMPARE_REGISTER_0，1，2，3，4，5，6</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> compareOutputMode;</span><br><span class="line">    <span class="comment">//TIMER_A_OUTPUTMODE_OUTBITVALUE,</span></span><br><span class="line">    <span class="comment">//TIMER_A_OUTPUTMODE_SET,</span></span><br><span class="line">    <span class="comment">//TIMER_A_OUTPUTMODE_TOGGLE_RESET,</span></span><br><span class="line">    <span class="comment">//TIMER_A_OUTPUTMODE_SET_RESET</span></span><br><span class="line">    <span class="comment">//TIMER_A_OUTPUTMODE_TOGGLE,</span></span><br><span class="line">    <span class="comment">//TIMER_A_OUTPUTMODE_RESET,</span></span><br><span class="line">    <span class="comment">//TIMER_A_OUTPUTMODE_TOGGLE_SET,</span></span><br><span class="line">    <span class="comment">//TIMER_A_OUTPUTMODE_RESET_SET</span></span><br><span class="line">    <span class="keyword">uint_fast16_t</span> dutyCycle;</span><br><span class="line">    <span class="comment">//specifies the dutycycle for the generated waveform</span></span><br><span class="line">&#125; Timer_A_PWMConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*相关函数*/</span></span><br><span class="line"><span class="comment">//三种计数模式配置函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_configureContinuousMode</span> <span class="params">(<span class="keyword">uint32_t</span> timer, <span class="keyword">const</span> Timer_A_ContinuousModeConfig ∗config)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_configureUpDownMode</span> <span class="params">(<span class="keyword">uint32_t</span> timer, <span class="keyword">const</span> Timer_A_UpDownModeConfig　∗config)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_configureUpMode</span> <span class="params">(<span class="keyword">uint32_t</span> timer, <span class="keyword">const</span> Timer_A_UpModeConfig ∗config)</span></span>;</span><br><span class="line"><span class="comment">//PWM相关函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_generatePWM</span> <span class="params">(<span class="keyword">uint32_t</span> timer, <span class="keyword">const</span> Timer_A_PWMConfig ∗config)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_setCompareValue</span> <span class="params">(<span class="keyword">uint32_t</span> timer, <span class="keyword">uint_fast16_t</span> compareRegister,<span class="keyword">uint_fast16_t</span> compareValue)</span></span>;</span><br><span class="line"><span class="comment">//中断相关函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_enableInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> timer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_disableInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> timer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_clearInterruptFlag</span> <span class="params">(<span class="keyword">uint32_t</span> timer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_registerInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> timer, <span class="keyword">uint_fast8_t</span> interruptSelect, <span class="keyword">void</span>(∗intHandler)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_A_unregisterInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> timer, <span class="keyword">uint_fast8_t</span> interruptSelect)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="系统中断（NVIC）"><a href="#系统中断（NVIC）" class="headerlink" title="系统中断（NVIC）"></a>系统中断（NVIC）</h2><h3 id="一点小小想法"><a href="#一点小小想法" class="headerlink" title="一点小小想法"></a>一点小小想法</h3><p><strong>PS:暂且将Interrupt开头的函数称为系统中断函数，而各个外设中的中断函数成为外设中断函数。</strong></p>
<p>学习中断函数的时候能感受到这个库的逻辑和HAL库最大的差别在于对中断向量的处理：</p>
<p>HAL库将中断处理函数全部写好了，给用户保留了中断回调函数作为接口，开机载入中断向量表的时候会将所有的中断处理函数都作为中断向量加载好，接着在中断处理函数中调用回调函数进而实现将用户代码加入中断中的目的。而SDK的中断向量表从一开始就是空的，用户需要自行编写中断处理函数，并且自行注册中断向量，进而实现发生中断时对中断内部代码的调用。</p>
<p>说简单点就是HAL库棒用户填好了中断向量表，而SDK则需要用户自行填写中断向量表，两种方式自然各有利弊。</p>
<p>HAL库最大的好处就是它简单，使用的时候很简单，只需要写一个回调函数就能完成中断内部函数的书写，对新手友好。但是我个人认为最大的缺点在于没有给新手一个好的引导，这也是我用了SDK的中断部分以后最大的感受：受益匪浅。这种函数的组织方式能让人更好的感受到有一个叫做“中断向量表”的东西一直在指引着程序，让程序知道发生了中断以后该执行什么函数。</p>
<h3 id="常用系统中断函数"><a href="#常用系统中断函数" class="headerlink" title="常用系统中断函数"></a>常用系统中断函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*中断相关函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Interrupt_disableInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> interruptNumber)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Interrupt_enableInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> interruptNumber)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Interrupt_registerInterrupt</span><span class="params">(<span class="keyword">uint32_t</span> interruptNumber,<span class="keyword">void</span> (*intHandler)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Interrupt_unregisterInterrupt</span><span class="params">(<span class="keyword">uint32_t</span> interruptNumber)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>使能某中断时必须<strong>同时调用</strong>外设中断使能函数和系统中断使能函数。</li>
<li>各个外设对应的注册中断向量函数其实内部调用了<strong>系统中断使能函数</strong>和<strong>系统注册中断向量函数</strong></li>
</ul>
</blockquote>
<h2 id="串口（UART）"><a href="#串口（UART）" class="headerlink" title="串口（UART）"></a>串口（UART）</h2><h3 id="串口介绍"><a href="#串口介绍" class="headerlink" title="串口介绍"></a>串口介绍</h3><p>其实串口没啥好介绍的，就是为了标题能整整齐齐所以写了这里。</p>
<p>其实还是看到了一些看起来很新奇的功能模块的，只不过还没用起来过，所以也不好说什么。</p>
<p>或许以后再次接触的时候会用到呢，这里留个坑吧。</p>
<blockquote>
<p><strong>看到的有趣功能：</strong></p>
<ul>
<li><p>Automatic Baud-Rate Detection （自动波特率检测？）</p>
</li>
<li><p>Automatic Error Detection  （自动错误侦测？）</p>
</li>
</ul>
</blockquote>
<h3 id="常用串口函数"><a href="#常用串口函数" class="headerlink" title="常用串口函数"></a>常用串口函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*串口配置结构体*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">eUSCI_eUSCI_UART_ConfigV1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint_fast8_t</span> selectClockSource;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> clockPrescalar;<span class="comment">//对应取值见设备用户指南（DEVICE USER GUIDE）</span></span><br><span class="line">    <span class="keyword">uint_fast8_t</span> firstModReg;	 <span class="comment">//对应取值见设备用户指南（DEVICE USER GUIDE）</span></span><br><span class="line">    <span class="keyword">uint_fast8_t</span> secondModReg;   <span class="comment">//对应取值见设备用户指南（DEVICE USER GUIDE）</span></span><br><span class="line">    <span class="keyword">uint_fast8_t</span> parity;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> msborLsbFirst;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> numberofStopBits;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> uartMode;</span><br><span class="line">    <span class="keyword">uint_fast8_t</span> overSampling;</span><br><span class="line">    <span class="keyword">uint_fast16_t</span> dataLength;</span><br><span class="line">&#125; eUSCI_UART_ConfigV1;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>结构体各部分定义及其取值：</strong></p>
<p><img src="/images/MSP432%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1622470501084.png" alt="1622470501084"></p>
<p><strong>关于上述结构体中注释的三个变量的取值方式：</strong></p>
<p>在USER GUID中查表可得对应取值：</p>
<p><img src="/images/MSP432%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1622472486950.png" alt="1622472486950"></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*串口函数*/</span></span><br><span class="line"><span class="comment">//使能、失能串口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_enableModule</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_disableModule</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance)</span></span>;</span><br><span class="line"><span class="comment">//初始化串口</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UART_initModule</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance, <span class="keyword">const</span> eUSCI_UART_ConfigV1 ∗config)</span></span>;</span><br><span class="line"><span class="comment">//串口收发数据（单字节形式）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_transmitData</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance, <span class="keyword">uint_fast8_t</span> transmitData)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">UART_receiveData</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance)</span></span>;</span><br><span class="line"><span class="comment">//使能、失能串口中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_enableInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance, <span class="keyword">uint_fast8_t</span> mask)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_disableInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance, <span class="keyword">uint_fast8_t</span> mask)</span></span>;</span><br><span class="line"><span class="comment">//清除中断标志位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_clearInterruptFlag</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance, <span class="keyword">uint_fast8_t</span> mask)</span></span>;</span><br><span class="line"><span class="comment">//注册、注销中断向量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_registerInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance, <span class="keyword">void</span>(∗intHandler)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_unregisterInterrupt</span> <span class="params">(<span class="keyword">uint32_t</span> moduleInstance)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>需要注意的内容：</strong></p>
<ul>
<li>UART_initModule()函数并不能使能串口，手册说明如下：</li>
</ul>
<p><img src="/images/MSP432%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1622471002332.png" alt="1622471002332"></p>
<ul>
<li>UART_receiveData()函数只有在没有使能串口中断的时候才会轮询中断标志位，也就是说会阻塞程序的运行；当使能中断后就不会再轮询标志位了（因为标志位的变化会引起串口中断，用户可以在中断中进行数据的处理）。</li>
<li>串口的中断接收没法进行断点式的调试，毕竟接收函数并没有轮询标志位，也就不会等着下一个字节数据的到来，信号在线路中传输是不会等待你下断点调试的。</li>
</ul>
</blockquote>
<h2 id="工程函数总结"><a href="#工程函数总结" class="headerlink" title="工程函数总结"></a>工程函数总结</h2><p>在使用的过程中，为了使用方便，我们将我们用到的函数进行了模块化的封装，对应文件内容如下：</p>
<p><strong>user.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZheWana on 2021/5/26.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UARTRetargetInit</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    GPIO_setAsPeripheralModuleFunctionInputPin(GPIO_PORT_P1, GPIO_PIN2 | GPIO_PIN3,</span><br><span class="line">                                               GPIO_PRIMARY_MODULE_FUNCTION);</span><br><span class="line">    <span class="keyword">const</span> eUSCI_UART_ConfigV1 uartConfig =</span><br><span class="line">            &#123;</span><br><span class="line">                    EUSCI_A_UART_CLOCKSOURCE_SMCLK,<span class="comment">//选择时钟源</span></span><br><span class="line">                    <span class="number">6</span>,							   <span class="comment">//In device guide:UCBRx</span></span><br><span class="line">                    <span class="number">8</span>,                             <span class="comment">//In device guide:UCBRFx</span></span><br><span class="line">                    <span class="number">0x11</span>,                          <span class="comment">//In device guide:UCBRSx</span></span><br><span class="line">                    EUSCI_A_UART_NO_PARITY,		   <span class="comment">//极性设置</span></span><br><span class="line">                    EUSCI_A_UART_LSB_FIRST,        <span class="comment">//设置高低位优先</span></span><br><span class="line">                    EUSCI_A_UART_ONE_STOP_BIT,	   <span class="comment">//停止位数</span></span><br><span class="line">                    EUSCI_A_UART_MODE,			   <span class="comment">//串口模式</span></span><br><span class="line">                    EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION,</span><br><span class="line">                    EUSCI_A_UART_8_BIT_LEN		   <span class="comment">//数据长度</span></span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="comment">//配置时钟源，其中SMCLK进行4分频</span></span><br><span class="line">    <span class="comment">//主频48000000</span></span><br><span class="line">    <span class="comment">//SMCLK为12000000</span></span><br><span class="line">    CS_setDCOCenteredFrequency(CS_DCO_FREQUENCY_48);</span><br><span class="line">    CS_setDCOFrequency(<span class="number">48000000</span>);</span><br><span class="line">    CS_initClockSignal(CS_SMCLK,CS_DCOCLK_SELECT,CS_CLOCK_DIVIDER_4);</span><br><span class="line">    <span class="comment">//串口模块初始化以及使能</span></span><br><span class="line">    UART_initModule(EUSCI_A0_BASE, &amp;uartConfig);</span><br><span class="line">    UART_enableModule(EUSCI_A0_BASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口重定向函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART_printf</span><span class="params">(<span class="keyword">uint32_t</span> moduleInstance, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    length = vsnprintf(buffer, <span class="number">128</span>, fmt, ap);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        UART_transmitData(moduleInstance, *(buffer + i));</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int32_t</span> CNT;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encoder_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> temp = GPIO_getInputPinValue(GPIO_PORT_P3, GPIO_PIN2);</span><br><span class="line">    <span class="keyword">uint32_t</span> status;</span><br><span class="line"></span><br><span class="line">    status = MAP_GPIO_getEnabledInterruptStatus(GPIO_PORT_P3);</span><br><span class="line">    MAP_GPIO_clearInterruptFlag(GPIO_PORT_P3, status);</span><br><span class="line">    <span class="keyword">if</span> (status &amp; GPIO_PIN3) &#123;</span><br><span class="line">        MAP_GPIO_toggleOutputOnPin(GPIO_PORT_P1, GPIO_PIN0);</span><br><span class="line">        <span class="keyword">if</span> (temp == GPIO_INPUT_PIN_HIGH) &#123;</span><br><span class="line">            CNT++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == GPIO_INPUT_PIN_LOW) &#123;</span><br><span class="line">            CNT--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EncoderInit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//GPIO模式设置</span></span><br><span class="line">    GPIO_setAsInputPinWithPullUpResistor(GPIO_PORT_P3, GPIO_PIN3);</span><br><span class="line">    GPIO_setAsInputPinWithPullUpResistor(GPIO_PORT_P3, GPIO_PIN2);</span><br><span class="line">    <span class="comment">//清除中断标志位</span></span><br><span class="line">    GPIO_clearInterruptFlag(GPIO_PORT_P3, GPIO_PIN3);</span><br><span class="line">    <span class="comment">//中断使能</span></span><br><span class="line">    GPIO_enableInterrupt(GPIO_PORT_P3, GPIO_PIN3);</span><br><span class="line">    <span class="comment">//中断触发边沿选择</span></span><br><span class="line">    GPIO_interruptEdgeSelect(GPIO_PORT_P3, GPIO_PIN3, GPIO_LOW_TO_HIGH_TRANSITION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中断使能以及中断向量注册</span></span><br><span class="line">    Interrupt_enableInterrupt(INT_PORT3);</span><br><span class="line">    Interrupt_enableMaster();</span><br><span class="line">    Interrupt_registerInterrupt(INT_PORT3, Encoder_IRQHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIMERA0_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    Timer_A_clearInterruptFlag(TIMER_A0_BASE);</span><br><span class="line">    <span class="comment">/********</span></span><br><span class="line"><span class="comment">    *处理函数*</span></span><br><span class="line"><span class="comment">    ********/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimerIntuerruptInit</span><span class="params">(<span class="keyword">double</span> period)</span></span>&#123;</span><br><span class="line">    Timer_A_UpModeConfig Timer=&#123;</span><br><span class="line">            TIMER_A_CLOCKSOURCE_ACLK,</span><br><span class="line">            TIMER_A_CLOCKSOURCE_DIVIDER_1,</span><br><span class="line">            (<span class="keyword">int</span>)(period/<span class="number">1000</span>*<span class="number">32000</span>),</span><br><span class="line">            TIMER_A_TAIE_INTERRUPT_ENABLE,</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    Timer_A_configureUpMode(TIMER_A0_BASE,&amp;Timer);</span><br><span class="line">    Timer_A_enableInterrupt(TIMER_A0_BASE);</span><br><span class="line">    Timer_A_clearInterruptFlag(TIMER_A0_BASE);</span><br><span class="line">    Interrupt_enableInterrupt(INT_TA0_N);</span><br><span class="line">    Interrupt_enableMaster();</span><br><span class="line">    Interrupt_registerInterrupt(INT_TA0_N, TIMERA0_IRQHandler);</span><br><span class="line">    Timer_A_startCounter(TIMER_A0_BASE, TIMER_A_UP_MODE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay_ms</span><span class="params">(<span class="keyword">int</span> freq, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">    SysTick_enableModule();</span><br><span class="line">    SysTick_setPeriod(<span class="number">1</span>&lt;&lt;<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    SysTick-&gt;VAL=<span class="number">1</span>&lt;&lt;<span class="number">24</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> a = SysTick_getValue();</span><br><span class="line">    <span class="keyword">while</span> ((a - SysTick_getValue()) &lt; freq / <span class="number">1000</span> * time);</span><br><span class="line">    SysTick_disableModule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> uartflag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">double</span> data, p, i, d, a;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    buff[cnt] = UART_receiveData(EUSCI_A0_BASE);</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">5</span>)cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>user.h</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZheWana on 2021/5/26.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEMPLATE_USER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEMPLATE_USER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ti/devices/msp432p4xx/driverlib/driverlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdarg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//串口重定向初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UARTRetargetInit</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//串口重定向输出函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART_printf</span><span class="params">(<span class="keyword">uint32_t</span> moduleInstance, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="comment">//定时器中断处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIMERA0_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//定时器中断初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimerIntuerruptInit</span><span class="params">(<span class="keyword">double</span> period)</span></span>;</span><br><span class="line"><span class="comment">//编码器初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EncoderInit</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//编码器对应IO中断处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encoder_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//毫秒延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay_ms</span><span class="params">(<span class="keyword">int</span> freq, <span class="keyword">int</span> time)</span></span>;</span><br><span class="line"><span class="comment">//串口中断回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//TEMPLATE_USER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>因为比赛原因所以学习的其实很仓促，所以很多东西理解的并不好，接下来会找时间系统的好好学习一下的。</p>
<p><strong>路漫漫其修远兮，吾将上下而求索。</strong></p>
]]></content>
      <categories>
        <category>单片机</category>
        <category>MSP432</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>MSP432</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Clion的STM32开发</title>
    <url>/2021/c69c321f18aa/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>前段时间刚刚从keil转到了VScode，正当我享受着VScode爽快的代码编辑的时候，被学长安利了Clion。</p>
<p>VScode的代码补全是很舒服的<del>（主要是keil衬托得好啊）</del>，但是真要调试、查看寄存器之类的功能却还是要打开keil，这导致我在搞工程的时候经常要打开VScode、打开CubeMX、打开Keil，这样的话反而背离了我们使用方便的初心，变得更麻烦了，而且VScode无法与CubeMX联动也是件让人伤心的事。</p>
<p>所有以上提到的问题，Clion都可以解决，而且还附带了GDB调试功能，让我们的调试更加<del>花里胡哨</del>高端大气、方便易用。</p>
<p>PS：以下内容均大部分参考自下面几位大佬的文章，但是文章中有一些问题并未涉及，于是我把没有涉及的部分加入进来融合为一篇文章，如果安装的过程中出现任何问题大家也可以看一下几位大佬的原文：</p>
<p><a href="https://www.bilibili.com/read/cv6308000">配置CLion用于STM32开发【优雅の嵌入式开发】</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/160183640">在CLion中开发STM32</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/288376187">CLion开发STM32（环境配置篇）</a> </p>
<span id="more"></span>

<hr>
<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="一、白嫖申请教育优惠"><a href="#一、白嫖申请教育优惠" class="headerlink" title="一、白嫖申请教育优惠"></a>一、<del>白嫖</del>申请教育优惠</h3><p>首先，Clion是JetBrains家的一款C/C++编辑器，正常的使用是要支付不菲的费用的，而且还不是买断制的，不过JetBrains推出了教育优惠，只要我们还是学生，就可以每年使用我们的教育邮箱申请一年的免费使用权限，<a href="https://www.jetbrains.com/shop/eform/students">传送门</a>在这。</p>
<p>填写完个人信息之后再打三个勾，申请一下即可（邮箱一定要用教育邮箱！如果你没有收到激活邮件请移步其他邮件的垃圾箱中查看，如果垃圾箱中也没有，请耐心等待。）</p>
<h3 id="二、下载和安装"><a href="#二、下载和安装" class="headerlink" title="二、下载和安装"></a>二、下载和安装</h3><p>1.<a href="https://www.jetbrains.com/clion/">Clion下载</a>：下载后正常安装即可</p>
<p>2.<a href="https://gnutoolchains.com/arm-eabi/openocd/">OpenOCD下载</a>：下载后解压到存放的目录，记住存放路径留待后面使用。</p>
<p>3.<a href="https://osdn.net/projects/mingw/releases/">MinGW下载</a>：下载后正常安装即可（安装路径不要有中文或空格）</p>
<p>安装后我们会得到一个 名为 “MinGW Installer Manager” 的软件 ，打开它。</p>
<p>勾选如图的两项后选择 Installation -&gt; Apply Changes ，在弹出的对话框中选择Apply后耐心等待安装完成。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619006464175-1620467115426.png" alt="1619006464175"></p>
<p>4.<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">GNU Arm Embedded Toolchain下载</a>：下载后正常安装即可（尽量不要安装到C盘，且安装路径不要有中文或空格），注意要勾选添加到环境变量否则需要手动添加</p>
<p>5.<a href="https://www.st.com/content/st_com/zh/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-programmers/stsw-link007.html">（非必须）ST-Link v2驱动下载</a>由于想要使用Jlink的话需要修改Jlink驱动，所以现在手中有未完成工程还想更换开发环境的建议先用ST-Link做一下过渡（若需要其他版本驱动请到ST官网自行寻找下载）。</p>
<h4 id="附手动添加MinGW环境变量方法："><a href="#附手动添加MinGW环境变量方法：" class="headerlink" title="附手动添加MinGW环境变量方法："></a>附手动添加MinGW环境变量方法：</h4><p>系统设置-&gt;高级系统设置-&gt;环境变量-&gt;（双击）Path-&gt;新建-&gt;添加MinGW安装目录中的bin文件夹到环境变量中（如图），例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\SoftWare\MinGW\bin（该路径因人而异）</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619945824839-1620467115426.png" alt="1619945824839"></p>
<p>结束后一路确定杀回设置。</p>
<h4 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h4><p>按下Win+R打开运行窗口，输入cmd回车，分别输入：</p>
<p>gcc -v</p>
<p>arm-none-eabi-gcc -v</p>
<p>输出如下说明安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\ZheWana&gt;gcc -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=d:/software/mingw/bin/../libexec/gcc/mingw32/9.2.0/lto-wrapper.exe</span><br><span class="line">Target: mingw32</span><br><span class="line">Configured with: ../src/gcc-9.2.0/configure --build=x86_64-pc-linux-gnu --host=mingw32 --target=mingw32 --disable-win32-registry --with-arch=i586 --with-tune=generic --enable-static --enable-shared --enable-threads --enable-languages=c,c++,objc,obj-c++,fortran,ada --with-dwarf2 --disable-sjlj-exceptions --enable-version-specific-runtime-libs --enable-libgomp --disable-libvtv --with-libiconv-prefix=/mingw --with-libintl-prefix=/mingw --enable-libstdcxx-debug --disable-build-format-warnings --prefix=/mingw --with-gmp=/mingw --with-mpfr=/mingw --with-mpc=/mingw --with-isl=/mingw --enable-nls --with-pkgversion=&#x27;MinGW.org GCC Build-2&#x27;</span><br><span class="line">Thread model: win32</span><br><span class="line">gcc version 9.2.0 (MinGW.org GCC Build-2)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\ZheWana&gt;arm-none-eabi-gcc -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=arm-none-eabi-gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=d:/software/10\ 2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/lto-wrapper.exe</span><br><span class="line">Target: arm-none-eabi</span><br><span class="line">Configured with: /mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/src/gcc/configure --build=x86_64-linux-gnu --host=i686-w64-mingw32 --target=arm-none-eabi --prefix=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/install-mingw --libexecdir=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/install-mingw/lib --infodir=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/install-mingw/share/doc/gcc-arm-none-eabi/info --mandir=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/install-mingw/share/doc/gcc-arm-none-eabi/man --htmldir=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/install-mingw/share/doc/gcc-arm-none-eabi/html --pdfdir=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/install-mingw/share/doc/gcc-arm-none-eabi/pdf --enable-languages=c,c++ --enable-mingw-wildcard --disable-decimal-float --disable-libffi --disable-libgomp --disable-libmudflap --disable-libquadmath --disable-libssp --disable-libstdcxx-pch --disable-nls --disable-shared --disable-threads --disable-tls --with-gnu-as --with-gnu-ld --with-headers=yes --with-newlib --with-python-dir=share/gcc-arm-none-eabi --with-sysroot=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/install-mingw/arm-none-eabi --with-libiconv-prefix=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/build-mingw/host-libs/usr --with-gmp=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/build-mingw/host-libs/usr --with-mpfr=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/build-mingw/host-libs/usr --with-mpc=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/build-mingw/host-libs/usr --with-isl=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/build-mingw/host-libs/usr --with-libelf=/mnt/workspace/workspace/GCC-10-pipeline/jenkins-GCC-10-pipeline-48_20201124_1606180641/build-mingw/host-libs/usr --with-host-libstdcxx=&#x27;-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm&#x27; --with-pkgversion=&#x27;GNU Arm Embedded Toolchain 10-2020-q4-major&#x27; --with-multilib-list=rmprofile,aprofile</span><br><span class="line">Thread model: single</span><br><span class="line">Supported LTO compression algorithms: zlib</span><br><span class="line">gcc version 10.2.1 20201103 (release) (GNU Arm Embedded Toolchain 10-2020-q4-major)</span><br></pre></td></tr></table></figure>

<h4 id="Clion中文界面配置"><a href="#Clion中文界面配置" class="headerlink" title="Clion中文界面配置"></a>Clion中文界面配置</h4><p>打开Clion，根据提示登录我们的<del>白嫖</del>账号。</p>
<p>选择Plugins-&gt;Marketplace-&gt;搜索“Chinese”,选择Chinese(Simplified) Language Pack/中文语言包</p>
<p>安装后重启即可。</p>
<h4 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h4><p>打开Clion-&gt;自定义-&gt;所有设置…-&gt;嵌入式开发</p>
<p>在OpenOCD位置中选择openocd.exe所在的位置；</p>
<p>在Stm32CubeMX位置中选择STM32CubeMX.exe所在的位置。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619922996711-1620467115426.png" alt="1619922996711"></p>
<p>完成后可以点击测试来测试一下是否成功配置。</p>
<h4 id="来试着建立我们的第一个工程"><a href="#来试着建立我们的第一个工程" class="headerlink" title="来试着建立我们的第一个工程"></a>来试着建立我们的第一个工程</h4><p>打开Clion，选择新建项目；</p>
<p>选择嵌入式一栏中的STM32CubeMX，新建一个文件夹用来存储Clion的工程（名字里面不要带有中文或空格），路径的最后一个文件名称要改为当前工程的名称，须要记住。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619088458058-1620467115427.png" alt="1619088458058"></p>
<p>完成后点击创建。</p>
<p>一番加载之后会出现这样的界面：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619088539398-1620467115427.png" alt="1619088539398"></p>
<p>点击中间的：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619088559232-1620467115427.png" alt="1619088559232"></p>
<p>就会自动运行CubeMX了，不过初始的芯片并不是我们想要的芯片，可以通过点击更换我们想要的芯片：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619088721106-1620467115427.png" alt="1619088721106"></p>
<p>我们仍以STM32F401CCU6为例来进行操作，配置的过程和正常使用芯片的时候几乎完全一致，需要注意的有这么三点：</p>
<p>1.工程名必须与之前的名字一致：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619088916849-1620467115427.png" alt="1619088916849"></p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619088940249-1620467115427.png" alt="1619088940249"></p>
<p>2.工程路径要和之前的路径是一样的：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619089152073-1620467115427.png" alt="1619089152073"></p>
<p><img src="C:\Users\ZheWana\AppData\Roaming\Typora\typora-user-images\1619088940249.png" alt="1619088940249"></p>
<p>3.ToolChain中要在这两项中任选一个并勾选右侧的Generate Under Root：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619089057614-1620467115427.png" alt="1619089057614"></p>
<p>配置完成之后点击生成代码，会提示是否要覆盖已存在的工程，选择Yes。</p>
<p>完成后点击Close，回到Clion。</p>
<p>界面会变成这个样子：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619089560446-1620467115427.png" alt="1619089560446"></p>
<p>紧接着会提示选择配置文件，因为这里没有我们需要的配置文件，所以我们点击取消，后面我们会自己写适合我们自己的配置文件。</p>
<p>至此，工程建立完毕，可以开始愉快的写代码了！</p>
<p>PS：主函数文件在“Core\Src\main.c”</p>
<p>​         函数库文件在“Driver\STM32F4xx_HAL_Driver\Src\xxx.c”</p>
<p>随便写一段代码，发现似乎代码补全并没有很好用？那我们来更改一下设置：</p>
<p>Ctrl+Alt+S打开设置界面：</p>
<p>（什么？你打开了QQ录屏？咳咳咳）</p>
<p>它其实在这里：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619090132742-1620467115427.png" alt="1619090132742"></p>
<p>点击编辑器-&gt;常规-&gt;代码完成（其实应该是代码补全咳咳）-&gt;取消匹配大小写前面的勾选（记得按应用）</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619090292986-1620467115427.png" alt="1619090292986"></p>
<p>回去敲一段代码就可以享受到丝滑的代码补全了：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619090418072-1620467115427.png" alt="1619090418072"></p>
<h4 id="配置文件的书写"><a href="#配置文件的书写" class="headerlink" title="配置文件的书写"></a>配置文件的书写</h4><p>考虑到随着开发过程的延长，我们用到的调试器会逐渐增多，所以我们在Clion工程文件夹中新建一个Config文件夹专门用来存放各种配置文件。</p>
<p>在文件夹中右键新建一个文本文档，后把文档的名字连同后缀改为“STlink.cfg”。</p>
<p>这里说一下配置文件书写的格式：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#前面带有“#”的是注释</span></span><br><span class="line"><span class="comment">#下方xxxxxx选择调试器型号，对应的配置文件在openocd文件夹路径\share\scripts\interface中，从中选择需要的即可。</span></span><br><span class="line">source <span class="section">[find interface/xxxxxx.cfg]</span></span><br><span class="line"><span class="comment">#下方xxxxxx选择调试接口，可选项包括：</span></span><br><span class="line"><span class="comment">#jtag、aice_jtag、swd、stlink_swim、hla_jtag、hla_swd</span></span><br><span class="line">transport select xxxxxx</span><br><span class="line"><span class="comment">#选择目标芯片种类，对应的配置文件在openocd文件夹路径\share\scripts\target中，从中选择需要的即可。</span></span><br><span class="line">source <span class="section">[find target/xxxxxx.cfg]</span></span><br><span class="line"><span class="comment"># 不使用复位接口</span></span><br><span class="line">reset_config none</span><br></pre></td></tr></table></figure>

<p>例如J-Link的配置文件内容如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">source <span class="section">[find interface/jlink.cfg]</span></span><br><span class="line"></span><br><span class="line">transport select swd</span><br><span class="line"></span><br><span class="line">source <span class="section">[find target/stm32f4x.cfg]</span></span><br><span class="line"></span><br><span class="line">reset_config none</span><br></pre></td></tr></table></figure>

<p>ST-Link的配置文件内容如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">source <span class="section">[find interface/stlink-v2.cfg]</span></span><br><span class="line"></span><br><span class="line">transport select hla_swd</span><br><span class="line"></span><br><span class="line">source <span class="section">[find target/stm32f4x.cfg]</span></span><br><span class="line"></span><br><span class="line">reset_config none</span><br></pre></td></tr></table></figure>

<p>接下来点击上方配置界面：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619177022369-1620467115427.png" alt="1619177022369"></p>
<p>选择编辑配置，</p>
<p>在面板配置文件中选择自己对应的调试器的配置文件即可（别忘了点击应用）。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619177105708-1620467115427.png" alt="1619177105708"></p>
<p>如果现在手中有未完成工程还想更换开发环境的此处建议使用ST-Link，因为J-Link需要更改驱动，这将导致你的Keil在换回原来的驱动之前无法使用J-link，而ST-Link则不存在这样的问题。</p>
<h4 id="关于硬件浮点运算单元"><a href="#关于硬件浮点运算单元" class="headerlink" title="关于硬件浮点运算单元"></a>关于硬件浮点运算单元</h4><p>在CMake模板文件中将硬件浮点运算注释掉了，这会导致如果我们使用这部分就会报错，因此需要把这部分取消注释。</p>
<p>我们进入CMake的模板文件：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619959379967-1620467115427.png" alt="1619959379967"></p>
<p>将下面的代码取消注释：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Uncomment for hardware floating point</span></span><br><span class="line">add_compile_definitions(ARM_MATH_CM4<span class="comment">;ARM_MATH_MATRIX_CHECK;ARM_MATH_ROUNDING)</span></span><br><span class="line">add_compile_options(<span class="attr">-mfloat-abi</span>=hard -mfpu=fpv4-sp-d16)</span><br><span class="line">add_link_options(<span class="attr">-mfloat-abi</span>=hard -mfpu=fpv4-sp-d16)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="J-Link驱动修改（非必须，看个人需要）"><a href="#J-Link驱动修改（非必须，看个人需要）" class="headerlink" title="J-Link驱动修改（非必须，看个人需要）"></a>J-Link驱动修改（非必须，看个人需要）</h4><p>接下来我们来修改一下J-Link驱动。</p>
<p>下载Zadig并打开</p>
<p>插上J-Link</p>
<p>点击Options-&gt;在List All Devices前面打勾</p>
<p>然后在下拉列表中选择这个驱动：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619178335471-1620467115427.png" alt="1619178335471"></p>
<p>在下方更改为WinUSB：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619178369514-1620467115427.png" alt="1619178369514"></p>
<p>点击安装即可修改驱动。</p>
<h4 id="简单的界面功能介绍以及一点小小的适应性修改"><a href="#简单的界面功能介绍以及一点小小的适应性修改" class="headerlink" title="简单的界面功能介绍以及一点小小的适应性修改"></a>简单的界面功能介绍以及一点小小的适应性修改</h4><p>首先就是最常用的快捷键：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619178659117-1620467115427.png" alt="1619178659117"></p>
<p>什么，你想用快捷键但是觉得Clion的快捷键风格不适合你？我们可以改下快捷键的风格：</p>
<p>进入设置-&gt;键盘映射，可以在这里将快捷键风格改为Visul Studio风格：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619957548187-1620467115427.png" alt="1619957548187"></p>
<p>这样我们就可以在调试的时候按下F10下一步，按下F11进入函数了。</p>
<p>改完键盘快捷键再说一个代码风格不好的小朋友的福音：<strong>代码格式化</strong></p>
<p>如果你更改了VS风格的快捷键，那么你可以用“Ctrl+Alt+Enter”来实现当前文件代码的格式化。</p>
<p>具体的细节方面设置可以在设置-&gt;编辑器-&gt;代码样式-&gt;C/C++中进行设置：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619958119088-1620467115427.png" alt="1619958119088"></p>
<p>如果你觉得右上角的报错怪怪的并不是你所需要的，</p>
<p>进入设置找到下图设置项，先把上方配置文件从项目默认改成全局默认：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619942701283-1620467115427.png" alt="1619942701283"></p>
<p>取消endless loop后面的勾选：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619942737559-1620467115427.png" alt="1619942737559"></p>
<p>在下面的设置项中找到校对-&gt;拼写错误,取消勾选：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619942755542-1620467115427.png" alt="1619942755542"></p>
<p>点击应用、确定。</p>
<p><strong>调试界面：</strong></p>
<p>由于Clion进入调试模式就会自动运行程序而不是像keil一样在main函数停下来，所以建议调试前在main前下断点。</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619187470202-1620467115427.png" alt="1619187470202"></p>
<p>点击虫子图标进入调试界面，功能菜单在下面：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619187955822-1620467115427.png" alt="1619187955822"></p>
<p>关于功能键的介绍：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619190852209-1620467115427.png" alt="1619190852209"></p>
<p>点击变量窗口的“+”可以添加监视变量（可以是表达式，似乎输入函数还可以监视函数的返回值）：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619190975442-1620467115427.png" alt="1619190975442"></p>
<p>此外，代码窗口中的箭头不仅有指示代码执行位置的作用，还可以通过拖动箭头来强制执行语句：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619191179568-1620467115427.png" alt="1619191179568"></p>
<h4 id="关于F4调试过程中的一些问题（只有F4有类似的问题）："><a href="#关于F4调试过程中的一些问题（只有F4有类似的问题）：" class="headerlink" title="关于F4调试过程中的一些问题（只有F4有类似的问题）："></a>关于F4调试过程中的一些问题（只有F4有类似的问题）：</h4><p>我们进入调试之后运行代码，然后暂停会发现一件奇怪的事：</p>
<p>代码停在了错误处理的死循环中：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619191669418-1620467115427.png" alt="1619191669418"></p>
<p>这是由于openocd的配置文件修改了我们的核心频率，导致HAL库在配置时钟树的时候会检测到时钟频率不是我们要配置的频率而进入ErrorHandler。由于进入调试的时候openocd的配置文件被运行了一次所以会产生这个问题。</p>
<p>由于复位会重置我们的时钟频率，所以如果不在意的话只要每次进入调试都复位一下即可解决问题：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619191819353-1620467115427.png" alt="1619191819353"></p>
<p>当然，解决办法也很简单：</p>
<p>在target文件夹中找到stm32f4x.cfg文件打开，用“#”将下面内容注释：</p>
<blockquote>
<p><strong>笔者说：</strong>虽说这个问题理论上是可以通过修改配置文件来解决，但是本着简单粗暴的原则，我们直接将不必要的代码注释掉即可。</p>
</blockquote>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#   $_TARGETNAME configure -event reset-init &#123;</span></span><br><span class="line"><span class="comment">#       # Configure PLL to boost clock to HSI x 4 (64 MHz)</span></span><br><span class="line"><span class="comment">#       mww 0x40023804 0x08012008   ;# RCC_PLLCFGR 16 Mhz /8 (M) * 128 (N) /4(P)</span></span><br><span class="line"><span class="comment">#       mww 0x40023C00 0x00000102   ;# FLASH_ACR = PRFTBE | 2(Latency)</span></span><br><span class="line"><span class="comment">#       mmw 0x40023800 0x01000000 0 ;# RCC_CR |= PLLON</span></span><br><span class="line"><span class="comment">#       sleep 10                    ;# Wait for PLL to lock</span></span><br><span class="line"><span class="comment">#       mmw 0x40023808 0x00001000 0 ;# RCC_CFGR |= RCC_CFGR_PPRE1_DIV2</span></span><br><span class="line"><span class="comment">#       mmw 0x40023808 0x00000002 0 ;# RCC_CFGR |= RCC_CFGR_SW_PLL</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       # Boost JTAG frequency</span></span><br><span class="line"><span class="comment">#       adapter_khz 8000</span></span><br><span class="line"><span class="comment">#   &#125;</span></span><br></pre></td></tr></table></figure>

<p>接下来就可以开心地进行调试了。</p>
<h4 id="关于查看寄存器配置"><a href="#关于查看寄存器配置" class="headerlink" title="关于查看寄存器配置"></a>关于查看寄存器配置</h4><p>进入调试，点击外设：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619189512044-1620467115427.png" alt="1619189512044"></p>
<p>后点击中间的加载.svd文件</p>
<p>由于我们安装过keil，故我们有现成的寄存器文件，路径如下：</p>
<p>…\Keil5\Packs\Keil\STM32F4xx_DFP\2.15.0\CMSIS\SVD\STM32F40x.svd</p>
<p>其他.svd文件也在相同路径下。</p>
<p>选择后出现下面窗口：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619189708577-1620467115427.png" alt="1619189708577"></p>
<p>可以根据需要选择需要查看的寄存器，也可以为了方便直接全选。</p>
<p>后续可以点击配置键重新配置选择的寄存器：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619190024821-1620467115428.png" alt="1619190024821"></p>
<h4 id="关于GDB调试"><a href="#关于GDB调试" class="headerlink" title="关于GDB调试"></a>关于GDB调试</h4><p>网上关于GDB调试的内容有很多，这里就列出一些简单的命令供大家使用：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>命令缩写</th>
<th>命令说明</th>
</tr>
</thead>
<tbody><tr>
<td>list</td>
<td>l</td>
<td>显示多行源代码</td>
</tr>
<tr>
<td>break</td>
<td>b</td>
<td>设置断点,程序运行到断点的位置会停下来</td>
</tr>
<tr>
<td>info</td>
<td>i</td>
<td>描述程序的状态</td>
</tr>
<tr>
<td>display</td>
<td>disp</td>
<td>跟踪查看某个变量,每次停下来都显示它的值</td>
</tr>
<tr>
<td>step</td>
<td>s</td>
<td>执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句</td>
</tr>
<tr>
<td>next</td>
<td>n</td>
<td>执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)</td>
</tr>
<tr>
<td>print</td>
<td>p</td>
<td>打印内部变量值</td>
</tr>
<tr>
<td>continue</td>
<td>c</td>
<td>继续程序的运行,直到遇到下一个断点</td>
</tr>
<tr>
<td>set var name=v</td>
<td></td>
<td>设置变量的值</td>
</tr>
<tr>
<td>start</td>
<td>st</td>
<td>开始执行程序,在main函数的第一条语句前面停下来</td>
</tr>
<tr>
<td>kill</td>
<td>k</td>
<td>终止正在调试的程序</td>
</tr>
<tr>
<td>watch</td>
<td></td>
<td>监视变量值的变化</td>
</tr>
<tr>
<td>quit</td>
<td>q</td>
<td>退出GDB环境</td>
</tr>
</tbody></table>
<p>具体用法可以参考<a href="https://www.cnblogs.com/HKUI/p/8955443.html">这篇文章</a>。</p>
<h4 id="关于printf重定向问题"><a href="#关于printf重定向问题" class="headerlink" title="关于printf重定向问题"></a>关于printf重定向问题</h4><p>在使用Clion时无法正常进行串口重定向。</p>
<p>对此我们提供一种解决方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件包含如下：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重定向函数内容如下，使用时直接调用即可：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART_printf</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">  length = vsnprintf(buffer, <span class="number">128</span>, fmt, ap);</span><br><span class="line">    </span><br><span class="line">  HAL_UART_Transmit(huart, (<span class="keyword">uint8_t</span> *)buffer, length, HAL_MAX_DELAY);</span><br><span class="line">    </span><br><span class="line">  va_end(ap);</span><br><span class="line">  <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关于多文件工程的组建"><a href="#关于多文件工程的组建" class="headerlink" title="关于多文件工程的组建"></a>关于多文件工程的组建</h4><p>在使用的过程中还会遇到的问题就是关于多文件项目找不到包含文件的问题，为了解决这种问题我们给出两种方法：</p>
<p>首先是最简单粗暴的方法：</p>
<p><strong>将需要使用的头文件（.h）丢进Inc文件夹，把源文件(.c)放进Src文件夹，然后在主函数include一下就可以用了。</strong></p>
<p>不过这种简单粗暴的方法往往不能让我们的工程变得井井有条，故我们有下面这个优雅的方法：</p>
<p>由于Clion是使用CMake进行工程组建的，所以我们在导入外部源文件的时候需要对CMake配置文件做点手脚。</p>
<p>PS：CMakeLists.txt是根据模板文件生成的，所以我们应该更改模板文件而不是这个文件，否则所作更改会在重新生成CMake文件的时候被覆盖。</p>
<p>此处以<strong>DMP库的导入</strong>为例：</p>
<p>首先在<strong>工程目录下</strong>新建一个文件夹并命名为“DMP”；</p>
<p>接下来将我们需要用到的文件复制到该文件夹下；</p>
<p>接下来打开我们项目列表中的<strong>CmakeLists_template.txt</strong>文件，我们开始改写CMake模板文件：</p>
<p>我们在文件中搜索“<strong>include_directories</strong>”可以看到如下语句：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">include_directories($&#123;includes&#125;)</span><br></pre></td></tr></table></figure>

<p>我们在这句话的下方加一句：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">include_directories(DMP)</span><br></pre></td></tr></table></figure>

<p>然后将下方的这个语句做一点小小的更改：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#更改前：</span></span><br><span class="line">file(GLOB_RECURSE SOURCES $&#123;sources&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#更改后：</span></span><br><span class="line">file(GLOB_RECURSE SOURCES $&#123;sources&#125; &quot;DMP/*.*&quot;)</span><br></pre></td></tr></table></figure>

<p>完成后右击(.ioc）文件，选择“使用CubeMX更新CMake项目”：</p>
<p><img src="/images/%E5%88%A9%E7%94%A8Clion%E7%9A%84STM32%E5%BC%80%E5%8F%91/1619958919004-1620467115428.png" alt="1619958919004"></p>
<p>回到主函数文件编译，此时应该没有问题了。</p>
<p>至此全部教程完成，如有问题可与我本人联系，内容中如果有任何形式的任何错误，欢迎大佬指出。</p>
<p>以上</p>
]]></content>
      <categories>
        <category>单片机</category>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>VL53L0X模块笔记</title>
    <url>/2021/54da72d34b59/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近几天学习了激光测距模块，现将过程记录下来以便以后浏览。</p>
<span id="more"></span>

<blockquote>
<p>有关模块学习的资料已经整理后上传了：</p>
<p><a href="https://wws.lanzoui.com/izIHArp85pa">https://wws.lanzoui.com/izIHArp85pa</a></p>
<p>密码:ayr4</p>
</blockquote>
<h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><p><del>VL53L0是一款意法半导体推出的激光测距模块</del></p>
<p>果然还是复制官方的说法比较靠谱：</p>
<blockquote>
<p>以下内容来自数据手册“Description”和某翻译</p>
<p>The VL53L0X is a new generation Time-of-Flight (ToF) laser-ranging module housed in the smallest package on the market today, providing accurate distance measurement whatever the target reflectances unlike conventional technologies. It can measure absolute distances up to 2m, setting a new benchmark in ranging performance levels, opening the door to various new applications.</p>
<p>VL53L0X是新一代的飞行时间（ToF）激光测距模块，采用当今市场上最小的封装，与传统技术不同，无论目标反射如何，都能提供精确的距离测量。它可以测量高达2米的绝对距离，为性能水平的范围设定了新的基准，为各种新的应用打开了大门。</p>
<p>The VL53L0X integrates a leading-edge SPAD array (Single Photon Avalanche Diodes) and embeds ST’s second generation FlightSenseTM patented technology.</p>
<p>VL53L0X集成了先进的SPAD阵列（单光子雪崩二极管），并嵌入ST的第二代FlightSenseTM专利技术。</p>
<p>The VL53L0X’s 940nm VCSEL emitter (Vertical Cavity Surface-Emitting Laser), is totally invisible to the human eye, coupled with internal physical infrared filters, it enables longer ranging distance, higher immunity to ambient light and better robustness to cover-glass optical cross-talk.  </p>
<p>VL53L0X的940nm VCSEL发射器（垂直腔面发射激光器）对人眼完全不可见，再加上内部物理红外滤光片，它可以实现更长的测距距离、更高的环境光免疫力和更好的鲁棒性，以覆盖玻璃光学串扰。</p>
</blockquote>
<p>附模块原理图如下：</p>
<p><img src="/images/53l0x_SCH-1626938571782.jpg" alt="53l0x_SCH"></p>
<h3 id="通信接口及引脚定义"><a href="#通信接口及引脚定义" class="headerlink" title="通信接口及引脚定义"></a>通信接口及引脚定义</h3><p>模块采用IIC通信，故：</p>
<p><strong>SCL：IIC时钟线</strong></p>
<p><strong>SDA：IIC数据线</strong></p>
<p>此外：</p>
<p><strong>VIN：电源</strong></p>
<p><strong>GND：接地</strong></p>
<p><strong>XShut：设备唤醒引脚</strong></p>
<blockquote>
<p>PS：XShut的接线方法决定了设备的测量模式，引用手册中的说法如下：</p>
<p>There are two options available for device power up/boot.</p>
<p>Option 1: </p>
<p>**XSHUT pin connected and controlled from host.**This option helps to optimize power consumption as the VL53L0X can be completely powered off when not used, and then woken up through host GPIO (using XSHUT pin).</p>
<p>HW Standby mode is defined as the period when AVDD is present and XSHUT is low.  </p>
<p>Option 2: </p>
<p><strong>XSHUT pin not controlled by host, and tied to AVDD through pull-up resistor.</strong></p>
<p>In case XSHUT pin is not controlled, the power up sequence is presented in Figure 11. In this case, the device is going automatically in SW STANDBY after FW BOOT, without entering HW STANDBY.  </p>
</blockquote>
<p><strong>GPIO1：中断输出</strong></p>
<blockquote>
<p>PS：GPIO1为中断输出，在手册中可以看出，当采用中断测量模式的时候，每次当设备准备就绪进行新的测量时，中断引脚就会进行输出来触发主机的中断，手册中说法如下：</p>
<p>Interrupt mode: An interrupt pin (GPIO1) sends an interrupt to the host when a new measurement is available.  </p>
</blockquote>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>对于该模块，不得不提的事情就是官方为其写了一个API库可以方便我们的应用层开发，而我们的任务就是进行该库的移植。</p>
<p>本来这个库的最大难点就在于移植，但是在网上我找到了有人做过了HAL库的移植版本，因此我们自己就不再做HAL移植了。但是为了方便自己以后在其他的平台上进行开发，我还是会对比已经移植完的函数库进行一次移植，这段内容就放在后面了。</p>
<p>我们首先来说API函数库：</p>
<h3 id="测量数据结构体"><a href="#测量数据结构体" class="headerlink" title="测量数据结构体"></a>测量数据结构体</h3><p>结构体源码如下，各个变量的含义均在库函数中有所提及：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> TimeStamp;		<span class="comment">/*!&lt; 32-bit time stamp. */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> MeasurementTimeUsec;</span><br><span class="line">		<span class="comment">/*!&lt; Give the Measurement time needed by the device to do the</span></span><br><span class="line"><span class="comment">		 * measurement.*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint16_t</span> RangeMilliMeter;	<span class="comment">/*!&lt; range distance in millimeter. */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint16_t</span> RangeDMaxMilliMeter;</span><br><span class="line">		<span class="comment">/*!&lt; Tells what is the maximum detection distance of the device</span></span><br><span class="line"><span class="comment">		 * in current setup and environment conditions (Filled when</span></span><br><span class="line"><span class="comment">		 *	applicable) */</span></span><br><span class="line"></span><br><span class="line">	FixPoint1616_t SignalRateRtnMegaCps;</span><br><span class="line">		<span class="comment">/*!&lt; Return signal rate (MCPS)\n these is a 16.16 fix point</span></span><br><span class="line"><span class="comment">		 *	value, which is effectively a measure of target</span></span><br><span class="line"><span class="comment">		 *	 reflectance.*/</span></span><br><span class="line">	FixPoint1616_t AmbientRateRtnMegaCps;</span><br><span class="line">		<span class="comment">/*!&lt; Return ambient rate (MCPS)\n these is a 16.16 fix point</span></span><br><span class="line"><span class="comment">		 *	value, which is effectively a measure of the ambien</span></span><br><span class="line"><span class="comment">		 *	t light.*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint16_t</span> EffectiveSpadRtnCount;</span><br><span class="line">		<span class="comment">/*!&lt; Return the effective SPAD count for the return signal.</span></span><br><span class="line"><span class="comment">		 *	To obtain Real value it should be divided by 256 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint8_t</span> ZoneId;</span><br><span class="line">		<span class="comment">/*!&lt; Denotes which zone and range scheduler stage the range</span></span><br><span class="line"><span class="comment">		 *	data relates to. */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> RangeFractionalPart;</span><br><span class="line">		<span class="comment">/*!&lt; Fractional part of range distance. Final value is a</span></span><br><span class="line"><span class="comment">		 *	FixPoint168 value. */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> RangeStatus;</span><br><span class="line">		<span class="comment">/*!&lt; Range Status for the current measurement. This is device</span></span><br><span class="line"><span class="comment">		 *	dependent. Value = 0 means value is valid.</span></span><br><span class="line"><span class="comment">		 *	See \ref RangeStatusPage */</span></span><br><span class="line">&#125; VL53L0X_RangingMeasurementData_t;</span><br></pre></td></tr></table></figure>

<p>在使用之前应该定义一个用于测量数据存储的结构体变量以供后续函数使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VL53L0X_RangingMeasurementData_t RangingData;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中RangeMilliMeter为我们期望的测量距离值，单位：mm</p>
</blockquote>
<h3 id="设备结构体"><a href="#设备结构体" class="headerlink" title="设备结构体"></a>设备结构体</h3><p>设备结构体是API函数库和所用平台之间连接的纽带<del>（反正手册是这么说的）</del>，结构体源码如下，变量含义已经在源码中给出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VL53L0X_DevData_t Data;               <span class="comment">/*!&lt; embed ST Ewok Dev  data as &quot;Data&quot;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!&lt; user specific field */</span></span><br><span class="line"></span><br><span class="line">    I2C_HandleTypeDef *I2cHandle;</span><br><span class="line">    <span class="keyword">uint8_t</span>   I2cDevAddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>    DevLetter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>     Id;</span><br><span class="line">    <span class="keyword">int</span>     Present;</span><br><span class="line">    <span class="keyword">int</span> 	Enabled;</span><br><span class="line">    <span class="keyword">int</span>		Ready;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span>   comms_type;</span><br><span class="line">    <span class="keyword">uint16_t</span>  comms_speed_khz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> LeakyRange;</span><br><span class="line">    <span class="keyword">int</span> LeakyFirst;</span><br><span class="line">    <span class="keyword">uint8_t</span> RangeStatus;</span><br><span class="line">    <span class="keyword">uint8_t</span> PreviousRangeStatus;</span><br><span class="line">    FixPoint1616_t SignalRateRtnMegaCps;</span><br><span class="line">    <span class="keyword">uint16_t</span> EffectiveSpadRtnCount;</span><br><span class="line">    <span class="keyword">uint32_t</span> StartTime;</span><br><span class="line"></span><br><span class="line">&#125; VL53L0X_Dev_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在使用之前，我们需要定义一个设备结构体变量以供后续函数使用，同时要在定义时将I2C句柄（&amp;hi2c1）以及I2C设备地址（0x52）赋值:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VL53L0X_Dev_t Dev = &#123;</span><br><span class="line">        .I2cHandle=&amp;hi2c1,</span><br><span class="line">        .I2cDevAddr=<span class="number">0x52</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PS:众所周知，HAL库使用的是8位地址，因此手册中的7位地址需要左移一位才能被正确读取，但是为什么0x52没有左移呢？</p>
<p><img src="/../../images/image-20210722112409582.png" alt="image-20210722112409582"></p>
<p>因为显然它在手册中使用的就是8位地址格式（最后一位为读写位）。</p>
</blockquote>
<h3 id="重命名的变量"><a href="#重命名的变量" class="headerlink" title="重命名的变量"></a>重命名的变量</h3><p>API中大部分函数返回值均为VL53L0X_Error类型，这个类型其实是对于有符号字符型的重命名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int8_t</span> VL53L0X_Error;</span><br></pre></td></tr></table></figure>

<p>为了保证类型的一致性，所以在调试看返回值的时候可以同样用这个类型来定义变量来存储返回的错误信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VL53L0X_Error re = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="API常用函数"><a href="#API常用函数" class="headerlink" title="API常用函数"></a>API常用函数</h3><h4 id="设备初始化阶段"><a href="#设备初始化阶段" class="headerlink" title="设备初始化阶段"></a>设备初始化阶段</h4><p>API函数库里面的应用函数很全，但是我们其实也只会用到其中的很小一部分，下面根据调用顺序一一列举：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Wait for device booted after chip enable (hardware standby)</span></span><br><span class="line"><span class="comment"> * This function can be run only when VL53L0X_State is VL53L0X_STATE_POWERDOWN.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function is not Implemented</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Dev      Device Handle</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NOT_IMPLEMENTED Not implemented</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_WaitDeviceBooted</span><span class="params">(VL53L0X_DEV Dev)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>等待设备启动</p>
</blockquote>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief One time device initialization</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To be called once and only once after device is brought out of reset</span></span><br><span class="line"><span class="comment"> * (Chip enable) and booted see @a VL53L0X_WaitDeviceBooted()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @par Function Description</span></span><br><span class="line"><span class="comment"> * When not used after a fresh device &quot;power up&quot; or reset, it may return</span></span><br><span class="line"><span class="comment"> * @a #VL53L0X_ERROR_CALIBRATION_WARNING meaning wrong calibration data</span></span><br><span class="line"><span class="comment"> * may have been fetched from device that can result in ranging offset error\n</span></span><br><span class="line"><span class="comment"> * If application cannot execute device reset or need to run VL53L0X_DataInit</span></span><br><span class="line"><span class="comment"> * multiple time then it  must ensure proper offset calibration saving and</span></span><br><span class="line"><span class="comment"> * restore on its own by using @a VL53L0X_GetOffsetCalibrationData() on first</span></span><br><span class="line"><span class="comment"> * power up and then @a VL53L0X_SetOffsetCalibrationData() in all subsequent init</span></span><br><span class="line"><span class="comment"> * This function will change the VL53L0X_State from VL53L0X_STATE_POWERDOWN to</span></span><br><span class="line"><span class="comment"> * VL53L0X_STATE_WAIT_STATICINIT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function Access to the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Dev                   Device Handle</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NONE     Success</span></span><br><span class="line"><span class="comment"> * @return  &quot;Other error code&quot;    See ::VL53L0X_Error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_DataInit</span><span class="params">(VL53L0X_DEV Dev)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设备初始化函数</p>
<p>注意：只能被调用一次！</p>
</blockquote>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Do basic device init (and eventually patch loading)</span></span><br><span class="line"><span class="comment"> * This function will change the VL53L0X_State from</span></span><br><span class="line"><span class="comment"> * VL53L0X_STATE_WAIT_STATICINIT to VL53L0X_STATE_IDLE.</span></span><br><span class="line"><span class="comment"> * In this stage all default setting will be applied.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function Access to the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Dev                   Device Handle</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NONE     Success</span></span><br><span class="line"><span class="comment"> * @return  &quot;Other error code&quot;    See ::VL53L0X_Error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_StaticInit</span><span class="params">(VL53L0X_DEV Dev)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进行基础设备初始化</p>
</blockquote>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Perform Reference Calibration</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @details Perform a reference calibration of the Device.</span></span><br><span class="line"><span class="comment"> * This function should be run from time to time before doing</span></span><br><span class="line"><span class="comment"> * a ranging measurement.</span></span><br><span class="line"><span class="comment"> * This function will launch a special ranging measurement, so</span></span><br><span class="line"><span class="comment"> * if interrupt are enable an interrupt will be done.</span></span><br><span class="line"><span class="comment"> * This function will clear the interrupt generated automatically.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @warning This function is a blocking function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function Access to the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Dev                  Device Handle</span></span><br><span class="line"><span class="comment"> * @param   pVhvSettings         Pointer to vhv settings parameter.</span></span><br><span class="line"><span class="comment"> * @param   pPhaseCal            Pointer to PhaseCal parameter.</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NONE    Success</span></span><br><span class="line"><span class="comment"> * @return  &quot;Other error code&quot;   See ::VL53L0X_Error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_PerformRefCalibration</span><span class="params">(VL53L0X_DEV Dev,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">uint8_t</span> *pVhvSettings, <span class="keyword">uint8_t</span> *pPhaseCal)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对设备执行校准</p>
</blockquote>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Set Reference Calibration Parameters</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @par Function Description</span></span><br><span class="line"><span class="comment"> * Set Reference Calibration Parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function Access to the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Dev                            Device Handle</span></span><br><span class="line"><span class="comment"> * @param   VhvSettings                    Parameter for VHV</span></span><br><span class="line"><span class="comment"> * @param   PhaseCal                       Parameter for PhaseCal</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NONE              Success</span></span><br><span class="line"><span class="comment"> * @return  &quot;Other error code&quot;             See ::VL53L0X_Error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_SetRefCalibration</span><span class="params">(VL53L0X_DEV Dev,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">uint8_t</span> VhvSettings, <span class="keyword">uint8_t</span> PhaseCal)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对校准中获得的参数进行设置以完成设备的校准</p>
</blockquote>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Performs Reference Spad Management</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @par Function Description</span></span><br><span class="line"><span class="comment"> * The reference SPAD initialization procedure determines the minimum amount</span></span><br><span class="line"><span class="comment"> * of reference spads to be enables to achieve a target reference signal rate</span></span><br><span class="line"><span class="comment"> * and should be performed once during initialization.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function Access to the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function change the device mode to</span></span><br><span class="line"><span class="comment"> * VL53L0X_DEVICEMODE_SINGLE_RANGING</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Dev                          Device Handle</span></span><br><span class="line"><span class="comment"> * @param   refSpadCount                 Reports ref Spad Count</span></span><br><span class="line"><span class="comment"> * @param   isApertureSpads              Reports if spads are of type</span></span><br><span class="line"><span class="comment"> *                                       aperture or non-aperture.</span></span><br><span class="line"><span class="comment"> *                                       1:=aperture, 0:=Non-Aperture</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NONE            Success</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_REF_SPAD_INIT   Error in the Ref Spad procedure.</span></span><br><span class="line"><span class="comment"> * @return  &quot;Other error code&quot;           See ::VL53L0X_Error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_PerformRefSpadManagement</span><span class="params">(VL53L0X_DEV Dev,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">uint32_t</span> *refSpadCount, <span class="keyword">uint8_t</span> *isApertureSpads)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  Set a new device mode</span></span><br><span class="line"><span class="comment"> * @par Function Description</span></span><br><span class="line"><span class="comment"> * Set device to a new mode (ranging, histogram ...)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function doesn&#x27;t Access to the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Dev                   Device Handle</span></span><br><span class="line"><span class="comment"> * @param   DeviceMode            New device mode to apply</span></span><br><span class="line"><span class="comment"> *                                Valid values are:</span></span><br><span class="line"><span class="comment"> *                                VL53L0X_DEVICEMODE_SINGLE_RANGING</span></span><br><span class="line"><span class="comment"> *                                VL53L0X_DEVICEMODE_CONTINUOUS_RANGING</span></span><br><span class="line"><span class="comment"> *                                VL53L0X_DEVICEMODE_CONTINUOUS_TIMED_RANGING</span></span><br><span class="line"><span class="comment"> *                                VL53L0X_DEVICEMODE_SINGLE_HISTOGRAM</span></span><br><span class="line"><span class="comment"> *                                VL53L0X_HISTOGRAMMODE_REFERENCE_ONLY</span></span><br><span class="line"><span class="comment"> *                                VL53L0X_HISTOGRAMMODE_RETURN_ONLY</span></span><br><span class="line"><span class="comment"> *                                VL53L0X_HISTOGRAMMODE_BOTH</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NONE               Success</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_MODE_NOT_SUPPORTED This error occurs when DeviceMode is</span></span><br><span class="line"><span class="comment"> *                                          not in the supported list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_SetDeviceMode</span><span class="params">(VL53L0X_DEV Dev,</span></span></span><br><span class="line"><span class="params"><span class="function">	VL53L0X_DeviceModes DeviceMode)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设定设备工作模式</p>
</blockquote>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Start device measurement</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @details Started measurement will depend on device parameters set through</span></span><br><span class="line"><span class="comment"> * @a VL53L0X_SetParameters()</span></span><br><span class="line"><span class="comment"> * This is a non-blocking function.</span></span><br><span class="line"><span class="comment"> * This function will change the VL53L0X_State from VL53L0X_STATE_IDLE to</span></span><br><span class="line"><span class="comment"> * VL53L0X_STATE_RUNNING.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function Access to the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param   Dev                  Device Handle</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NONE                  Success</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_MODE_NOT_SUPPORTED    This error occurs when</span></span><br><span class="line"><span class="comment"> * DeviceMode programmed with @a VL53L0X_SetDeviceMode is not in the supported</span></span><br><span class="line"><span class="comment"> * list:</span></span><br><span class="line"><span class="comment"> *                                   Supported mode are:</span></span><br><span class="line"><span class="comment"> *                                   VL53L0X_DEVICEMODE_SINGLE_RANGING,</span></span><br><span class="line"><span class="comment"> *                                   VL53L0X_DEVICEMODE_CONTINUOUS_RANGING,</span></span><br><span class="line"><span class="comment"> *                                   VL53L0X_DEVICEMODE_CONTINUOUS_TIMED_RANGING</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_TIME_OUT    Time out on start measurement</span></span><br><span class="line"><span class="comment"> * @return  &quot;Other error code&quot;   See ::VL53L0X_Error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_StartMeasurement</span><span class="params">(VL53L0X_DEV Dev)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>开始执行测量</p>
</blockquote>
<hr>
<h4 id="测量阶段"><a href="#测量阶段" class="headerlink" title="测量阶段"></a>测量阶段</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Retrieve the measurements from device for a given setup</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @par Function Description</span></span><br><span class="line"><span class="comment"> * Get data from last successful Ranging measurement</span></span><br><span class="line"><span class="comment"> * @warning USER should take care about  @a VL53L0X_GetNumberOfROIZones()</span></span><br><span class="line"><span class="comment"> * before get data.</span></span><br><span class="line"><span class="comment"> * PAL will fill a NumberOfROIZones times the corresponding data</span></span><br><span class="line"><span class="comment"> * structure used in the measurement function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note This function Access to the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Dev                      Device Handle</span></span><br><span class="line"><span class="comment"> * @param   pRangingMeasurementData  Pointer to the data structure to fill up.</span></span><br><span class="line"><span class="comment"> * @return  VL53L0X_ERROR_NONE        Success</span></span><br><span class="line"><span class="comment"> * @return  &quot;Other error code&quot;       See ::VL53L0X_Error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VL53L0X_API VL53L0X_Error <span class="title">VL53L0X_GetRangingMeasurementData</span><span class="params">(VL53L0X_DEV Dev,</span></span></span><br><span class="line"><span class="params"><span class="function">	VL53L0X_RangingMeasurementData_t *pRangingMeasurementData)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取测量值</p>
</blockquote>
<h4 id="模块工作流程"><a href="#模块工作流程" class="headerlink" title="模块工作流程"></a>模块工作流程</h4><p>在数据手册中其实结合API函数库给出了模块推荐的工作流程，如下：</p>
<p>首先是初始化流程：</p>
<p><img src="/images/%E6%BF%80%E5%85%89%E6%B5%8B%E8%B7%9D%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B-1626938862721.png" alt="激光测距初始化流程"></p>
<p>接下来是测量流程：</p>
<p><img src="/images/%E6%BF%80%E5%85%89%E6%B5%8B%E8%B7%9D%E6%B5%8B%E9%87%8F%E6%B5%81%E7%A8%8B-1626938867288.png" alt="激光测距测量流程"></p>
<p>API使用举例（main.c）：</p>
<p><strong>环境：STM32F401CCU6+CubeMX+HAL</strong></p>
<p>在100Hz定时器中进行测量，并将测量标志位置一，然后在主循环中将获得的测量数据使用串口打印出来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN Header */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file           : main.c</span></span><br><span class="line"><span class="comment">  * @brief          : Main program body</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @attention</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2021 STMicroelectronics.</span></span><br><span class="line"><span class="comment">  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * This software component is licensed by ST under BSD 3-Clause license,</span></span><br><span class="line"><span class="comment">  * the &quot;License&quot;; You may not use this file except in compliance with the</span></span><br><span class="line"><span class="comment">  * License. You may obtain a copy of the License at:</span></span><br><span class="line"><span class="comment">  *                        opensource.org/licenses/BSD-3-Clause</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">/* USER CODE END Header */</span></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;i2c.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private includes ----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdarg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vl53l0x_api.h&quot;</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private typedef -----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PTD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END PTD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private define ------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PD */</span></span><br><span class="line"><span class="comment">/* USER CODE END PD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private macro -------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PM */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log UART_printf</span></span><br><span class="line"><span class="comment">/* USER CODE END PM */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables ---------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line">VL53L0X_RangingMeasurementData_t RangingData;</span><br><span class="line">VL53L0X_Dev_t Dev = &#123;</span><br><span class="line">        .I2cHandle=&amp;hi2c1,</span><br><span class="line">        .I2cDevAddr=<span class="number">0x52</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint8_t</span> TofDataRead;</span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes -----------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SystemClock_Config</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PFP */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART_printf</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">VL53L0X_Error re = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* USER CODE END PFP */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private user code ---------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  The application entry point.</span></span><br><span class="line"><span class="comment">  * @retval int</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 1 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> refSpadCount;</span><br><span class="line">    <span class="keyword">uint8_t</span> isApertureSpads;</span><br><span class="line">    <span class="keyword">uint8_t</span> VhvSettings;</span><br><span class="line">    <span class="keyword">uint8_t</span> PhaseCal;</span><br><span class="line">    <span class="comment">/* USER CODE END 1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MCU Configuration--------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span></span><br><span class="line">    HAL_Init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN Init */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE END Init */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Configure the system clock */</span></span><br><span class="line">    SystemClock_Config();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN SysInit */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE END SysInit */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line">    MX_GPIO_Init();</span><br><span class="line">    MX_I2C1_Init();</span><br><span class="line">    MX_TIM3_Init();</span><br><span class="line">    MX_USART1_UART_Init();</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_15, GPIO_PIN_RESET); <span class="comment">// Disable XSHUT</span></span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_15, GPIO_PIN_SET); <span class="comment">// Enable XSHUT</span></span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    HAL_NVIC_DisableIRQ(TIM3_IRQn);</span><br><span class="line"></span><br><span class="line">    re = VL53L0X_WaitDeviceBooted(&amp;Dev);</span><br><span class="line">    <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;%d\n&quot;</span>, re);</span><br><span class="line">    re = VL53L0X_DataInit(&amp;Dev);</span><br><span class="line">    <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;%d\n&quot;</span>, re);</span><br><span class="line">    re = VL53L0X_StaticInit(&amp;Dev);</span><br><span class="line">    <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;%d\n&quot;</span>, re);</span><br><span class="line">    re = VL53L0X_PerformRefCalibration(&amp;Dev, &amp;VhvSettings, &amp;PhaseCal);</span><br><span class="line">    <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;%d\n&quot;</span>, re);</span><br><span class="line">    re = VL53L0X_SetRefCalibration(&amp;Dev, VhvSettings, PhaseCal);</span><br><span class="line">    <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;%d\n&quot;</span>, re);</span><br><span class="line">    re = VL53L0X_PerformRefSpadManagement(&amp;Dev, &amp;refSpadCount, &amp;isApertureSpads);</span><br><span class="line">    <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;%d\n&quot;</span>, re);</span><br><span class="line">    re = VL53L0X_SetDeviceMode(&amp;Dev, VL53L0X_DEVICEMODE_CONTINUOUS_RANGING);</span><br><span class="line">    <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;%d\n&quot;</span>, re);</span><br><span class="line">    re = VL53L0X_StartMeasurement(&amp;Dev);</span><br><span class="line">    <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;%d\n\n&quot;</span>, re);</span><br><span class="line"></span><br><span class="line">    HAL_NVIC_EnableIRQ(TIM3_IRQn);</span><br><span class="line">    <span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Infinite loop */</span></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">    HAL_TIM_Base_Start_IT(&amp;htim3);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TofDataRead == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">log</span>(&amp;huart1, <span class="string">&quot;Measured distance: %i\n\r&quot;</span>, RangingData.RangeMilliMeter);</span><br><span class="line">            TofDataRead = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief System Clock Configuration</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SystemClock_Config</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    RCC_OscInitTypeDef RCC_OscInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    RCC_ClkInitTypeDef RCC_ClkInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Configure the main internal regulator output voltage</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    __HAL_RCC_PWR_CLK_ENABLE();</span><br><span class="line">    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);</span><br><span class="line">    <span class="comment">/** Initializes the RCC Oscillators according to the specified parameters</span></span><br><span class="line"><span class="comment">    * in the RCC_OscInitTypeDef structure.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;</span><br><span class="line">    RCC_OscInitStruct.HSEState = RCC_HSE_ON;</span><br><span class="line">    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;</span><br><span class="line">    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;</span><br><span class="line">    RCC_OscInitStruct.PLL.PLLM = <span class="number">25</span>;</span><br><span class="line">    RCC_OscInitStruct.PLL.PLLN = <span class="number">168</span>;</span><br><span class="line">    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;</span><br><span class="line">    RCC_OscInitStruct.PLL.PLLQ = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) &#123;</span><br><span class="line">        Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Initializes the CPU, AHB and APB buses clocks</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK</span><br><span class="line">                                  | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;</span><br><span class="line">    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;</span><br><span class="line">    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;</span><br><span class="line">    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;</span><br><span class="line">    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) &#123;</span><br><span class="line">        Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 4 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (htim3.Instance == TIM3) &#123;</span><br><span class="line">        VL53L0X_GetRangingMeasurementData(&amp;Dev, &amp;RangingData);</span><br><span class="line"><span class="comment">//        VL53L0X_ClearInterruptMask(&amp;Dev, VL53L0X_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY);</span></span><br><span class="line">        TofDataRead = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART_printf</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    length = vsnprintf(buffer, <span class="number">128</span>, fmt, ap);</span><br><span class="line"></span><br><span class="line">    HAL_UART_Transmit(huart, (<span class="keyword">uint8_t</span> *) buffer, length, HAL_MAX_DELAY);</span><br><span class="line"></span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 4 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  This function is executed in case of error occurrence.</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Error_Handler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN Error_Handler_Debug */</span></span><br><span class="line">    <span class="comment">/* User can add his own implementation to report the HAL error return state */</span></span><br><span class="line">    __disable_irq();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* USER CODE END Error_Handler_Debug */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  USE_FULL_ASSERT</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Reports the name of the source file and the source line number</span></span><br><span class="line"><span class="comment">  *         where the assert_param error has occurred.</span></span><br><span class="line"><span class="comment">  * @param  file: pointer to the source file name</span></span><br><span class="line"><span class="comment">  * @param  line: assert_param error line source number</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert_failed</span><span class="params">(<span class="keyword">uint8_t</span> *file, <span class="keyword">uint32_t</span> line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 6 */</span></span><br><span class="line">  <span class="comment">/* User can add his own implementation to report the file name and line number,</span></span><br><span class="line"><span class="comment">     ex: printf(&quot;Wrong parameters value: file %s on line %d\r\n&quot;, file, line) */</span></span><br><span class="line">  <span class="comment">/* USER CODE END 6 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_FULL_ASSERT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote>
<ul>
<li>设备初始化的时候不要开中断！！！</li>
<li>注意XShut的连接方式，如果和主设备连接了，则需要在测量之前进行唤醒操作。</li>
</ul>
</blockquote>
<h2 id="关于API的移植"><a href="#关于API的移植" class="headerlink" title="关于API的移植"></a>关于API的移植</h2><p>挖坑，以后填……</p>
]]></content>
      <categories>
        <category>硬件</category>
        <category>模块</category>
      </categories>
      <tags>
        <tag>VL53L0X</tag>
      </tags>
  </entry>
  <entry>
    <title>记MPU6050模块的学习过程</title>
    <url>/2021/9fca8038048c/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文为我自己学习MPU6050的过程以及其过程中遇到的问题，将其记录下来以方便自己以后再次使用，同时也是为了防止遗忘。</p>
<p>学习过程中用到的资料整理了下存了起来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.lanzous.com/iROIKnjuo6h</span><br><span class="line">密码:gzai</span><br></pre></td></tr></table></figure>

<p>环境：<strong>STM32F401CCU6+CubeMX+HAL库</strong></p>
<span id="more"></span>

<hr>
<h2 id="模块组成："><a href="#模块组成：" class="headerlink" title="模块组成："></a>模块组成：</h2><p> MPU6050+HMC5883L+MS5611 </p>
<h3 id="MPU6050：加速度计-陀螺仪"><a href="#MPU6050：加速度计-陀螺仪" class="headerlink" title="MPU6050：加速度计+陀螺仪"></a>MPU6050：加速度计+陀螺仪</h3><h3 id="HMC5883L：-3轴数字罗盘"><a href="#HMC5883L：-3轴数字罗盘" class="headerlink" title="HMC5883L：  3轴数字罗盘"></a>HMC5883L：  3轴数字罗盘</h3><h3 id="MS5611-：气压传感器"><a href="#MS5611-：气压传感器" class="headerlink" title="MS5611 ：气压传感器"></a>MS5611 ：气压传感器</h3><hr>
<h2 id="模块引脚定义："><a href="#模块引脚定义：" class="headerlink" title="模块引脚定义："></a>模块引脚定义：</h2><p>以下引脚用途以及配置为个人对与数据手册内容的理解，可能有误。</p>
<h3 id="VCC-IN-5V电源输入"><a href="#VCC-IN-5V电源输入" class="headerlink" title="VCC_IN:5V电源输入"></a>VCC_IN:5V电源输入</h3><h3 id="3-3V：3-3V电源输入"><a href="#3-3V：3-3V电源输入" class="headerlink" title="3.3V：3.3V电源输入"></a>3.3V：3.3V电源输入</h3><h3 id="GND：接地"><a href="#GND：接地" class="headerlink" title="GND：接地"></a>GND：接地</h3><h3 id="SCL：IIC总线时钟"><a href="#SCL：IIC总线时钟" class="headerlink" title="SCL：IIC总线时钟"></a>SCL：IIC总线时钟</h3><h3 id="SDA：IIC总线数据输入"><a href="#SDA：IIC总线数据输入" class="headerlink" title="SDA：IIC总线数据输入"></a>SDA：IIC总线数据输入</h3><h3 id="FSYNC：（MPU6050）"><a href="#FSYNC：（MPU6050）" class="headerlink" title="FSYNC：（MPU6050）"></a>FSYNC：（MPU6050）</h3><p>​    Frame synchronization digital input. Connect to GND if unused</p>
<p>​    帧同步数字输入。 如果未使用，则连接到GND</p>
<h3 id="（GND）"><a href="#（GND）" class="headerlink" title="（GND）"></a>（GND）</h3><h3 id="INTA：（MPU6050）"><a href="#INTA：（MPU6050）" class="headerlink" title="INTA：（MPU6050）"></a>INTA：（MPU6050）</h3><p>​    Interrupt digital output (totem pole or open-drain)</p>
<p>​    中断数字输出（图腾柱或漏极开路）</p>
<p>​     Interrupt functionality is configured via the Interrupt Configuration register. Items that are configurable include the INT pin configuration, the interrupt latching and clearing method, and triggers for the interrupt. Items that can trigger an interrupt are </p>
<p>(1) Clock generator locked to new reference oscillator (used when switching clock sources); </p>
<p>(2) new data is available to be read (from the FIFO and Data registers); </p>
<p>(3) accelerometer event interrupts; </p>
<p>(4) the MPU-60X0 did not receive an knowledge from an auxiliary sensor on the secondary I2C bus. The interrupt status can be read from the Interrupt Status register.  </p>
<h3 id="（配置为外部中断）"><a href="#（配置为外部中断）" class="headerlink" title="（配置为外部中断）"></a>（配置为外部中断）</h3><h3 id="DRDY：（HMC5883L）"><a href="#DRDY：（HMC5883L）" class="headerlink" title="DRDY：（HMC5883L）"></a>DRDY：（HMC5883L）</h3><p>​    Data Ready, Interrupt Pin. Internally pulled high. Optional connection. Low for 250 µsec when data is placed in the data output registers.</p>
<p>​    数据准备，中断引脚。内部被拉高。可选连接，当数据位于输出寄存器 上时会在低电位上停250μs。（理解为数据传输完成标志引脚）</p>
<h3 id="（配置为外部中断）-1"><a href="#（配置为外部中断）-1" class="headerlink" title="（配置为外部中断）"></a>（配置为外部中断）</h3><hr>
<h2 id="模块使用："><a href="#模块使用：" class="headerlink" title="模块使用："></a>模块使用：</h2><h3 id="伪前言："><a href="#伪前言：" class="headerlink" title="伪前言："></a>伪前言：</h3><p>使用分为两部分，首先是为了<strong>熟悉IIC使用以及对数据手册的阅读</strong>而存在的<strong>原始数据打印</strong>部分，接下来是为了真正应用而存在的<strong>DMP库移植</strong>部分。</p>
<p>第一次进行库的移植的确会出现很多奇怪的问题，请细心细心加耐心。</p>
<p>官方的手册是好东西，请多阅读。</p>
<p><em><strong>如果只是需要使用欧拉角数据，则不需要参考第一部分内容，直接进行第二部分即可</strong></em></p>
<p><em><strong>如果只是需要使用欧拉角数据，则不需要参考第一部分内容，直接进行第二部分即可</strong></em></p>
<p><em><strong>如果只是需要使用欧拉角数据，则不需要参考第一部分内容，直接进行第二部分即可</strong></em></p>
<hr>
<h3 id="原始数据的打印："><a href="#原始数据的打印：" class="headerlink" title="原始数据的打印："></a>原始数据的打印：</h3><p>首先新建一个F401工程，在新工程里面完成IIC和UART的配置。</p>
<p>其中IIC选择IIC1，下拉栏选择IIC，配置默认即可。</p>
<p>生成工程并打开。</p>
<p>在工程文件夹中新建一个mpu6050.h文件。</p>
<p>（PS：如果是自己添加的文件需要添加包含路径，方法参考u8g2屏幕的配置文档）</p>
<p>为了方便使用，首先把要用到的寄存器在mpu6050.h中进行宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************************</span></span><br><span class="line"><span class="comment"> *设备地址  </span></span><br><span class="line"><span class="comment"> *PS：在数据手册里面的七位地址是0x68，但是HAL库中函数前面的注释有说明如下：</span></span><br><span class="line"><span class="comment"> *DevAddress Target device address: The device 7 bits address value</span></span><br><span class="line"><span class="comment"> *in datasheet must be shifted to the left before calling the interface</span></span><br><span class="line"><span class="comment"> *也就是说我们在使用时要将设备地址左移一位，而0x68左移一位是0xD0。</span></span><br><span class="line"><span class="comment"> **********************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU6050_ADDR 0xD0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//采样频率分频器寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMPRT_DIV_REG 0x19</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//陀螺仪配置寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GYRO_CONFIG_REG 0x1B</span></span><br><span class="line"><span class="comment">//角速度量程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSR1_GYRO 0   <span class="comment">//+-250°/s</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSR2_GYRO 1   <span class="comment">//+-500°/s</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSR3_GYRO 2   <span class="comment">//+-1000°/s</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSR4_GYRO 3   <span class="comment">//+-2000°/s</span></span></span><br><span class="line"><span class="comment">//角速度最低分辨率</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB1_GYRO 16384.0   <span class="comment">//+-250°/s</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB2_GYRO 8192.0   <span class="comment">//+-500°/s</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB3_GYRO 4096.0   <span class="comment">//+-1000°/s</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB4_GYRO 2048.0   <span class="comment">//+-2000°/s</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加速度配置寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACCEL_CONFIG_REG 0x1c</span></span><br><span class="line"><span class="comment">//加速度量程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSR1_ACCEL 0  <span class="comment">//+-2g</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSR2_ACCEL 1  <span class="comment">//+-4g</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSR3_ACCEL 2  <span class="comment">//+-8g</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSR4_ACCEL 3  <span class="comment">//+-16g</span></span></span><br><span class="line"><span class="comment">//加速度最低分辨率</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB1_ACCEL 131.0   <span class="comment">//+-2g</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB2_ACCEL 65.5   <span class="comment">//+-4g</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB3_ACCEL 32.8   <span class="comment">//+-8g</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB4_ACCEL 16.4   <span class="comment">//+-16g</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加速度测量值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACCEL_XOUT_H_REG 0x3B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//温度测量值</span></span><br><span class="line"><span class="comment">//温度计算公式:摄氏度=(int16_t)REG/340+36.53</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEMP_OUT_H_REG 0x41</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//陀螺仪测量值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GYRO_XOUT_H_REG 0x43</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//电源管理寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWR_MGMT_1_REG 0x6B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设备身份标识寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHO_AM_I_REG 0x75</span></span><br></pre></td></tr></table></figure>

<p>定义几个变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int16_t</span> Axo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int16_t</span> Ayo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int16_t</span> Azo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int16_t</span> Gxo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int16_t</span> Gyo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int16_t</span> Gzo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int16_t</span> Temp_RAW = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> Ax,Ay,Az,Gx,Gy,Gz,Temp;</span><br></pre></td></tr></table></figure>

<p>首先对模块进行初始化设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU6050_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> check,Data;</span><br><span class="line">	<span class="comment">//检查设备身份标识(WHO_AM_I)</span></span><br><span class="line">	HAL_I2C_Mem_Read (&amp;hi2c1 ,MPU6050_ADDR,WHO_AM_I_REG,<span class="number">1</span>,&amp;check ,<span class="number">1</span>,<span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">if</span>(check == <span class="number">104</span>)		<span class="comment">//验证设备地址</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//在电源管理寄存器中写入0来使能传感器</span></span><br><span class="line">		Data = <span class="number">0</span>;</span><br><span class="line">		HAL_I2C_Mem_Write (&amp;hi2c1 ,MPU6050_ADDR ,PWR_MGMT_1_REG ,<span class="number">1</span>,&amp;Data ,<span class="number">1</span>,<span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//设置采样频率</span></span><br><span class="line">		Data = <span class="number">0x07</span>;</span><br><span class="line">		HAL_I2C_Mem_Write (&amp;hi2c1 ,MPU6050_ADDR ,SMPRT_DIV_REG ,<span class="number">1</span> ,&amp;Data,<span class="number">1</span>,<span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//设置加速度量程</span></span><br><span class="line">		Data = FSR1_ACCEL;</span><br><span class="line">		HAL_I2C_Mem_Write (&amp;hi2c1 ,MPU6050_ADDR, ACCEL_CONFIG_REG, <span class="number">1</span>, &amp;Data, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//设置陀螺仪量程</span></span><br><span class="line">		Data = FSR1_GYRO;</span><br><span class="line">		HAL_I2C_Mem_Write (&amp;hi2c1 ,MPU6050_ADDR, GYRO_CONFIG_REG, <span class="number">1</span>, &amp;Data, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对几个重要寄存器做一些说明：</p>
<p><strong>1.采样频率分频器：</strong></p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617031200192-1620477659491.png" alt="1617031200192"></p>
<p>采样频率的计算公式为：</p>
<p>​    <strong>采样频率=陀螺仪输出频率/（ 1+SMPLRT_DIV  ）</strong></p>
<p>而陀螺仪的输出频率是受到DLPF（数字低通滤波器）的配置影响的，具体影响如下图：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617031379242-1620477659492.png" alt="1617031379242"></p>
<p>而上述滤波器在配置寄存器中进行设置：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617031435930-1620477659492.png" alt="1617031435930"></p>
<p><strong>2.陀螺仪配置寄存器</strong></p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617031496511-1620477659492.png" alt="1617031496511"></p>
<p>主要功能为触发陀螺仪自检以及陀螺仪最大量程配置，我们主要用到第二个功能。</p>
<p>自检功能：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617031878416-1620477659492.png" alt="1617031878416"></p>
<p>具体量程配置参考下表：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617031692618-1620477659492.png" alt="1617031692618"></p>
<p><strong>3.加速度配置寄存器</strong></p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617031935975-1620477659492.png" alt="1617031935975"></p>
<p>主要功能和陀螺仪配置寄存器一致，我们还是用第二个功能。</p>
<p>自检功能：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617032006471-1620477659492.png" alt="1617032006471"></p>
<p>具体量程配置参考下表：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617032031176-1620477659492.png" alt="1617032031176"></p>
<p><strong>4.测量值寄存器</strong></p>
<p>要用到的测量值寄存器有三个：加速度、陀螺仪和温度。</p>
<p>首先是加速度计：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617032142421-1620477659492.png" alt="1617032142421"></p>
<p>不难看出，数据的存储方式是用了六个字节来存储三个坐标轴的数据，其中相邻两个数据分别表示同一坐标轴数据的高八位和低八位，因此我们可以对数据如此处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义六位数组来存放寄存器值</span></span><br><span class="line"><span class="keyword">int8_t</span> Mesurment[<span class="number">6</span>];</span><br><span class="line"><span class="comment">//将寄存器值读取出来存入数组中方便后续操作</span></span><br><span class="line">HAL_I2C_Mem_Read (&amp;hi2c1 ,MPU6050_ADDR ,ACCEL_XOUT_H_REG ,<span class="number">1</span>,Mesurment ,<span class="number">6</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//以x轴数据为例，应做如下处理：</span></span><br><span class="line">Ax=(<span class="keyword">int16_t</span>)(Mesurment[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)|Mesurment[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//处理后的数据除以LSB（灵敏度最低分辨率）即可得到加速度值</span></span><br><span class="line">Accel=Ax*<span class="number">1.0</span>/<span class="number">16384</span>;</span><br></pre></td></tr></table></figure>

<p>最小分辨率取值参考下表：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617032758704-1620477659492.png" alt="1617032758704"></p>
<p>接下来是陀螺仪：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617280360231-1620477659492.png" alt="1617280360231"></p>
<p>处理方式与加速度相同，最小分辨率参考下表：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617280418367-1620477659493.png" alt="1617280418367"></p>
<p>最后是温度：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617280458545-1620477659493.png" alt="1617280458545"></p>
<p>读出数据需要按照下述公式进行处理：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617349496815-1620477659493.png" alt="1617349496815"></p>
<p><strong>5.电源管理寄存器</strong></p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617280616125-1620477659493.png" alt="1617280616125"></p>
<p>具体各位功能参考数据手册，这里我们想让他正常工作，需要将所有位置0.</p>
<p><strong>6.设备身份标识寄存器</strong></p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617280733301-1620477659493.png" alt="1617280733301"></p>
<p>说明设备地址的寄存器，若AD0接地，则最低位位0，设备地址为0x68;</p>
<p>若AD0置高，则最低位为1，设备地址为0x69.</p>
<p>配置完模块后，只要自己写出函数将数据读出打印出来即可。</p>
<p>以下读取函数仅作参考：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//陀螺仪数据读取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GYRO_READ</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> Mesurment[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">  HAL_I2C_Mem_Read(&amp;hi2c1,MPU6050_ADDR,GYRO_XOUT_H_REG,<span class="number">1</span>,Mesurment,<span class="number">6</span>,<span class="number">1000</span>);</span><br><span class="line">  	Gxo = (<span class="keyword">int16_t</span> )(Mesurment [<span class="number">0</span>] &lt;&lt; <span class="number">8</span> | Mesurment [<span class="number">1</span>]);</span><br><span class="line">	Gyo = (<span class="keyword">int16_t</span> )(Mesurment [<span class="number">2</span>] &lt;&lt; <span class="number">8</span> | Mesurment [<span class="number">3</span>]);</span><br><span class="line">	Gzo = (<span class="keyword">int16_t</span> )(Mesurment [<span class="number">4</span>] &lt;&lt; <span class="number">8</span> | Mesurment [<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">  	Gx = (<span class="keyword">double</span>)Gxo/LSB1_GYRO;</span><br><span class="line">	Gy = (<span class="keyword">double</span>)Gyo/LSB1_GYRO;</span><br><span class="line">	Gz = (<span class="keyword">double</span>)Gzo/LSB1_GYRO;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加速度数据读取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ACCEL_READ</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> Mesurment[<span class="number">6</span>];</span><br><span class="line">	</span><br><span class="line">	HAL_I2C_Mem_Read (&amp;hi2c1 ,MPU6050_ADDR ,ACCEL_XOUT_H_REG ,<span class="number">1</span>,Mesurment ,<span class="number">6</span>,<span class="number">1000</span>);</span><br><span class="line">	</span><br><span class="line">	Axo = (<span class="keyword">int16_t</span> )(Mesurment [<span class="number">0</span>] &lt;&lt;<span class="number">8</span> | Mesurment [<span class="number">1</span>]);</span><br><span class="line">	Ayo = (<span class="keyword">int16_t</span> )(Mesurment [<span class="number">2</span>] &lt;&lt;<span class="number">8</span> | Mesurment [<span class="number">3</span>]);</span><br><span class="line">	Azo = (<span class="keyword">int16_t</span> )(Mesurment [<span class="number">4</span>] &lt;&lt;<span class="number">8</span> | Mesurment [<span class="number">5</span>]);</span><br><span class="line">	</span><br><span class="line">	Ax = (<span class="keyword">double</span>) Axo / LSB1_ACCEL;</span><br><span class="line">	Ay = (<span class="keyword">double</span>) Ayo / LSB1_ACCEL;</span><br><span class="line">	Az = (<span class="keyword">double</span>) Azo / LSB1_ACCEL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//温度数据读取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TEMP_READ</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> Mesurment[<span class="number">2</span>];</span><br><span class="line">	</span><br><span class="line">	HAL_I2C_Mem_Read (&amp;hi2c1 ,MPU6050_ADDR ,TEMP_OUT_H_REG ,<span class="number">1</span> ,Mesurment  ,<span class="number">2</span> ,<span class="number">1000</span>);</span><br><span class="line">	</span><br><span class="line">	Tempo = (<span class="keyword">int16_t</span> )(Mesurment [<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)|Mesurment [<span class="number">1</span>];</span><br><span class="line">	Temp = <span class="number">36.53</span> + Tempo * <span class="number">1.0</span> / <span class="number">340</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此，第一部分结束。</p>
<hr>
<h3 id="DMP库移植"><a href="#DMP库移植" class="headerlink" title="DMP库移植"></a>DMP库移植</h3><p>首先新建一个F401工程，在新工程里面完成IIC和UART的配置。</p>
<p>其中IIC选择IIC1，下拉栏选择IIC，配置默认即可。</p>
<p>生成工程并打开。</p>
<p>先把我们要移植的库文件复制到工程文件夹中：</p>
<p>下载并解压“MPU6050资料”这一文件，文件内容以及具体文件路径在README中有说明。</p>
<p>解压官方库文件“motion_driver_6.12.7z”</p>
<p>复制库文件和包含文件所在的两个文件夹，粘贴到工程文件夹。<img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617352471139-1620477659493.png" alt="1617352471139"></p>
<p>回到keil中，新建文件夹命名为DMP</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617352556822-1620477659493.png" alt="1617352556822"></p>
<p>双击文件夹为其中添加库文件：</p>
<p>记得将文件类型的筛选改成所有文件<img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617352641220-1620477659493.png" alt="1617352641220"></p>
<p>全选eMPL中的6个文件点击添加：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617352677192-1620477659493.png" alt="1617352677192"></p>
<p>接下来添加所需的包含路径：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617352990063-1620477659493.png" alt="1617352990063"></p>
<p>添加这两个文件：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617353030848-1620477659493.png" alt="1617353030848"></p>
<p>接下来添加我们要用到的包含文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inv_mpu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inv_mpu_dmp_motion_driver.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>这时编译一下<del>应该是0 errors</del></p>
<p>咳咳  应该是</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617353398948-1620477659493.png" alt="1617353398948"></p>
<p>那么接下来我们来修改库文件。</p>
<p>打开inv_mpu.c</p>
<p>可以看到这里官方已经为我们写好了F4的接口，只需要我们定义一个宏即可。复制一下宏的内容，打开选项界面选择C/C++，在上面的define中添加预编译的内容，即刚刚复制的宏，顺手把优化改到最低（方便后面出问题调试）：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617353709603-1620477659493.png" alt="1617353709603"></p>
<p>编译：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617353777911-1620477659493.png" alt="1617353777911"></p>
<p>我们来看看这两个错误：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617353828850-1620477659493.png" alt="1617353828850"></p>
<p>都是”board-st_discovery.h”没有找到导致的，这个文件是官方的测试工程中用到的文件，所以直接删除对于我们没有影响。</p>
<p>双击对应的错误传送带对应位置删除宏定义代码，</p>
<p>编译：<del>0 errors！！！</del></p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617354000906-1620477659493.png" alt="1617354000906"></p>
<p>缓缓的打出一堆问号？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？</p>
<p>别急，我们慢慢解决。</p>
<p>首先让我们好好读一下官方的说明：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617354101759-1620477659493.png" alt="1617354101759"></p>
<p>明确的说明了我们需要定义这四个函数来使库正常工作。而下面的宏定义就是留给我们的函数接口，于是我们开始写一下这几个函数。</p>
<p>首先根据网上资料，get_ms函数没什么用，所以下一个空函数防止报错;</p>
<p>delay_ms函数直接调用HAL库的延时函数；</p>
<p>而i2c_read和i2c_write我们通过调用HAL库的IIC函数来实现，需要注意的是HAL库函数与需要的函数参数个数和顺序都不一样。</p>
<p>参考代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空函数防止报错</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mget_ms</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *time)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用HAL库函数</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">i2c_write</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> slave_addr, <span class="keyword">unsigned</span> <span class="keyword">char</span> reg_addr,<span class="keyword">unsigned</span> <span class="keyword">char</span> length, <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">const</span> *data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line">	res=HAL_I2C_Mem_Write(&amp;hi2c1,slave_addr,reg_addr,<span class="number">1</span>,(<span class="keyword">uint8_t</span> *)data,length,<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">i2c_read</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> slave_addr, <span class="keyword">unsigned</span> <span class="keyword">char</span> reg_addr,<span class="keyword">unsigned</span> <span class="keyword">char</span> length, <span class="keyword">unsigned</span> <span class="keyword">char</span> *data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    res=HAL_I2C_Mem_Read(&amp;hi2c1,slave_addr,reg_addr,<span class="number">1</span>,(<span class="keyword">uint8_t</span> *)data,length,<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于之前提到的HAL库IIC地址偏移特性，我们需要把库里面的设备地址改为0xD0:</p>
<p>在inv_mpu.c中搜索0x68:</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617357292231-1620477659493.png" alt="1617357292231"></p>
<p>改为0xD0:</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617357328178-1620477659493.png" alt="1617357328178"></p>
<p>把函数接口改成我们的函数名：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617354938152-1620477659493.png" alt="1617354938152"></p>
<p>记得inv_mpu_dmp_motion_driver.c中的接口也要改：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617355462081-1620477659493.png" alt="1617355462081"></p>
<p>编译，会看到一堆错误中有这样一个画风清奇：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617355116084-1620477659493.png" alt="1617355116084"></p>
<p>这是在提醒我们要定义我们的模块型号，于是在预编译中添加MPU6050：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617355183949-1620477659493.png" alt="1617355183949"></p>
<p>编译：2 errors</p>
<p>我们来看看是什么错误：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617355311309-1620477659493.png" alt="1617355311309"></p>
<p>到inv_mpu_dmp_motion_driver.c中搜索operation看到</p>
<p>__no_operation();</p>
<p>看函数名就知道啥都没做，注释掉。</p>
<p>更改inv_mpu.c中log的宏，用空语句替换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log_i(...)     do &#123;&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log_e(...)     do &#123;&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>编译，0 errors！！！</p>
<p>接下来我们来调用库里面的函数进行模块的初始化以及数据的输出。</p>
<p>添加我们需要的宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN PD */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> q30  1073741824.0f</span></span><br><span class="line"><span class="comment">/* USER CODE END PD */</span></span><br></pre></td></tr></table></figure>

<p>定义我们需要的变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"><span class="keyword">float</span> pitch=<span class="number">0</span>,roll=<span class="number">0</span>,yaw=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">signed</span> <span class="keyword">char</span> gyro_orientation[<span class="number">9</span>] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                           <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">                                           <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br></pre></td></tr></table></figure>

<p>定义我们需要的函数（网上抄的）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN PFP */</span></span><br><span class="line"><span class="comment">//得到dmp处理后的数据(注意,本函数需要比较多堆栈,局部变量有点多)</span></span><br><span class="line"><span class="comment">//pitch:俯仰角 精度:0.1°   范围:-90.0° &lt;---&gt; +90.0°</span></span><br><span class="line"><span class="comment">//roll:横滚角  精度:0.1°   范围:-180.0°&lt;---&gt; +180.0°</span></span><br><span class="line"><span class="comment">//yaw:航向角   精度:0.1°   范围:-180.0°&lt;---&gt; +180.0°</span></span><br><span class="line"><span class="comment">//返回值:0,正常</span></span><br><span class="line"><span class="comment">//    其他,失败</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">mpu_dmp_get_data</span><span class="params">(<span class="keyword">float</span> *pitch,<span class="keyword">float</span> *roll,<span class="keyword">float</span> *yaw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> q0=<span class="number">1.0f</span>,q1=<span class="number">0.0f</span>,q2=<span class="number">0.0f</span>,q3=<span class="number">0.0f</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sensor_timestamp;</span><br><span class="line">	<span class="keyword">short</span> gyro[<span class="number">3</span>], accel[<span class="number">3</span>], sensors;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> more;</span><br><span class="line">	<span class="keyword">long</span> quat[<span class="number">4</span>]; </span><br><span class="line">	<span class="keyword">if</span>(dmp_read_fifo(gyro, accel, quat, &amp;sensor_timestamp, &amp;sensors,&amp;more))<span class="keyword">return</span> <span class="number">1</span>;	 </span><br><span class="line">	<span class="comment">/* Gyro and accel data are written to the FIFO by the DMP in chip frame and hardware units.</span></span><br><span class="line"><span class="comment">	 * This behavior is convenient because it keeps the gyro and accel outputs of dmp_read_fifo and mpu_read_fifo consistent.</span></span><br><span class="line"><span class="comment">	**/</span></span><br><span class="line">	<span class="comment">/*if (sensors &amp; INV_XYZ_GYRO )</span></span><br><span class="line"><span class="comment">	send_packet(PACKET_TYPE_GYRO, gyro);</span></span><br><span class="line"><span class="comment">	if (sensors &amp; INV_XYZ_ACCEL)</span></span><br><span class="line"><span class="comment">	send_packet(PACKET_TYPE_ACCEL, accel); */</span></span><br><span class="line">	<span class="comment">/* Unlike gyro and accel, quaternions are written to the FIFO in the body frame, q30.</span></span><br><span class="line"><span class="comment">	 * The orientation is set by the scalar passed to dmp_set_orientation during initialization. </span></span><br><span class="line"><span class="comment">	**/</span></span><br><span class="line">	<span class="keyword">if</span>(sensors&amp;INV_WXYZ_QUAT) </span><br><span class="line">	&#123;</span><br><span class="line">		q0 = quat[<span class="number">0</span>] / q30;	<span class="comment">//q30格式转换为浮点数</span></span><br><span class="line">		q1 = quat[<span class="number">1</span>] / q30;</span><br><span class="line">		q2 = quat[<span class="number">2</span>] / q30;</span><br><span class="line">		q3 = quat[<span class="number">3</span>] / q30; </span><br><span class="line">		<span class="comment">//计算得到俯仰角/横滚角/航向角</span></span><br><span class="line">		*pitch = <span class="built_in">asin</span>(<span class="number">-2</span> * q1 * q3 + <span class="number">2</span> * q0* q2)* <span class="number">57.3</span>;	<span class="comment">// pitch</span></span><br><span class="line">		*roll  = <span class="built_in">atan2</span>(<span class="number">2</span> * q2 * q3 + <span class="number">2</span> * q0 * q1, <span class="number">-2</span> * q1 * q1 - <span class="number">2</span> * q2* q2 + <span class="number">1</span>)* <span class="number">57.3</span>;	<span class="comment">// roll</span></span><br><span class="line">		*yaw   = <span class="built_in">atan2</span>(<span class="number">2</span>*(q1*q2 + q0*q3),q0*q0+q1*q1-q2*q2-q3*q3) * <span class="number">57.3</span>;	<span class="comment">//yaw</span></span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_self_test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result;</span><br><span class="line">	<span class="keyword">char</span> test_packet[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">long</span> gyro[<span class="number">3</span>], accel[<span class="number">3</span>]; </span><br><span class="line">	result = mpu_run_self_test(gyro, accel);</span><br><span class="line">	<span class="keyword">if</span> (result == <span class="number">0x7</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Test passed. We can trust the gyro data here, so let&#x27;s push it down</span></span><br><span class="line"><span class="comment">		* to the DMP.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">float</span> sens;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">short</span> accel_sens;</span><br><span class="line">		mpu_get_gyro_sens(&amp;sens);</span><br><span class="line">		gyro[<span class="number">0</span>] = (<span class="keyword">long</span>)(gyro[<span class="number">0</span>] * sens);</span><br><span class="line">		gyro[<span class="number">1</span>] = (<span class="keyword">long</span>)(gyro[<span class="number">1</span>] * sens);</span><br><span class="line">		gyro[<span class="number">2</span>] = (<span class="keyword">long</span>)(gyro[<span class="number">2</span>] * sens);</span><br><span class="line">		dmp_set_gyro_bias(gyro);</span><br><span class="line">		mpu_get_accel_sens(&amp;accel_sens);</span><br><span class="line">		accel[<span class="number">0</span>] *= accel_sens;</span><br><span class="line">		accel[<span class="number">1</span>] *= accel_sens;</span><br><span class="line">		accel[<span class="number">2</span>] *= accel_sens;</span><br><span class="line">		dmp_set_accel_bias(accel);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//DMP初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">mpu_dmp_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint8_t</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">int_param_s</span> <span class="title">int_param</span>;</span><span class="comment">//这个没什么用，就是为了能给他实参调用起来</span></span><br><span class="line">	<span class="keyword">if</span>(mpu_init(&amp;int_param)==<span class="number">0</span>)	<span class="comment">//初始化MPU6050</span></span><br><span class="line">	&#123;	 </span><br><span class="line">		res=mpu_set_sensors(INV_XYZ_GYRO|INV_XYZ_ACCEL);<span class="comment">//设置所需要的传感器</span></span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">		res=mpu_configure_fifo(INV_XYZ_GYRO | INV_XYZ_ACCEL);<span class="comment">//设置FIFO</span></span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">		res=mpu_set_sample_rate(<span class="number">100</span>);	<span class="comment">//设置采样率</span></span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">3</span>; </span><br><span class="line">		res=dmp_load_motion_driver_firmware();		<span class="comment">//加载dmp固件</span></span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">4</span>; </span><br><span class="line">		<span class="comment">//res=dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation));//设置陀螺仪方向</span></span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">5</span>; </span><br><span class="line">		res=dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT|DMP_FEATURE_TAP|	<span class="comment">//设置dmp功能</span></span><br><span class="line">		    DMP_FEATURE_ANDROID_ORIENT|DMP_FEATURE_SEND_RAW_ACCEL|DMP_FEATURE_SEND_CAL_GYRO|</span><br><span class="line">		    DMP_FEATURE_GYRO_CAL);</span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">6</span>; </span><br><span class="line">		res=dmp_set_fifo_rate(<span class="number">100</span>);	<span class="comment">//设置DMP输出速率(最大不超过200Hz)</span></span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">7</span>;   </span><br><span class="line">		res=run_self_test();		<span class="comment">//自检</span></span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">8</span>;    </span><br><span class="line">		res=mpu_set_dmp_state(<span class="number">1</span>);	<span class="comment">//使能DMP</span></span><br><span class="line">		<span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在循环前面调用初始化函数，在循环中调用数据处理函数，并打印出欧拉角的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> res;</span><br><span class="line">res = mpu_dmp_init();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">	res=mpu_dmp_get_data(&amp;pitch,&amp;roll,&amp;yaw);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.2f,%.2f,%.2f\n&quot;</span>,pitch,roll,yaw);</span><br><span class="line">   <span class="comment">/* USER CODE END WHILE */</span></span><br></pre></td></tr></table></figure>

<p>串口重定向：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 4 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch,FILE *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HAL_UART_Transmit (&amp;huart1 ,(<span class="keyword">uint8_t</span> *)&amp;ch,<span class="number">1</span>,HAL_MAX_DELAY );</span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 4 */</span></span><br></pre></td></tr></table></figure>

<p>编译烧录，就可以在串口调试助手上看到欧拉角了：</p>
<p><img src="/images/%E8%AE%B0MPU6050%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/1617357509432-1620477659493.png" alt="1617357509432"></p>
<p>如果出现了三个角度全为0的情况，必然是某一环出现的问题，我会将我遇到的问题在之后列举一下，可以自己使用打印对应返回值以及单步调试的方法逐步排查。</p>
<h4 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h4><p>PS：“/”表示不易出现问题，如出现问题可能是硬件问题，检查是否是未供电以及供电电压是否正确，或者可能你的模块坏掉了。</p>
<table>
<thead>
<tr>
<th align="center">函数返回值</th>
<th align="center">mpu_dmp_init函数</th>
<th align="center">mpu_dmp_get_data函数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">/</td>
<td align="center">dmp_read_fifo函数出现问题</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">/</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">/</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">/</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">/</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">/</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">/</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">说明run_self_test函数出现问题</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">/</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">说明mpu_init函数出现问题</td>
<td align="center">/</td>
</tr>
</tbody></table>
<h5 id="run-self-test问题"><a href="#run-self-test问题" class="headerlink" title="run_self_test问题"></a>run_self_test问题</h5><p>进入run_self_test函数内部有一个</p>
<p>mpu_run_self_test函数，将它的result打印出来。</p>
<table>
<thead>
<tr>
<th align="center">result</th>
<th align="center">mpu_run_self_test内部</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x4</td>
<td align="center">加速度计和陀螺仪自检均未通过，考虑为模块损坏</td>
</tr>
<tr>
<td align="center">0x5</td>
<td align="center">加速度计自检未通过，未知原因</td>
</tr>
<tr>
<td align="center">0x6</td>
<td align="center">陀螺仪自检未通过，未知原因</td>
</tr>
</tbody></table>
<p>如果重新连线、改变防止方向（芯片平放）无法解决你的问题，可以试试将后面的条件判断修改为你的值，看看是否可以出数据，但是如果出了数据，对数据的准确性无法做以保证。</p>
<h5 id="mpu-init问题"><a href="#mpu-init问题" class="headerlink" title="mpu_init问题"></a>mpu_init问题</h5><p>这里的问题一般是由于IIC配置错误导致的。</p>
<p>进入函数内不出意外的话程序会在i2c_write返回-1，此时进入函数内部查看返回值：</p>
<p>**HAL_ERROR:**请检查之前的0x68改为0xD0是否有更改。如果更改了，则可能是其他的地方地址出现问题。（检查AD0引脚是否被拉高，若拉高则地址应为0xD1）。</p>
<p>**HAL_BUSY:**硬件IIC会出现的busy锁死问题，这是ST硬件上的一点小问题，可能已经在后续的产品中修复。临时解决办法是把设备完全断电，在不上IIC的情况下上电，清除BUSY位后断电重新插线即可解决问题。</p>
<h5 id="dmp-read-fifo问题"><a href="#dmp-read-fifo问题" class="headerlink" title="dmp_read_fifo问题"></a>dmp_read_fifo问题</h5><p>进入函数内部，不出意外是mpu_read_fifo_stream这个函数处返回了-1，这说明我们读取速度太慢了导致了FIFO溢出，只需要在读取语句之后加上一行代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(mpu_dmp_get_data(&amp;pitch,&amp;roll,&amp;yaw));</span><br></pre></td></tr></table></figure>

<p>在FIFO下次溢出前再次读取即可。</p>
]]></content>
      <categories>
        <category>硬件</category>
        <category>模块</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>MPU6050</tag>
      </tags>
  </entry>
  <entry>
    <title>逐飞常用库函数列举</title>
    <url>/2021/255becb857b2/</url>
    <content><![CDATA[<h2 id="常用用户函数列举"><a href="#常用用户函数列举" class="headerlink" title="常用用户函数列举"></a>常用用户函数列举</h2><p>学习英飞凌TC-264单片机时采用了逐飞的开源库，现将常用库函数总结如下：</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      PWM初始化</span></span><br><span class="line"><span class="comment">//  @param      pwmch       PWM通道号及引脚</span></span><br><span class="line"><span class="comment">//  @param      freq        PWM频率</span></span><br><span class="line"><span class="comment">//  @param      duty        PWM占空比</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:           gtm_pwm_init(ATOM0_CH7_P02_7, 50, 1000);     //ATOM 0模块的通道7 使用P02_7引脚输出PWM  PWM频率50HZ  占空比百分之1000/GTM_ATOM0_PWM_DUTY_MAX*100</span></span><br><span class="line"><span class="comment">//							GTM_ATOM0_PWM_DUTY_MAX宏定义在zf_gtm_pwm.h  默认为10000</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gtm_pwm_init</span><span class="params">(ATOM_PIN_enum pwmch, uint32 freq, uint32 duty)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      PWM占空比设置</span></span><br><span class="line"><span class="comment">//  @param      pwmch       PWM通道号及引脚</span></span><br><span class="line"><span class="comment">//  @param      duty        PWM占空比</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:           pwm_duty(ATOM0_CH7_P02_7, 5000);//设置占空比为百分之5000/GTM_ATOM0_PWM_DUTY_MAX*100</span></span><br><span class="line"><span class="comment">//							GTM_ATOM0_PWM_DUTY_MAX宏定义在zf_gtm_pwm.h  默认为10000</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pwm_duty</span><span class="params">(ATOM_PIN_enum pwmch, uint32 duty)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      校验FLASH是否有数据</span></span><br><span class="line"><span class="comment">//  @param      sector_num 		需要写入的扇区编号   参数范围0-11</span></span><br><span class="line"><span class="comment">//  @param      page_num	 	当前扇区页的编号     参数范围0-1023</span></span><br><span class="line"><span class="comment">//  @return     				返回1有数据，返回0没有数据，如果需要对有数据的区域写入新的数据则应该对所在扇区进行擦除操作</span></span><br><span class="line"><span class="comment">//  @since      v1.0</span></span><br><span class="line"><span class="comment">//  Sample usage:               flash_check(0,0);//校验0号扇区，第0页是否有数据</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">uint8 <span class="title">flash_check</span><span class="params">(uint32 sector_num, uint32 page_num)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      擦除扇区</span></span><br><span class="line"><span class="comment">//  @param      sector_num 		需要写入的扇区编号   参数范围0-11</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  @since      v1.0</span></span><br><span class="line"><span class="comment">//  Sample usage:               eeprom_erase_sector(0);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eeprom_erase_sector</span><span class="params">(uint32 sector_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      编程一页</span></span><br><span class="line"><span class="comment">//  @param      sector_num 		需要写入的扇区编号   参数范围0-11</span></span><br><span class="line"><span class="comment">//  @param      page_num 		需要写入的页编号     参数范围0-1023</span></span><br><span class="line"><span class="comment">//  @param      buf 		   	需要写入的数据地址   传入的数组类型必须为uint32</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  @since      v1.0</span></span><br><span class="line"><span class="comment">//  Sample usage:				eeprom_page_program(0,0, &amp;buf);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eeprom_page_program</span><span class="params">(uint32 sector_num, uint32 page_num, uint32 *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      eru触发dma初始化</span></span><br><span class="line"><span class="comment">//  @param      dma_ch           	选择DMA通道</span></span><br><span class="line"><span class="comment">//  @param      source_addr         设置源地址</span></span><br><span class="line"><span class="comment">//  @param      destination_addr    设置目的地址</span></span><br><span class="line"><span class="comment">//  @param      eru_pin				设置触发的eru通道</span></span><br><span class="line"><span class="comment">//  @param      trigger				设置触发方式</span></span><br><span class="line"><span class="comment">//  @param      dma_count			设置dma搬移次数</span></span><br><span class="line"><span class="comment">//	@return		void</span></span><br><span class="line"><span class="comment">//  Sample usage:</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">uint8 <span class="title">eru_dma_init</span><span class="params">(IfxDma_ChannelId dma_ch, uint8 *source_addr, uint8 *destination_addr, ERU_PIN_enum eru_pin, TRIGGER_enum trigger, uint16 dma_count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      dma启动</span></span><br><span class="line"><span class="comment">//  @param      dma_ch           	选择DMA通道</span></span><br><span class="line"><span class="comment">//	@return		void</span></span><br><span class="line"><span class="comment">//  Sample usage:</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_start</span><span class="params">(IfxDma_ChannelId dma_ch)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      dma停止</span></span><br><span class="line"><span class="comment">//  @param      dma_ch           	选择DMA通道</span></span><br><span class="line"><span class="comment">//	@return		void</span></span><br><span class="line"><span class="comment">//  Sample usage:</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_stop</span><span class="params">(IfxDma_ChannelId dma_ch)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      eru初始化(gpio中断)</span></span><br><span class="line"><span class="comment">//  @param      eru_pin         设置eru通道及引脚</span></span><br><span class="line"><span class="comment">//  @param      trigger         设置触发方式</span></span><br><span class="line"><span class="comment">//	@return		void</span></span><br><span class="line"><span class="comment">//  Sample usage:				eru_init(ERU_CH0_REQ0_P15_4, RISING);//eru通道0 使用P10_7引脚，上升沿触发中断</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eru_init</span><span class="params">(ERU_PIN_enum eru_pin, TRIGGER_enum trigger)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      开启eru中断</span></span><br><span class="line"><span class="comment">//  @param      eru_pin         设置eru通道及引脚</span></span><br><span class="line"><span class="comment">//	@return		void</span></span><br><span class="line"><span class="comment">//  Sample usage:				eru_enable_interrupt(ERU_CH0_REQ0_P15_4);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eru_enable_interrupt</span><span class="params">(ERU_PIN_enum eru_pin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      关闭eru中断</span></span><br><span class="line"><span class="comment">//  @param      eru_pin         设置eru通道及引脚</span></span><br><span class="line"><span class="comment">//	@return		void</span></span><br><span class="line"><span class="comment">//  Sample usage:				eru_disable_interrupt(ERU_CH0_REQ0_P15_4);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eru_disable_interrupt</span><span class="params">(ERU_PIN_enum eru_pin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      获取GPIO基地址</span></span><br><span class="line"><span class="comment">//  @param      pin         选择的引脚 (可选择范围由 common.h 内PIN_enum枚举值确定)</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:           文件内部使用，用户无需关心</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">volatile</span> Ifx_P* <span class="title">get_port</span><span class="params">(PIN_enum pin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      GPIO初始化</span></span><br><span class="line"><span class="comment">//  @param      pin         选择的引脚 (可选择范围由 common.h 内PIN_enum枚举值确定)</span></span><br><span class="line"><span class="comment">//  @param      dir         引脚的方向   输出：GPO   输入：GPI</span></span><br><span class="line"><span class="comment">//  @param      dat         引脚初始化时设置的电平状态，输出时有效 0：低电平 1：高电平</span></span><br><span class="line"><span class="comment">//  @param      pinmode     引脚配置（可设置参数由zf_gpio.h文件内GPIOMODE_enum枚举值确定）</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:           gpio_init(P00_0, GPO, 1, PUSHPULL);//P00_0初始化为GPIO功能、输出模式、输出高电平、推挽输出</span></span><br><span class="line"><span class="comment">//  @note					需要特别注意P20_2是不能用于输出的，仅仅只有输入的功能</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpio_init</span><span class="params">(PIN_enum pin, GPIODIR_enum dir, uint8 dat, GPIOMODE_enum pinmode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      GPIO引脚驱动模式</span></span><br><span class="line"><span class="comment">//  @param      pin         选择的引脚 (可选择范围由 common.h 内PIN_enum枚举值确定)</span></span><br><span class="line"><span class="comment">//  @param      pin_driver 	引脚驱动模式设置</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:           gpio_pin_driver(P00_0, IfxPort_PadDriver_cmosAutomotiveSpeed1)</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpio_pin_driver</span><span class="params">(PIN_enum pin, IfxPort_PadDriver pin_driver)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      GPIO输出设置</span></span><br><span class="line"><span class="comment">//  @param      pin         选择的引脚 (可选择范围由 common.h 内PIN_enum枚举值确定)</span></span><br><span class="line"><span class="comment">//  @param      dat         0：低电平 1：高电平</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:           gpio_set(P00_0, 1);//P00_0 输出高电平</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpio_set</span><span class="params">(PIN_enum pin, uint8 dat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dat) IfxPort_setPinHigh(get_port(pin), pin&amp;<span class="number">0x1f</span>);</span><br><span class="line">    <span class="keyword">else</span>    IfxPort_setPinLow(get_port(pin), pin&amp;<span class="number">0x1f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      GPIO状态获取</span></span><br><span class="line"><span class="comment">//  @param      pin         选择的引脚 (可选择范围由 common.h 内PIN_enum枚举值确定)</span></span><br><span class="line"><span class="comment">//  @return     uint8       0：低电平 1：高电平</span></span><br><span class="line"><span class="comment">//  Sample usage:           uint8 status = gpio_get(P00_0);//获取P00_0引脚电平</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">uint8 <span class="title">gpio_get</span><span class="params">(PIN_enum pin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      GPIO方向设置</span></span><br><span class="line"><span class="comment">//  @param      pin         选择的引脚 (可选择范围由 common.h 内PIN_enum枚举值确定)</span></span><br><span class="line"><span class="comment">//  @param      dir         引脚的方向   输出：GPO   输入：GPI</span></span><br><span class="line"><span class="comment">//  @param      pinmode     引脚配置（可设置参数由zf_gpio.h文件内GPIOMODE_enum枚举值确定）</span></span><br><span class="line"><span class="comment">//  @return     void        </span></span><br><span class="line"><span class="comment">//  Sample usage:           gpio_dir(P00_0, GPO, PUSHPULL);//设置P00_0为推挽输出模式</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpio_dir</span><span class="params">(PIN_enum pin, GPIODIR_enum dir, GPIOMODE_enum pinmode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      GPIO 翻转</span></span><br><span class="line"><span class="comment">//  @param      pin         选择的引脚 (可选择范围由 common.h 内PIN_enum枚举值确定)</span></span><br><span class="line"><span class="comment">//  @return     void        </span></span><br><span class="line"><span class="comment">//  Sample usage:           gpio_toggle(P00_0);//P00_0引脚电平翻转</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpio_toggle</span><span class="params">(PIN_enum pin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      GPT12初始化（编码器采集）</span></span><br><span class="line"><span class="comment">//  @param      gptn         	选择所使用的GPT12定时器</span></span><br><span class="line"><span class="comment">//  @param      count_pin 		设置计数引脚</span></span><br><span class="line"><span class="comment">//  @param      dir_pin     	设置计数方向引脚</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:           	gpt12_init(GPT12_T2, GPT12_T2INA_P00_7, GPT12_T2EUDA_P00_8);//使用T2定时器   P00_7引脚进行计数    计数方向使用P00_8引脚</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpt12_init</span><span class="params">(GPTN_enum gptn, GPT_PIN_enum count_pin, GPT_PIN_enum dir_pin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      GPT12计数读取（编码器采集）</span></span><br><span class="line"><span class="comment">//  @param      gptn         	选择所使用的GPT12定时器</span></span><br><span class="line"><span class="comment">//  @return     int16</span></span><br><span class="line"><span class="comment">//  Sample usage:           	speed = gpt12_get(GPT12_T2);//使用T2定时器</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">int16 <span class="title">gpt12_get</span><span class="params">(GPTN_enum gptn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      清除GPT12计数（编码器采集）</span></span><br><span class="line"><span class="comment">//  @param      gptn         	选择所使用的GPT12定时器</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:           	gpt12_clear(GPT12_T2);//使用T2定时器</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpt12_clear</span><span class="params">(GPTN_enum gptn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      SPI初始化</span></span><br><span class="line"><span class="comment">//  @param      spi_n           选择SPI模块(SPI_1-SPI_4)</span></span><br><span class="line"><span class="comment">//  @param      cs_pin          选择SPI片选引脚</span></span><br><span class="line"><span class="comment">//  @param      sck_pin         选择SPI时钟引脚</span></span><br><span class="line"><span class="comment">//  @param      mosi_pin        选择SPI MOSI引脚</span></span><br><span class="line"><span class="comment">//  @param      miso_pin        选择SPI MISO引脚</span></span><br><span class="line"><span class="comment">//  @param      mode            SPI模式 0：CPOL=0 CPHA=0    1：CPOL=0 CPHA=1   2：CPOL=1 CPHA=0   3：CPOL=1 CPHA=1 //具体细节可自行百度</span></span><br><span class="line"><span class="comment">//  @param      baud            设置SPI的波特率</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:               spi_init(SPI_2, SPI2_SCLK_P15_3, SPI2_MOSI_P15_5, SPI2_MISO_P15_4, SPI2_CS0_P15_2, 0, 1*1000*1000);//硬件SPI初始化  模式0 波特率为1Mhz</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spi_init</span><span class="params">(SPIN_enum spi_n, SPI_PIN_enum sck_pin, SPI_PIN_enum mosi_pin, SPI_PIN_enum miso_pin, SPI_PIN_enum cs_pin, uint8 mode, uint32 baud)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      SPI发送接收函数</span></span><br><span class="line"><span class="comment">//  @param      spi_n           选择SPI模块   (SPI_1-SPI_4)</span></span><br><span class="line"><span class="comment">//  @param      cs_pin          选择SPI片选引脚</span></span><br><span class="line"><span class="comment">//  @param      modata          发送的数据缓冲区地址</span></span><br><span class="line"><span class="comment">//  @param      midata          发送数据时接收到的数据的存储地址(不需要接收则传 NULL)</span></span><br><span class="line"><span class="comment">//  @param      len             发送的字节数</span></span><br><span class="line"><span class="comment">//  @param      continuous      本次通信是CS是否持续保持有效状态 1:持续保持  0:每传输完一个字节关闭CS(一般设置为1 即可)</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  @since      v2.0</span></span><br><span class="line"><span class="comment">//  Sample usage:       		spi_mosi(SPI_2,SPI2_CS0_P15_2,buf,buf,1,1);    //发送buff的内容，并接收到buf里，长度为1字节 通信期间CS持续拉低</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spi_mosi</span><span class="params">(SPIN_enum spi_n, SPI_PIN_enum cs_pin, uint8 *modata, uint8 *midata, uint32 len, uint8 continuous)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------以下宏定义用于延时------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> systick_delay_ms(stmn, time)	systick_delay(stmn, time*1000000)   <span class="comment">//设置延时时间  单位ms</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> systick_delay_us(stmn, time)	systick_delay(stmn, time*1000)      <span class="comment">//设置延时时间  单位us</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> systick_delay_ns(stmn, time)	systick_delay(stmn, time)   		<span class="comment">//设置延时时间  单位ns</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------以下宏定义用于获取当前时间------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> systick_getval_ms(stmn)         systick_getval(stmn)/100000         <span class="comment">//获取当前计时时间  单位ms</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> systick_getval_us(stmn)         systick_getval(stmn)/100            <span class="comment">//获取当前计时时间  单位us</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> systick_getval_ns(stmn)         systick_getval(stmn)*10    			<span class="comment">//获取当前计时时间  单位ns</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      systick定时器启动</span></span><br><span class="line"><span class="comment">//  @param      stmn			选择使用的模块</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:				systick_start(STM0);//记录下当前的时间</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">systick_start</span><span class="params">(STMN_enum stmn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief     获得当前System tick timer的值</span></span><br><span class="line"><span class="comment">//  @param     stmn				选择使用的模块</span></span><br><span class="line"><span class="comment">//  @return    uint32 			返回从开始到现在的时间(单位10ns)</span></span><br><span class="line"><span class="comment">//  Sample usage:               uint32 tim = systick_getval(STM0);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">uint32 <span class="title">systick_getval</span><span class="params">(STMN_enum stmn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      串口初始化</span></span><br><span class="line"><span class="comment">//  @param      uartn           串口模块号(UART_0,UART_1,UART_2,UART_3)</span></span><br><span class="line"><span class="comment">//  @param      baud            串口波特率</span></span><br><span class="line"><span class="comment">//  @param      tx_pin          串口发送引脚</span></span><br><span class="line"><span class="comment">//  @param      rx_pin          串口接收引脚</span></span><br><span class="line"><span class="comment">//  @return     uint32          实际波特率</span></span><br><span class="line"><span class="comment">//  Sample usage:               uart_init(UART_0,115200,UART0_TX_P14_0,UART0_RX_P14_1);       // 初始化串口0 波特率115200 发送引脚使用P14_0 接收引脚使用P14_1</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">(UARTN_enum uartn, uint32 baud, UART_PIN_enum tx_pin, UART_PIN_enum rx_pin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      串口字节输出</span></span><br><span class="line"><span class="comment">//  @param      uartn           串口模块号(UART_0,UART_1,UART_2,UART_3)</span></span><br><span class="line"><span class="comment">//  @param      dat             需要发送的字节</span></span><br><span class="line"><span class="comment">//  @return     void        </span></span><br><span class="line"><span class="comment">//  Sample usage:               uart_putchar(UART_0, 0xA5);       // 串口0发送0xA5</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_putchar</span><span class="params">(UARTN_enum uartn, uint8 dat)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      串口发送数组</span></span><br><span class="line"><span class="comment">//  @param      uartn           串口模块号(UART_0,UART_1,UART_2,UART_3)</span></span><br><span class="line"><span class="comment">//  @param      *buff           要发送的数组地址</span></span><br><span class="line"><span class="comment">//  @param      len             发送长度</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:               uart_putbuff(UART_0,&amp;a[0],5);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_putbuff</span><span class="params">(UARTN_enum uartn, uint8 *buff, uint32 len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      串口发送字符串</span></span><br><span class="line"><span class="comment">//  @param      uartn           串口模块号(UART_0,UART_1,UART_2,UART_3)</span></span><br><span class="line"><span class="comment">//  @param      *str            要发送的字符串地址</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:               uart_putstr(UART_0,&quot;i lvoe you&quot;);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_putstr</span><span class="params">(UARTN_enum uartn, <span class="keyword">const</span> int8 *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      读取串口接收的数据（whlie等待）</span></span><br><span class="line"><span class="comment">//  @param      uartn           串口模块号(UART_0,UART_1,UART_2,UART_3)</span></span><br><span class="line"><span class="comment">//  @param      *dat            接收数据的地址</span></span><br><span class="line"><span class="comment">//  @return     void        </span></span><br><span class="line"><span class="comment">//  Sample usage:               uint8 dat; uart_getchar(UART_0,&amp;dat);       // 接收串口0数据  存在在dat变量里</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_getchar</span><span class="params">(UARTN_enum uartn, uint8 *dat)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      读取串口接收的数据（查询接收）</span></span><br><span class="line"><span class="comment">//  @param      uartn           串口模块号(UART_0,UART_1,UART_2,UART_3)</span></span><br><span class="line"><span class="comment">//  @param      *dat            接收数据的地址</span></span><br><span class="line"><span class="comment">//  @return     uint8           1：接收成功   0：未接收到数据</span></span><br><span class="line"><span class="comment">//  Sample usage:               uint8 dat; uart_query(UART_0,&amp;dat);       // 接收串口0数据  存在在dat变量里</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">uint8 <span class="title">uart_query</span><span class="params">(UARTN_enum uartn, uint8 *dat)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      ADC初始化</span></span><br><span class="line"><span class="comment">//  @param      adcn            选择ADC模块(ADC_0、ADC_1、ADC_2)</span></span><br><span class="line"><span class="comment">//  @param      ch              选择ADC通道</span></span><br><span class="line"><span class="comment">//  @return     void</span></span><br><span class="line"><span class="comment">//  Sample usage:               adc_init(ADC_0, ADC0_CH0_A0);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adc_init</span><span class="params">(VADCN_enum vadc_n, VADC_CHN_enum vadc_chn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      ADC转换一次</span></span><br><span class="line"><span class="comment">//  @param      adcn            选择ADC模块(ADC_0、ADC_1、ADC_2)</span></span><br><span class="line"><span class="comment">//  @param      ch              选择ADC通道</span></span><br><span class="line"><span class="comment">//  @return     转换值</span></span><br><span class="line"><span class="comment">//  Sample usage:               adc_convert(ADC_0, ADC0_CH0_A0, ADC_12BIT);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">uint16 <span class="title">adc_convert</span><span class="params">(VADCN_enum vadc_n, VADC_CHN_enum vadc_chn, VADC_RES_enum vadc_res)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//  @brief      ADC均值滤波</span></span><br><span class="line"><span class="comment">//  @param      adcn            选择ADC模块(ADC_0、ADC_1、ADC_2)</span></span><br><span class="line"><span class="comment">//  @param      ch              选择ADC通道</span></span><br><span class="line"><span class="comment">//  @param      count           均值滤波次数</span></span><br><span class="line"><span class="comment">//  @return     平均转换值</span></span><br><span class="line"><span class="comment">//  Sample usage:               adc_mean_filter(ADC_0, ADC0_CH0_A0, ADC_12BIT, 5);//采集5次 然后返回平均值</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">uint16 <span class="title">adc_mean_filter</span><span class="params">(VADCN_enum vadc_n, VADC_CHN_enum vadc_chn, VADC_RES_enum vadc_res, uint8 count)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>单片机</category>
        <category>infineon</category>
        <category>函数库</category>
      </categories>
      <tags>
        <tag>智能车</tag>
      </tags>
  </entry>
  <entry>
    <title>那些授课中“隐秘的角落”</title>
    <url>/2021/087e2aa47655/</url>
    <content><![CDATA[<p>经过了一年的学习之后，当笔者自己要亲手进行授课的时候，发觉到有些东西当初似乎解释的并不明确，特在此解释一下。</p>
<span id="more"></span>

<h2 id="工程是个什么东东"><a href="#工程是个什么东东" class="headerlink" title="工程是个什么东东"></a>工程是个什么东东</h2><p>无论是使用Keil、CubeMX还是以后可能会涉及的Clion，开始写代码之前总有一步叫做新建工程，那么工程是什么呢？</p>
<p>抛开又大又空的理论不谈，工程（Project）是什么其实很好理解，就是将你想要做的东西进行一个封装，形成一个易于移植的、与外界耦合度较低的独立个体。用实物举一个简单的小例子：</p>
<p>你要做一辆小车，那么<code>“小车”</code>就是工程的名字，而工程中用到的组件可能包括<strong>轮子、电机、驱动以及小车的外壳</strong>，这些东西之间有很强的耦合性，他们相互作用共同组成了小车这个工程，而这整个工程与外界的耦合度并不高，所以你的小车可以随处乱跑，无论拿到宿舍还是教学楼都可以正常工作。</p>
<p>在硬件中是这样，软件中也是这样。</p>
<p>你新建了一个名为<code>Car</code>的工程，在为其写代码的过程中你可能会用到单片机接口库、电机驱动库等等，他们之间耦合度很高，但是整个工程与你的电脑之间只是一个简单的存储的关系，所以整个工程文件夹可以随意在不同电脑之间迁移并且都可以正常工作。</p>
<blockquote>
<p><strong>言外之意：</strong></p>
<p>当你希望别人在他的电脑上运行或者测试你的工程时，<strong>请将整个工程文件夹打包发给对方</strong>，而不是仅仅将main.c里面的代码复制然后把文本发过去或者仅仅将main.c文件发过去。</p>
</blockquote>
<h2 id="CubeMX中某些不起眼的点"><a href="#CubeMX中某些不起眼的点" class="headerlink" title="CubeMX中某些不起眼的点"></a>CubeMX中某些不起眼的点</h2><h3 id="Pinout-amp-Configuration"><a href="#Pinout-amp-Configuration" class="headerlink" title="Pinout &amp; Configuration"></a>Pinout &amp; Configuration</h3><p>当你想得知自己配置的引脚还有没有相同功能的复用引脚时，可以试试按住Ctrl然后拖动已经设置的引脚，拥有相同复用功能的引脚就会闪烁，只要在其上放开即可。</p>
<h3 id="Clock-Configuration"><a href="#Clock-Configuration" class="headerlink" title="Clock Configuration"></a>Clock Configuration</h3><p>选择完时钟源之后可以直接在某个频率设置中输入频率，按下回车即可由CubeMX为你配置已知的解决方案。</p>
<h3 id="Project-Manager"><a href="#Project-Manager" class="headerlink" title="Project Manager"></a>Project Manager</h3><p><img src="/images/%E9%82%A3%E4%BA%9B%E6%8E%88%E8%AF%BE%E4%B8%AD%E2%80%9C%E9%9A%90%E7%A7%98%E7%9A%84%E8%A7%92%E8%90%BD%E2%80%9D/image-20211027165955063.png" alt="image-20211027165955063"></p>
<p>用于设置集成环境工具链，笔者使用Keil故选择MDK-ARM。</p>
<p><img src="/images/%E9%82%A3%E4%BA%9B%E6%8E%88%E8%AF%BE%E4%B8%AD%E2%80%9C%E9%9A%90%E7%A7%98%E7%9A%84%E8%A7%92%E8%90%BD%E2%80%9D/image-20211027170242510.png" alt="image-20211027170242510"></p>
<p>用于设置工程代码的最小堆栈大小</p>
<p><img src="/images/%E9%82%A3%E4%BA%9B%E6%8E%88%E8%AF%BE%E4%B8%AD%E2%80%9C%E9%9A%90%E7%A7%98%E7%9A%84%E8%A7%92%E8%90%BD%E2%80%9D/image-20211027170729456.png" alt="image-20211027170729456"></p>
<blockquote>
<ul>
<li>将所有用到的函数库拷贝到工程文件夹</li>
<li>仅拷贝必要的库文件</li>
<li>将必要的库文件添加到工具链的工程配置文件作为参考</li>
</ul>
</blockquote>
<p>学习的过程中建议选择第三个，以便使用过程中参考库函数代码。</p>
<p><img src="/images/%E9%82%A3%E4%BA%9B%E6%8E%88%E8%AF%BE%E4%B8%AD%E2%80%9C%E9%9A%90%E7%A7%98%E7%9A%84%E8%A7%92%E8%90%BD%E2%80%9D/image-20211027171359513.png" alt="image-20211027171359513"></p>
<blockquote>
<ul>
<li>为每个外设生成一对“.c/.h”文件</li>
<li>重新生成时备份初始生成的文件</li>
<li>重新生成时保留用户代码</li>
<li>删除未重新生成的以前生成的文件</li>
</ul>
</blockquote>
<p>建议勾选图中的三个，有助于规范化工程中的文件结构。</p>
<h2 id="MDK工具链下的工程文件夹结构"><a href="#MDK工具链下的工程文件夹结构" class="headerlink" title="MDK工具链下的工程文件夹结构"></a>MDK工具链下的工程文件夹结构</h2><p>来看一个典型的工程个文件夹的文件树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\APPLICATION_DATA\CLION_PROJECTS\EXAMPLE</span><br><span class="line">│  .mxproject			//CubeMX工程配置文件</span><br><span class="line">│  Example.ioc			//CubeMX工程文件（点击打开CubeMX</span><br><span class="line">├─Core				//工程核心代码文件夹</span><br><span class="line">│  ├─Inc					//工程核心代码-头文件夹</span><br><span class="line">│  │      gpio.h </span><br><span class="line">│  │      main.h </span><br><span class="line">│  │      stm32f4xx_hal_conf.h </span><br><span class="line">│  │      stm32f4xx_it.h </span><br><span class="line">│  └─Src					//工程核心代码-源文件夹</span><br><span class="line">│          gpio.c </span><br><span class="line">│          main.c </span><br><span class="line">│          stm32f4xx_hal_msp.c </span><br><span class="line">│          stm32f4xx_it.c </span><br><span class="line">│          system_stm32f4xx.c </span><br><span class="line">└─MDK-ARM			//MDK工程文件夹</span><br><span class="line">        Example.uvoptx				//MDK工程配置文件夹</span><br><span class="line">        Example.uvprojx				//MDK工程文件（点击打开Keil</span><br><span class="line">        startup_stm32f401xc.s			//初始化代码</span><br></pre></td></tr></table></figure>

<h2 id="CubeMX模板生成的代码结构"><a href="#CubeMX模板生成的代码结构" class="headerlink" title="CubeMX模板生成的代码结构"></a>CubeMX模板生成的代码结构</h2><blockquote>
<p>可能没什么必要的<strong>前置小知识：</strong></p>
<p>C语言中用<code>/*被注释内容*/</code>来表示段注释；</p>
<p>​              用<code>//被注释的内容</code>来表示行注释。</p>
</blockquote>
<p>观察CubeMX生成的代码不难发现其中的注释很大一部分都是一样的，这些注释其实是<strong>十分科学地分配了用户写代码时的代码结构</strong>。</p>
<p>忽略其中一些无用的部分，我们将大体的框架拿出来看一看：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">！！首先最先强调的一个问题：</span><br><span class="line">！！用户代码应该写在Begin和End之间，即：</span><br><span class="line">！！<span class="comment">/* USER CODE BEGIN xxxx */</span>和<span class="comment">/* USER CODE END xxxx */</span>之间，</span><br><span class="line">！！否则将导致的后果是：你的代码会在下一次重新生成时被删除。</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Header */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//书写用户头（依照Doxygen的注释形式，在官方信息的基础上添加文件信息）</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END Header */</span></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private includes ----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//书写用户头文件包含</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private typedef -----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PTD */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//书写用户变量重命名</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END PTD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private define ------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PD */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//书写用户替换宏定义</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END PD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private macro -------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PM */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//书写用户宏</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END PM */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables ---------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//书写用户变量定义</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes -----------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PFP */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//书写用户函数声明</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END PFP */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private user code ---------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//书写函数定义等一些不属于以上分类的内容</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 1 */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//书写一些函数比HAL初始化更底层的函数调用</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MCU Configuration--------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Init */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//书写用户MCU初始换代码</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END Init */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Configure the system clock */</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN SysInit */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//书写用户系统初始化代码</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END SysInit */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//一般用于书写外设或其他功能初始换代码</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//书写while（系统已经生成）</span></span><br><span class="line"><span class="comment">//书写循环中代码</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//书写循环中代码</span></span><br><span class="line"><span class="comment">//书写与前方循环对应的括号（系统已生成）</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 4 */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//常用于书写函数定义</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END 4 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Error_Handler_Debug */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//用户添加自己的错误处理代码</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END Error_Handler_Debug */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 6 */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//用户添加自己的断言处理代码</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* USER CODE END 6 */</span></span><br></pre></td></tr></table></figure>

<h2 id="关于我用CubeMX快速找到芯片资料那些事"><a href="#关于我用CubeMX快速找到芯片资料那些事" class="headerlink" title="关于我用CubeMX快速找到芯片资料那些事"></a>关于我用CubeMX快速找到芯片资料那些事</h2><p>选过芯片之后可以通过CubeMX来快速获得所选的芯片的各种资料：</p>
<p><img src="/images/%E9%82%A3%E4%BA%9B%E6%8E%88%E8%AF%BE%E4%B8%AD%E2%80%9C%E9%9A%90%E7%A7%98%E7%9A%84%E8%A7%92%E8%90%BD%E2%80%9D/image-20211027200753561.png" alt="image-20211027200753561"></p>
<p>资料很全，F401的资料如图：</p>
<p><img src="/images/%E9%82%A3%E4%BA%9B%E6%8E%88%E8%AF%BE%E4%B8%AD%E2%80%9C%E9%9A%90%E7%A7%98%E7%9A%84%E8%A7%92%E8%90%BD%E2%80%9D/image-20211027200952936.png" alt="image-20211027200952936"></p>
<h2 id="点点点是在干什么"><a href="#点点点是在干什么" class="headerlink" title="点点点是在干什么"></a>点点点是在干什么</h2><p>第一次接触CubeMX的大家可能还搞不懂我们点来点去是在干嘛。</p>
<p>简单地说，我们的每一次点击都会对单片机的寄存器进行一次配置，而右面的图片其实就是一个放大了的单片机，上面的每一个引脚都对应着单片机上面的一个引脚。</p>
<h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><p>笔者学习语文的时候就经常听到一句话：<strong>字体是一个人的脸面</strong></p>
<p>现在笔者在写代码，不得不说，代码的格式甚至也可以上升到程序员脸面的地步。</p>
<p><strong>什么样的代码格式算是好的呢？</strong></p>
<p>有一个很有趣的注释：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A few days ago, only God and I understood my code. </span></span><br><span class="line"><span class="comment">//Now only God understands it.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>几天前只有上帝和我能看懂我的代码，现在只有上帝懂了。</p>
</blockquote>
<p>好的代码不应该是这样的，而应该是傻子都可以理解作者的意图。</p>
<p>换句话说，代码格式至少应该<strong>清晰明了、整洁统一</strong>，若能<strong>将逻辑结构划分开来</strong>则为更好。</p>
<p>直观地来感受一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个简单的时间片轮询函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskDicision</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TaskNum(taskList); i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (taskList[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">taskList[i]-&gt;taskTimer += ITperiod;</span><br><span class="line"><span class="keyword">if</span> (taskList[i]-&gt;taskTimer &gt;= taskList[i]-&gt;taskTimePiece) </span><br><span class="line">&#123;</span><br><span class="line">	taskList[i]-&gt;taskTimer = <span class="number">0</span>;</span><br><span class="line">		taskList[i]-&gt;taskHandler();</span><br><span class="line">&#125;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个简单的时间片轮询函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskDicision</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TaskNum(taskList); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (taskList[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            taskList[i]-&gt;taskTimer += ITperiod;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (taskList[i]-&gt;taskTimer &gt;= taskList[i]-&gt;taskTimePiece) &#123;</span><br><span class="line">                taskList[i]-&gt;taskTimer = <span class="number">0</span>;</span><br><span class="line">                taskList[i]-&gt;taskHandler();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该不用多说什么，可读性高下立判。</p>
<p>当然这其实是一个相对较极端的例子，一般的使用中我们很少会用这么多层的括号互相嵌套。但是即使是少层的内容嵌套也需要一个良好的格式，主要是遵循以下几点其实就可以写出漂亮的代码：</p>
<ul>
<li>在每层花括号内部进行缩进</li>
<li>对于<code>for</code>或者<code>if</code>之类的有明显逻辑结构的语句即使并没有用到花括号也最好进行缩进</li>
<li>在不同的代码功能之间最好以换行来进行分隔</li>
</ul>
<h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><p>代码注释一直是一个非常值得探讨的话题。</p>
<p>不仅仅是由于你的代码是否有注释决定了别人能否读懂你的代码，更是由于能否读懂别人的注释决定了你是否能够读懂别人的代码。</p>
<p>提到代码注释就不得不提的东西叫做”Doxygen“，它可以根据代码之中的注释来为工程生成一个详尽的文档，而程序员所需要付出的代价很简单：按照Doxygen的注释标准来编写注释。</p>
<p>就是因为很多开源库都在使用Doxygen（没办法，<del>给的实在是太多了</del>太好用了），以至于Doxygen的注释标准甚至成为了一种几乎公用的良好注释标准。</p>
<p>其实HAL库中的很多注释都是基于Doxygen的注释标准的，因此了解这种注释标准对大家读懂注释有很大帮助。</p>
<p>由于全写完篇幅有点长，所以大家可以自己看看<a href="https://www.cnblogs.com/schips/p/12200388.html">这篇文章</a>。</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>内容补充</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>“一些关于电赛的小碎碎念”</title>
    <url>/2021/726e7273fa90/</url>
    <content><![CDATA[<p>电赛啦！电赛啦！虽然是迟到的电赛，但是我还是对它非常期待的，毕竟可以见证一下这一年来我自己的努力成果了。难得的机会，写点废话吧，也算是作为电赛的总结了。</p>
<span id="more"></span>

<h2 id="暑假阳光下训练的傻孩子们"><a href="#暑假阳光下训练的傻孩子们" class="headerlink" title="暑假阳光下训练的傻孩子们"></a>暑假阳光下训练<del>的傻孩子们</del></h2><p>电赛的训练最早是暑假就开始了，为了参加集训我甚至一个暑假没有回家。<del>食堂真是太难吃了</del></p>
<p>但是令人没想到的是今年学校对于自控队伍的训练约等于没有，所以在训练期间我们一直在做一些往年的题目来提高技术水平。</p>
<p>这期间不得不提的就是：还好我们试着做了<strong>板球控制系统</strong>。在做这道题目的时候我们发现树莓派处理图像有很大的时延，并不满足板球控制系统的要求，因此迫使我们学习了OpenMV。而OpenMV在正式的电赛中也确实发挥了很大的作用。</p>
<p>除了OpenMV之外还有点小收获就是控制器：</p>
<p>我们采用了TM4作为主控，用以防止电赛自控题目出现限制单片机的情况。为了使用方便，我在使用过程中对一些外设功能进行了二次封装，虽然写的代码很屎，但是还是很好用的，已经开源在了我的GitHub中的<a href="https://github.com/Zhewana/TM4C123G_UserInterface">TM4C123G_UserInterface</a>仓库中，代码中含有详尽的注释，无论是别人使用还是我自己后面再看都有很大帮助。</p>
<p>就在当时所谓的电赛前两天，我们整个队伍<strong>搬家</strong>到了比赛的教室，结果熟悉了一天环境后得知了电赛推迟的消息：</p>
<p><img src="/images/%E2%80%9C%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%94%B5%E8%B5%9B%E7%9A%84%E5%B0%8F%E7%A2%8E%E7%A2%8E%E5%BF%B5%E2%80%9D/1636725764552.jpg" alt="电赛延期通知"></p>
<p>就这样，<strong>在暑假阳光下训练的傻孩子们被电赛放了鸽子。</strong></p>
<p>不过虽然大部分同学都回家了，我们队伍仍然没有回家。不是因为想留下训练，实在是因为再没有比暑假更适合做自己的项目的时间了，因此我们三个人分别开始玩起了自己的东西：sjj的平衡车、yqy的独轮车还有我自己的无人机（虽然至今未完成），项目进度我写在了<a href="https://zhewana.cn/2021/21928eec9c6c/">这篇文章</a>里面，现在开学应该是龟速更新，只能等到寒假的时候才能接着玩自己的项目了（叹气</p>
<h2 id="对第二次延期习以为常的傻孩子们"><a href="#对第二次延期习以为常的傻孩子们" class="headerlink" title="对第二次延期习以为常的傻孩子们"></a>对第二次延期习以为常<del>的傻孩子们</del></h2><p>有了第一次延后的经验，大家开始对于电赛延期习以为常了，也就是在这样的心情下，我们对于得到的电赛延期消息其实十分平静，然后继续做手中没做完的项目。</p>
<p><img src="/images/%E2%80%9C%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%94%B5%E8%B5%9B%E7%9A%84%E5%B0%8F%E7%A2%8E%E7%A2%8E%E5%BF%B5%E2%80%9D/IMG_20211112_222312.jpg" alt="电赛延期"></p>
<p><img src="/images/%E2%80%9C%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%94%B5%E8%B5%9B%E7%9A%84%E5%B0%8F%E7%A2%8E%E7%A2%8E%E5%BF%B5%E2%80%9D/Cache_-608aa07ee7805407..jpg" alt="电赛安排"></p>
<h2 id="带着平静心情打电赛的傻孩子们"><a href="#带着平静心情打电赛的傻孩子们" class="headerlink" title="带着平静心情打电赛的傻孩子们"></a>带着平静心情打电赛<del>的傻孩子们</del></h2><p>日子一点一点地过，我们当时对于电赛的执着其实已经被磨得不能更平了。</p>
<p>从一开始的见到材料清单<strong>疯狂猜题</strong>，比赛前一晚<strong>睡不着觉</strong>，到后来的见到比赛赛题<strong>内心毫无波动</strong>，平静的开始进行分工，相信无论是队友还是我自己，我们都有了很大的提升。</p>
<p>电赛开始，看到赛题我们几乎毫不犹豫地选择了F题：<a href="https://www.nuedc-training.com.cn/index/news/details/new_id/259">智能送药小车</a>。</p>
<blockquote>
<p>题目太长就不放图了，可以点进超链接去看。</p>
<p>另：单片机工程上传到了蓝奏云，需要自取吧：</p>
<p><a href="https://wwe.lanzoui.com/iBR4owffy3e">https://wwe.lanzoui.com/iBR4owffy3e</a><br>密码:ae4w</p>
</blockquote>
<p>写这段内容的时候我们已经完成了电赛的测评，结果还算满意。下面的内容大概是对这四天三夜的一些回顾、吐槽还有反思（都是废话）：</p>
<h3 id="第一天-昼"><a href="#第一天-昼" class="headerlink" title="第一天 - 昼"></a>第一天 - 昼</h3><p>拿到赛题，秒选F题，我立刻开始新建工程担任了单片机程序的撰写任务。</p>
<p>与此同时，yqy负责硬件开始搭建两辆小车，sjj负责视觉开始撰写代码。</p>
<p>此时的方案选择是：</p>
<p>硬件：<strong>四轮小车</strong></p>
<p>单片机平台：<strong>STM32</strong></p>
<p>视觉：<strong>OpenMV</strong></p>
<blockquote>
<p>小惊喜：其实我自己有一辆小车不过两个队友一直不知道，电赛了想着拿来作为备用小车，可谁知道最后竟然刚好要用两辆小车，我们三人直接狂喜。</p>
</blockquote>
<p>单片机平台选择是我们最熟悉的STM32，在工程中使用了一些我自己平时写的库：</p>
<p>调试信息输出库：<a href="https://github.com/Zhewana/DebugLogger">DebugLogger</a></p>
<p>时间片轮询框架：<a href="https://github.com/Zhewana/TimePiece">TimePiece</a></p>
<p>其中时间片轮询框架在电赛后我自行进行了一些功能上的完善，上传的是完善后的版本，这部分后面再说。</p>
<p>在队友搭车的同时，我将电机、舵机的底层驱动以及速度环、转向环PID调节算法全部撰写完毕，刚好这时队友将第一辆车搭完了，开始简单的软硬件联调+调节速度环PID。</p>
<p>接着和视觉队友沟通了一下两边的通信协议，完成了通讯协议的解析程序；</p>
<p>为了将OpenMV装上车子，yqy专门3D建模量身定做了一个支架；</p>
<p>接着sjj完成了红线循迹程序，于是开始将OpenMV装到车上开始进行初步联调。</p>
<p>大概一天就这么结束了。</p>
<h3 id="第一天-夜"><a href="#第一天-夜" class="headerlink" title="第一天 - 夜"></a>第一天 - 夜</h3><blockquote>
<p>有关晚上的内容大概仅限于对睡觉环境的吐槽吧…</p>
</blockquote>
<p>第一题天在活室睡觉，我打开了活动室内的一张折叠床（据说是某学长留下的）打算美美的睡一觉：</p>
<p><img src="/images/%E2%80%9C%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%94%B5%E8%B5%9B%E7%9A%84%E5%B0%8F%E7%A2%8E%E7%A2%8E%E5%BF%B5%E2%80%9D/1636727634880.jpg" alt="折叠床"></p>
<p>我在早上两点美美的入睡了，但是却收到了反噬：有一只蚊子在我身边飞来飞去（/(ㄒoㄒ)/~~</p>
<p>以为会做个美梦，但是这次睡觉经历我见到人就会这样吐槽：<strong>就像睡在楼梯上面一样</strong></p>
<p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAsJCQcJCQcJCQkJCwkJCQkJCQsJCwsMCwsLDA0QDBEODQ4MEhkSJRodJR0ZHxwpKRYlNzU2GioyPi0pMBk7IRP/2wBDAQcICAsJCxULCxUsHRkdLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCz/wAARCAC0AJEDASIAAhEBAxEB/8QAHAABAAIDAQEBAAAAAAAAAAAAAAUGAQQHAwII/8QAQBAAAQMDAwIEBAIIBAQHAAAAAQIDBAAFEQYSITFBE1FhcRQigZEVMiNCcqGx0eHwBxZSYiUzwfFFRlZjkqPT/8QAGQEBAAMBAQAAAAAAAAAAAAAAAAECAwQF/8QAHxEBAQACAwEBAQEBAAAAAAAAAAECEQMhMRIiE0Ey/9oADAMBAAIRAxEAPwDrdKUoFKUoFKZxXk8/HYQpbzzTaAlayp1aUJCUDcpWVeXU0HrkedeanWQXAXGx4Y3OArSNgxuyvJ4GOa51dtQuX+a9Gtc+Q1ZoTcZTjkTxI7s+Q6C5guEJcDSRjgYzk8kYqPZt8Fh0voaUXylSVOOuOOuHcSVEqcJJJ7k56Y6VjlyzG6aY8dq7Oaz0kgrH4gtxLa9jzrESW6y0e29xDZT7c9697ZqS0XSU5DjmU2+lsvtpmMLj+O0FhBW0HOTgkZBAPI45qmjjGAByVYHAyRgnj6VryoUSYAXW/wBIhKksupO15kqwd7SxyFAgEH0+lZTn77jS8PXrq2R5ilc9Y1DqOE+0885+IwgpSZEdLDDcttvaT4kdaNoJTxlJBJHfPBvUOXFnxosyI4HI0lpLzDicgKQoAg4PPvXRjlMvGOWNx9bFRl4vNusrLbssuqcfX4USNGbL0uW6Bnw2GU8k+Z6DPJ5qTqnagj6qj3pu6We1Rbm25aRBUl+Qhh2MtLynCWlKUOF5G7jnA8ubqtCVD1NqxJavGLXaFLQsWuHsemvbfmBlSSCE+yR/CsG8Wi0oRY9OQ13OZGBS3EguKXGig5AXLlrJGM9fmz7VEXRr/Fe5KjNP2IM28K2yIdvuDTPxeecPPh0ubccEAj9/CFcdcWloRY+gUMxGkKVsh+MlRUcgKK9y9x8+MnzFay4zxDeOl5t6lMXDVchp9xvPg263gtQ2QP1VOJw4o+fzD3NWxKAhKEJACUJCE+iRwE/Tt/1qlnVmsmi34uhrgApTWfD+JJ2qzwn9EefLyrB13c23ltSNH3hspU4jaguqXlJwRhTAGfOrzLFGl2586VSv853j/wBJXv8A+K//AM6VP3DTqXFOKUrmWOKcUpmg0Ltc4tpgSZ0gKKGglKG28F155xQQ200D1UokAf0rm8xD16mu3C8sxHFOMMx48VKPEahsoWpe1K3SdyiT8x2jp5VOaylmVcLNZkNoxEUzfn3FqJykF6M20hCRjOSVZJ7DAPaLA/d5/wA65ubPXUb8WMvdPU9cAfYYrIx9aY9vvSuTboKzkVjnHH76ZNA9R2IPHmPKtvT12RZJ0qJLIbtN0lsmE4VgNxZzrai6lYUeEOEAg/6j0+bjU5rXlRWJjD8d8DY42tO8hJU2SD86NwwCOef+4148vmq54zKOqgg8jGDyCDnNZwKh9NPy5Nisj8tba5DsJlbimihSDkHaApvKTgYBIqYrujiYwKY9qzSpGMDzoB61mlA/vqaUpQKUpQKwTgEkgDByT0A8zWai77c/we03O5BAcXGbHgoUSEqedWllsLI527lDPpmg5+ub+LXa+XROExXnGIcTBSd7ENJR4gI55UVkHPQjyNeucff91fKGygL3IZQ6tSnJAjshlovLOXClscAZ/vmvqvO5LvKu7DHWOmf76U/lWvLlNQo70p0KLbRaSdoGcuOJbGST05r7YfRIEsoSoCNLfiuE4PzNKxnjz4NU1dJ3Hqe1P5VkEHA7VjafT7miWKHB64PfkEj67eaEYr66KBAzjB9OOe3NSVPaAUU2m4xnOJMW8z0SkNqBjtuOlMgJjAdG8KHHY5q31Q9CrVFl6ltYGGUvs3Fjn83jjatWVALJJAKzkgcJHQ1fBXo4+ODLqlKUqyClKUClKUClKUCq1rdezTdzSTtaedgRpKuPljvS2m3Tz6EjPbOe3Flqna+P/C7W2XENh++wW1LVsJSPDeJxvIT2AOexI6nIi+JiCwBxkADAGDkcDgDk/wAadTgZJ86fKAABgDASB0SBxisfXrXmf7t3S9IS8B1woZlKkOwCRIMS3Rd7i0MlKyqS+4vASOuBjP0r5Y+AmXVuREhtA/DRZ7sh555txaX0rCVIYR8hIxySf4VOqGQoHkKBSRnjB4NeUeLEioQ3HaQhKG0tDAydiSSEknkgZOK0+586UuO7t7fQ/cV9Z/hXzyMUzz9qyaMeprPOPXPHb954rwlzIkFrxZDhG9QbZbbBW884eiGkDkmo1yfeWvg5MiNFYhvzY0P4bcpyWA+VAKU5kNBQwMjaevpWmOFyVyykXHQxRId1RLLAS4m4NQ0OvJ2SSy0wghpTe44QCSUdM5yck5q7DoKqWgWWxZX5W1fjzbjOdkOOrU4twodUygeKoAKCUgAFIA44q216GPUcV7pSlKlBSlKBSlKBSlKBXPdYKK9SWWPIBMf8HmuRAsAtqkqfSh0AHjdt29uhPnXQqp+vojrtrgzW2C6LTdYtwlFrHxCISUrQ6pnv3SVDIyE+lVym5U43VQJ8/TtWBivll1p9pp5pQU08hLjaxnCkKAUCMj+/pX1z1rzda6dsZ4rI45rH25onqknnBzgdwOoFNbqQ8+/livGVJZhMOSHtxSjaEoQMuOuKO1DTY7qUeB/SoqK7d1fgKX0SApcq8Imqc+RJQjPh79wHHTB/jitqIy5c5S7o4FGDDW7GtSFJwhxafldl4PmcpRnsM+tazCzuq/W+o+YMJ9bxuVy2rnuJCW0DGyC32Za7Z/1H+z6TGG59w0lalBwifeEvO+GsoV4ERsrWUqTyOufpWw9KjMLaaKwXXHEsobQQVElSQc9hgHJ/rW1pln47WMh/cktWO0JQBtORJnKJJGf9u6tOPeWXavJZjj06DAgxLdFjwojYajR07GmwVK2jqcqUSoknJJJ6mtknGBjOa+VrS2lS1qQlCEqWtSyAlKUjJUSeMDvXOr1fZmoVmNAcdjWDlLshsqafuwPylLZ4UlnqCeqvQGum2Y+uWS29LFL1xpaJJVGD70nwXEtTH4TRdiQySBl9/IRxn5sFWOc4xVlSpKgFJIKVAEEHIIPIINccvCWIdgurbTaG2UxfAbShIACnFIbAAHc9K6zbm3GrfbGnP+Y1DituftpaSDVcM/ubWzx+em3SlK0UKUpQKUpQK1Lg029BuTTgyl2HKbUPD8XKVNqTjw+/t3+tbdYOMe3NBx+yOoMBhr4tmQ5HR4a1NuKWpCR+RC0uBLiTjAwQMY74ydx+QhlSY7aHH57zbrkaFHSpyQ9tSVD5UA4T/uOB/wBfqVaLrG1HdbXbFRX3rm+bkuW8tbrlsiukblzElsbllW4NDxTnAyABVwtdmtFgjyHUlRc8Iv3K4STvkyA2kqUt1w84GCQBgDy71zXim+3T/T89KQ/InQnkszrZLakP4TAjtqaecmOZ27WQ2T6kk8AYzzwZeJpO9zwHrzdHYLawD+HWVSWylOc7XZpSVKPZWBjyNSmn4qpy16ouDZ+PubeYDa//AA61knwWW92QFKB3OEdSrt337zdlW1uIzGjGXdLi6uNbIaSEBxxKSpTjxzkNoHKiPbvxMwkvSuWV120mtE6OSQr8JQ+scFct2TJUec5JdWRUs5bmDgbNmAlKUhJCAkDG0DgfaqDeb3YbfJWxqW93i6XFPEi32FxUK2wl/m8EBtxskjoSXFHjnB4r0st6sN1KWdO3e6Wu7I3iJBvcpyXCmHO/wlIecWCO2QpKh2zjFa3FnOTSxu6UtL0tM1Q3SUupfQTkoSsN+DuSjIHIP7h5VDW12bpG4annXW1XB6JdJyHG7hbwiUlqO3lDSH2kkOADPXHp72ayXlF3jOqWyqLOhvqh3KE4QVxJKOCAe6VdUnuPapbHpj24qs6q1/UUe6Xg6nYV8Gp1vTTe5cmS6lTJuS28ktAKwQwj9cn8xBHQZVHsPNyEJdQkgcpCSBvQAPlCgOhKcHHUA4NX2Tb4EuM5FeYbMdzbvaA2IISsOdEY4yASO/1qCRpWNDEgw3HD47ynVJfcUrbkn5Enpge2e5JrLklyXw/PSqXNoy39O2oKGbneoTbvG4+AyfFXgeny5rrwx/KudRYTg1zY2Q28G7ZZps1a9v6Mrkkxxzj27/q10JTrTeze4hHiOJbRvUlO5auQhOe/pW3HPnHTPku8n3SlK0ZlKUoFKUoFR94ubFnts+5PJUtMZsFDaASt55xQbaaSB3UogfWpCqjflrn6k0pZAAWI/j6jnA9SIuWYwIHbec+4HlUXo9bOn7Y9b4i35uF3e6OfH3d3qVSXBkNJzyENjCUjoMepz56vcW1pjUZRnLkL4fg4G2Q6hhXPso1O9PfPv79a0bxbxdrTdrbuCDNiOsIWr8qHVDLalegVgmsd7rXzptttoZbQ02kJQ0lLKAnoEITtSB7cCqpepEmPd9UTWMfF2fRiXLcCAVNqkvPqdeSk5GRsTn2x3qbsVw/ErbFfcTskoColwaJBUxNjnwnm1exBI9896075FlNSol8iMKlKixn4F0hJALk21vHK0NDuts5UkZ5yR1PNsbqmXcfnd1SlOLUvcoqJUorUVKKjySVHkkmsNrdaWhxtSkONqQ42tGQpC0kFKkkc5Bq9zP8AD964qenaSlxbhbluK2sLc8GXEUSD4DqHscpz3wfTz3LRoT8FcZvGr5USFb4Skvpi+Klx2S8g7ko+XjrjgZJ6VqxT0x6RF1S8W1Ft6dpy0zLhsXgmWhSmsqxwTjH2qTGpTbkJcnLddbU4hltttPiSn3lHAajoHJUe1V+MuVcJ13vsptbLt1dQY7DgG6PCZGxltYHG4jBP9a9G5TcB3Veo3mkvK01BhwrW26kFtE24BJU6R1/WQDg9M+fPP/1yN5+MO1leuupQEOyntO6djuDcy3eXTLnrSOiloQ600M9wCcefHP2Lzd4sZq5Pfhd3tCUAS5dhLiZEfb+Z3wHFrStAHKgFBQ64IrgU6ZKuEuTLmPLfkPuLccdXypaifsB5ADipDTt+uNhuEaVFcWW1OoRLjlSvBksK+VSHEDg8dOODW+p4x+q7rcYjlzjxLxYZiG7m2wHLdKSSY0yMs7zGlJHVtR6d0k5GORUWiZJu0iDeYkSRNuBD9vgwJKAzbdPzmkpRKcnOAlRXnO3AyRwMbtw2NNoFuu2sbE0CIUGVDnwGudrLNwaLpaQOgSCDgeteze626yQ2hW2LqW3PPqaBO38RtxQlTgB4ypBGf2e/asurpfW5taWEvpbZD6kKeDaA6psFKFLCRuKQecE5wP5V60pV1ClKUDinFKUDtVQtgMnVmtp6gcRRa7NHJHKEIZ+JdwfIlQOP7Fvqn6ZX4k3Xq8/+aZbWPINR2myfKq5eJnqyGnanWlYxb/VZujM+yz3tQW9pyTDkpbTf4DKcuLDY2pnRkjjxEjhY7j1GRPQ5kG4xmZsGQ3IivjKHWjlJ77VdwR3HXitn+8jrUGqwtRJ7tzs7xhPPb1TYaABAnqKFBJeQPyqzjKk8+hqZd9VZ7T9P2C5OoflwkKkIBSHmXHo735t2C5HUknnzzWn/AJP0whfjtwQZQIKJEl1+S4gjptL61Yx2r5/zXEiKQxqCHLsshSggOSUKet7qv/ZmMgpx+0B61YGXWJDTchh1t5hwZQ8ytDjSh5pWglJ+9T2dKm/Z57SuGytO7hSeeOgJqLXb/Ddu9suO6Pb9WxmYrUp0Zai3eMD4aV7iD842lOT1TjvXQ68JcSJOjPxJjKH4z6Sh5pwbkrB55z9wc8fSq4Y/N2tldzT84Xiw3yyyXI9whPtKStQS4EKLLqQcBbawNpB96m9HaVn3S4RZsthTFmgOomzpUlJbaU2x+kLad+M5xyRwBnnseui0X2HtatN+KIaB8sa7RRcS2SSSEyFuJfx5Ak4rydsF3uSkIv19XLgBQUbZAipgRHsdEvqStTqk9DgqxwPrv9RjqvLSpcnSdTakWFpZvk5tNvC8gmBBSthpzB6bsqIrYlhErWWlmUpO612q7XJ4jICUy1IitAn1IXj+8yk+dbLLCVKlrRHhsJS2hCUgFZHCWY7Y5Kjj5QBWhpiBPK7rfro2WrjfXmnhHP5ocFpO2PGUf9QHK+nPbI5rJu7WvU0s/FOKUq6hxSlKBzTmlKB5fSqfpjaJWukhIBGq56lZJyd7TJB/jVwqn2hSo+ptdwVgfpJFturP+9EiOGVY9imq5eJiyU57DNfO9AJyoD0NZGFFIyOSBxnjJxWMu15GfP8AvFZ5qOs8t+dHmSXVBSVXO5txgkAbYzMhTDYOP2f31I+1Ss83mmX21svtNutLGFodQlaFDyUlQxVfVpC1svqk2d+dZZKzuUq1PFEdwjoHIzu5oj02irJgmhBHB456Hg/apmxDMJ1VDjPJkOQbs8lbQjkJ/DXFtc71PLSHGyocYwgDg+fGs5fb9HW58RpK5raQfkct8yFL3jofkyhXsMVYeBx9+KVH0hXhqSYsnZpTU/QqBdahtDhJVglT3HSvKJctY36NHlWuBb7XBkth1ibc5HxkhbahgLbixgEA/tLqwTHfAhzngkHwYkp3B4BKGVLAz9K0tGtrb0tphKxgm2RXMHycT4iT9iKvjJe1K+IWmIrctq5XOXJu90a5Zkzynw4xPX4SM2A0gH2J9asWPSlK0VOac0pQOaUpQKUpQKpOoybZqbT913JS1cokqwyDkDDoV8XHUQeOoI/71dqr+rrO5erLLjsY+Ojqbn25XXEqMd6R0/WGU/X0qL4meoV+a/yoE8JJUVH8o8z5V4xdVW1t9ttV0gKWF7Qj4to5UDnGQrHp171BMuRL7AiuyULU3v3yI61LCEyUApWh5HGdp6Z+3l7LhWxSfCXBhuJxkM+EwklI44yMexrjt1dV02bnSV01dks6csjac7yw46tRUclbr7q1E/epJF6dzyrgHnPXb9apWnXAq2NtbVoVDfkxSlwgLQlLhUlKxyQcHnn+sxk8g53Dj1z5GmWVlTjOm9qO8qlMQbNDW4l66KWuatpSkuNW6PhTm1SOQVkhGfLNRUWO3AcW7BU9HkuJCVyGlkyFpSc4cW7u3DOCQc5x6VEPx2JV+kCeHAl2DHbt6UOutJfbbyXhllQyoEg4Jr7kIlWlPxUeQ9IgtOJTPiSXC8phsHYXWnSdwKc8gk1bLd1JUTU2vGm73LuLt/hTVIW9bZEfa6lCWwtiS0HUJUlOBlOCCcc8GrAHmCcbuftXNbQ6tq4aqcQSEvTYjOSTz4EVIAPfvU81LKjuUo5B7D6d6XKTpHzvtIaylGNpe/KaBU7JYRb2EpGVLcmrTHwn1wTVkgxkQ4cGIgAIixmIyAOAEtNpbGM+1UeYtV1uujrMUrKROcv03B/IxAR+hCxj8qlnH0roA58+tdGHjDL0pTIzivhLrKytKHEKUj86ULSopz5gHNXVfdKcUoFKUoIbT1/gaht7c6LlCwotSo6z+kjPjq2sHB9jjn9wmcg1QtQwn9LXFWsLU0pcV1Qb1JCaOEvMqOPiUDBG4HlXTz/WJq7RJUebHjS4yw5HktNvsrHRbbiQpJH0oPesY9azSgqF60s8px+fYTHYmvul6bGk5+FmuHqvcn5kOeo4Pcd6rEiy63kuRi1p9EaXHWlTcpdzjrjlsq/SNOBI3KQodsdRn0rq2BWMDy59qrcJbtaZWTTlUqx3vT7wuc0tSItwQVXY29lYat8pAwhzBJWWyOFKx2ycV8sPqelyGm3EOxvhojzSmihQQp1S0EBYyPmwCOa6vgcjHaq7K0XpWS65IRDchyHDlx22SH4RWckkqSwoIPU/q96zy4pbtfHksc0eE64XCDboifi58O/SXI+xxDSxCZZS46FuH5QBnZkjqMdTX3IjX7xWrNOgPW83Z24zJTynWXXFQw7uLbWwqSnOUgkn6efVLPpuw2LxzbogbdkHMh9xa3pDxyVfO66SrrUfqvTsq9sxnYEpEW5Q0SWmHHUktOsyUeG4y7tycHgjg8ip+JpH3uqfAEJEZBikfDrWtQWtSsuKK9hWVucnJ6E9eMda3UqShK3FK8NDSVuuLPRtCAVFZ9KiJcHUkcWiNL03chHhvh1wWwNzmXgw2WmAktqBHODhQHQGpKDYb/qJ1LVxgyLXYUOb5TckhE+4FGClopT+VGevt68YfytybXkmkxoiEqWq6aokNqQu6rEW2IX1atUfCWzg85WQVH2B71dv318MtNstoabQlDbaUNtoQkJQhCQEhKQOMDtUVqS6O2i0y5MdO+c6W4Vtb4JcnSVeC0AD1wTuI8kmuuTXTl9VrUd2+Odlsjxl2aBKbt640VZbevd3cJQmGlYP/KQfz9MkHqE86knT/wAMkPydPqhOAb0T9KPKW9GOMfOlpKHzj0QselbOlrWmTcGHQSu16YbcgQnDkpnXhwYmzcnk4OUpPPUkV0DA8qkc7tuotSw0qWHmNSWxkkOrjBLF6jJHGHGOAojyKQTVwtF+s18aW7b5KXC2Sl9lY8OSwpJ2lLzKvnB+lfF009ZbotMh5lbM5CdrU6EtUeYgHt4reCR6KyPSqZeNN3mK4Zi23rn4I3NXSzqRB1DHSnJwptGGXQPofSg6Tn0NK454N5/1f4j/AP0/zpQdgeZZkNOMPIStl9C2nUK/KtC0lKkn3qk/4bPvqtt7hKWpUe2XmXFhJUSS0xncEAnnA5xSlBeqUpQKUpQKUpQKYHlSlAwKYFKUCud6/kyWp9q8Nwp+CsuobnHAxhExplLTb2DxlIUdvkTmlKC26bixodhsLEdsIbTb4ywB3U4gOrUfUkkn3qXpSgUNKUGMmlKVKz//2Q==" alt="生气"></p>
<p>四点钟我醒了一次，是被冻醒的，然后翻了个身接着睡，早上六点就实在忍不住，起来了。</p>
<p>这绝对是我主动起床<strong>最早</strong>的一次了。</p>
<p>就这样，第二天开始了。</p>
<h3 id="第二天-昼"><a href="#第二天-昼" class="headerlink" title="第二天 - 昼"></a>第二天 - 昼</h3><blockquote>
<p>后面几天的内容其实并没有什么好说的，基本都是软硬件在联调，然后发现各种各样的问题并且解决各种各样的问题</p>
</blockquote>
<p>依照之前的四轮小车的方案，我们大概做了第一个要求，此时就发现四轮车在行进的时候还要进行<strong>倒车</strong>和<strong>复杂的路线规划</strong>，这样整个系统的<strong>稳定性会直线降低</strong>，同时时间上也会有很大程度的浪费。</p>
<p>虽然但是我们仍在努力克服这些问题。联调的时候顺便确定了一些视觉任务的细节，比如：对十字的识别、对于T形路口的识别以及对于赛道终点（虚线）的识别。</p>
<p>同时还有一个遗留问题一直在困扰着我们：<strong>如何检测200g药品被放上了车子，</strong>暂时还没有明确的方案。</p>
<p>刚好有同一个实验室的同学和我们同时想到了两轮加万向轮的方案，于是我们立即更换方案：</p>
<p>yqy开始更改整辆车的硬件，sjj继续写视觉代码，我则将原来代码中用不到的底层驱动删除并且将PID算法稍作修改以适应双驱动车的循迹。</p>
<p>最终大概搭出了一辆简单的三轮小车（图片下方正面向前方的）：</p>
<p><img src="/images/%E2%80%9C%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%94%B5%E8%B5%9B%E7%9A%84%E5%B0%8F%E7%A2%8E%E7%A2%8E%E5%BF%B5%E2%80%9D/Cache_1b0a1f5b2da315d0..jpg" alt="简单的三轮小车"></p>
<p>这个时候其实已经大概下午了，视觉那边遇到了数字识别的难点，于是我们三个人一起研究了很久，一天大概也就这样结束。</p>
<p>对了，必须要说的是谢谢指导教师送我们的披萨，真的很好吃！</p>
<p><img src="/images/%E2%80%9C%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%94%B5%E8%B5%9B%E7%9A%84%E5%B0%8F%E7%A2%8E%E7%A2%8E%E5%BF%B5%E2%80%9D/OIP-C.wHJO60ojTAdwUX6DsoEJjAAAAAw=136&h=180&c=7&r=0&o=5&dpr=1.1&pid=1.7" alt="Image result for 小豆泥表情包"></p>
<h3 id="第二天-夜"><a href="#第二天-夜" class="headerlink" title="第二天 - 夜"></a>第二天 - 夜</h3><p>调车到大概四五点钟，我和队友都回去睡觉了。</p>
<p>有了第一天的教训，我绝对坚决拒绝再睡在那张床上面。我天真地以为趴在桌子上应该能获得比在床上更好的睡眠效果，但是事实是我完全错了：</p>
<p>穿着厚厚的马夹，戴着帽子，我睡了一小时就醒了，醒来的时候肚子里面鼓鼓的，感觉全是气体……</p>
<p>睡眠不足的虚弱感不断冲击着大脑，整个脑子浑浑噩噩的，整个人大概处于一个<strong>行尸走肉</strong>的状态：</p>
<p><img src="/images/%E2%80%9C%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%94%B5%E8%B5%9B%E7%9A%84%E5%B0%8F%E7%A2%8E%E7%A2%8E%E5%BF%B5%E2%80%9D/OIP-C.4uTgIsr3qsQ96bpioLFTTQAAAAw=129&h=177&c=7&r=0&o=5&dpr=1.1&pid=1.7" alt="行尸走肉"></p>
<p>站起来到外面走了一圈，看到了我未曾看到过的南邮日出。内心没有狂喜，没有紧张，<strong>不如说是什么都没有</strong>。转身回到活动室，队友们还在睡觉，听着大家的呼吸声，我意识到我才睡了一小时多应该再睡会，于是趴在桌子上闭上了眼，一会之后仍无法入睡，于是再次起身到走廊走了一圈……</p>
<p>上面的过程被我像一块单片机一样执行了记不清多少次（我知道这种比喻很奇怪），我不知道自己在干什么，只是走的次数多了整个人就会变得更清醒一点。直到再晚些sjj醒过来了，大概我的神智才恢复了一些，没过多久yqy也醒了于是我们商量了下决定去吃早饭。</p>
<p>吃早饭的路上我提出下午想回宿舍好好的睡一觉，因为我意识到我个人的消耗已经太大了，队友也同意了。</p>
<p>不过吃完饭之后（也可能是生物钟到了），我整个人开始变得精神起来。</p>
<p>就这样，第三天开始了。</p>
<h3 id="第三天-昼"><a href="#第三天-昼" class="headerlink" title="第三天 - 昼"></a>第三天 - 昼</h3><p>到了这时候，已经能够为车子实装上数字识别了，并且开始真正意义上的软硬件全面联调。</p>
<p>判断药品有了一个很好的方案：<strong>使用装满螺丝的大试管作为药品，</strong>并且由yqy为其量身建模一个试管架，<strong>在试管架下面放上微动开关</strong>，即可通过开关的闭合与否来判断是否有药品放入（这应该是电赛期间我们的一个<strong>高光设计</strong>了）；</p>
<p>送药的过程中发现一些小问题：有些本应转弯的地方被循迹算法影响导致没法表现出我们想要的转弯效果，于是在程序的状态机结构中添加了循迹算法的屏蔽框架；</p>
<p>后续的测试中发现仅仅屏蔽循迹算法然后阻塞延时是不够的，因此又添加了一点简单的非阻塞延时代码；</p>
<p>视觉方面则是发现了一些会相互之间误识别的元素，并对他们做了一些处理。</p>
<p>虽然说着不多，但是中间过程非常艰辛，仅仅发现上述问题就花了很长时间，毕竟问题表现出来的现象往往是无原因的不正常，我们只能在一堆代码中一点一点找问题出在了哪里。</p>
<p>大脑转着转着，一天就这样结束了。</p>
<h3 id="第三天-夜"><a href="#第三天-夜" class="headerlink" title="第三天 - 夜"></a>第三天 - 夜</h3><p>白天的时候听了yqy推荐，我发现了一个良好的睡觉地方：<strong>一张黑色的大椅子</strong></p>
<p><img src="/images/%E2%80%9C%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%94%B5%E8%B5%9B%E7%9A%84%E5%B0%8F%E7%A2%8E%E7%A2%8E%E5%BF%B5%E2%80%9D/1636727634871.jpg" alt="一张黑色的大椅子"></p>
<p>只要整个人躺在上面然后把jio伸出去再找一张矮一些的椅子来垫jio就可以了。</p>
<p>最后一天肯定是要冲刺一下的嘛，所以一直肝到了早上。</p>
<p>早上五点钟，我尝试了一下之前说的方法，不得不说这种方法睡得比前两天都要舒服，不过到了早上六点我还是准时醒了过来（作息规律了属于是），整个人还是一种浑浑噩噩的状态，但是比前一天的行尸走肉应该好多了（大概</p>
<p>依然是等队友醒过来然后出去吃了早饭，接着开始了这最后一天。</p>
<h3 id="第四天-昼"><a href="#第四天-昼" class="headerlink" title="第四天 - 昼"></a>第四天 - 昼</h3><p>最后一天了，整体的功能已经成型了，不过还有一些小细节需要完善。</p>
<p>大概是视觉上<strong>提高了T字路段的识别率</strong>，机械结构上进一步做了一些优化，单片机程序上对一些特殊情况做了一点处理。</p>
<p>解决完这些之后，我们开始搭起第二辆车。开始第二辆车调试的时候其实大概已经下午了，不过好在发挥题目对第二辆车子的要求不是很高，因此我只是在第一辆车的状态机上面稍微改改就获得了第二辆车的代码。</p>
<p>晚上八—-点~（请自行脑部大姨的声线</p>
<p><img src="/images/%E2%80%9C%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%94%B5%E8%B5%9B%E7%9A%84%E5%B0%8F%E7%A2%8E%E7%A2%8E%E5%BF%B5%E2%80%9D/TY%7DRDL@4P50SJ_DUYVX%25_O.jpg" alt="成品"></p>
<p><strong>收工！</strong></p>
<h3 id="吐槽题目"><a href="#吐槽题目" class="headerlink" title="吐槽题目"></a>吐槽题目</h3><p>对于F题甚至是对于整个今年的电赛题目，我相信肯定会有很多人想要吐槽一些什么。我只做了F题，对于其他题目也不好信口开河，就来吐槽一下F题的槽点吧：</p>
<ol>
<li>图像在整个题目中起着决定性作用</li>
<li>题目的区分点在单片机上</li>
</ol>
<p>单纯的看这两点其实都不是一个良好的槽点，但是这两点同时出现就成为了最大的槽点：</p>
<p><strong>明明图像在整个题目中起着决定性作用但是题目的区分点却在单片机上</strong>，与此同时单片机的内容又十分简单，并没有什么区分度。</p>
<p>这就直接导致了绝大部分参赛队伍只有两种结果：要么<strong>全部做完</strong>，要么<strong>一个题目都做不了</strong>。</p>
<p><img src="/images/%E2%80%9C%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%94%B5%E8%B5%9B%E7%9A%84%E5%B0%8F%E7%A2%8E%E7%A2%8E%E5%BF%B5%E2%80%9D/OIP-C.8fWpleql9uKQPVatjwUxiQAAAAw=158&h=142&c=7&r=0&o=5&dpr=1.1&pid=1.7" alt="气"></p>
<h3 id="单片机程序"><a href="#单片机程序" class="headerlink" title="单片机程序"></a>单片机程序</h3><p>懒得再开一篇博客来讲这东西了（主要是还有一堆东西还没写完，所以就顺手一起写了），所以就在这里大概讲一下参赛作品的单片机程序框架吧（写的挺屎的，欢迎大佬提出宝贵建议）</p>
<p><img src="/images/%E2%80%9C%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%94%B5%E8%B5%9B%E7%9A%84%E5%B0%8F%E7%A2%8E%E7%A2%8E%E5%BF%B5%E2%80%9D/OIP-C.vmjIAHN3zzklE-GiCMQ3GAHaHaw=180&h=180&c=7&r=0&o=5&dpr=1.1&pid=1.7" alt="好奇"></p>
<p>首先需要的功能显而易见：<strong>点灯</strong>、<strong>按键检测</strong>、<strong>电机驱动</strong>、<strong>串口通信</strong>还有<strong>编码器使用</strong>。</p>
<p>为了使程序更有条理使用了一些常见的代码框架（或者说程序设计方式？）：<strong>状态机</strong>、<strong>时间片轮询</strong>还有<strong>数据流处理</strong>（我也不知道是不是这么叫</p>
<p>首先显而易见的是主循环里面一直在跑小车的状态机，然后在一个1kHz的定时器中断回调函数中部署了时间片轮询架构以对其进行时分复用，实现一种类似OS的效果。</p>
<p>在时间片轮询框架中执行了4个任务：</p>
<ul>
<li>PID控制（10ms</li>
<li>状态检测（2ms</li>
<li>日志输出（10ms</li>
<li>非阻塞延时的计时（2ms</li>
</ul>
<p>PID控制是需要有实时性保证的，这点用过的大家都知道。</p>
<p>与OpenMV的通信是用串口接收中断来做的，中断里面放入了使用流处理方式的协议解析程序，每次运行完解析程序都会对所需的变量进行赋值，状态检测任务其实就是实时检测这些变量以便获得当前的路况信息，方便状态机进行跳转。</p>
<p>日志输出任务看名字其实就很容易理解了，就是在调试的时候把一些需要输出的数据进行输出，当然<strong>最后realease版本的时候是要删除的</strong>。</p>
<p>非阻塞延时计时任务仅对一部分有非阻塞延时需求的代码服务，为其提供计时功能，以便能够实现非阻塞延时。</p>
<blockquote>
<p>也正是电赛期间发现了对于非阻塞延时和任务屏蔽的硬性需求，我才在自己的时间片轮询框架中添加了单任务和多任务的非阻塞延时功能以及任务屏蔽的功能。</p>
</blockquote>
<h2 id="测评时一句话都不敢乱说的傻孩子们"><a href="#测评时一句话都不敢乱说的傻孩子们" class="headerlink" title="测评时一句话都不敢乱说的傻孩子们"></a>测评时一句话都不敢乱说的<del>傻孩子们</del></h2><p>真的是第一次参加电赛测评，整个人紧张的不行不行的。</p>
<p>测评前有半小时的时间给我们进行准备和尝试，我和队友商量了一下大概整个流程应该怎么进行，包括但不限于谁发车、谁放置药品、谁录像以及谁取下药品等等。但是真的等到专家接入我们的测评会议室的时候真的是<strong>一切从简</strong>，之前的流程完全抛到脑后，唯一脑子里面还记得的就是把jio离车子远一点。</p>
<blockquote>
<p>PS：测评当天我没脑子的穿了一双红色的鞋子，会造成图像的误识别，好在最终并没有什么影响。</p>
</blockquote>
<p>测评基础第一题，第一次我们的车子跑的还好，只是有一些出线，测评的专家好心的让我们又测评了一次，至于第二次是什么结果我只记得跑完了，似乎还是有点压线来着。</p>
<p>测评基础第二题，同样是第一次有点压线，不过第二次跑的很完美，于是专家记录了我们的最好成绩。</p>
<p>测评基础第三题，两次都冲出赛道了，后面分析了一下觉得可能是因为贴数字的时候把数字贴的鼓起来了，导致摄像头没法看到数字。</p>
<p>测评发挥第一题，第一次就能够完整的跑下来，不过压线的现象有点严重，第二次两辆车都很完美的完成了题目，看到两辆车停下来的时候真的整个人都松了一口气。</p>
<p>不得不说上面的测评我们的运气都非常好，因为我们的数字识别其实有那么几个数字会以极高的概率（几乎是100%）被误识别，但是专家在选择数字的时候完全避开了我们的问题数字。所以其实能够到这一步我们就很满足了。</p>
<h2 id="继续平静生活的傻孩子们"><a href="#继续平静生活的傻孩子们" class="headerlink" title="继续平静生活的傻孩子们"></a>继续平静生活的<del>傻孩子们</del></h2><blockquote>
<p>写下这段话的时间是2021年的12月13号，差点忘记了手头还有这么一篇文章等着完结。</p>
</blockquote>
<p>比赛完之后就是等待时间，好在等待时间也不是很漫长。</p>
<p>11月26日出了省奖名单，我们运气还不错，获得了一等奖A的推优资格，但是我们学校的推优人数有点多，所以我们本来就已经满意的准备拿省一了。不巧的是，12月3号最终还是发出了国奖的名单，我们惊喜的发现我们通过了复测，拿到了国二的成绩。</p>
<p>也没有多么多么的振奋人心，我们依然继续着之前平静的生活。</p>
<p>继续玩着自己想玩的东西，仍然日常在给学弟学妹们讲课的时候翻车，唯一不同的是：</p>
<p><strong>下次参加比赛的我们将抱着必拿国一的决心。</strong></p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>废话</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>The GNU Linker部分译文</title>
    <url>/2021/c906435d6fa7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学习链接脚本，一方面是为了填外部FLASH的坑，另一方面是想自己搞一搞IAR到Clion的开发环境移植，故参考《The GNU Linker》将与链接脚本相关的部分借助翻译工具进行了简单的翻译。</p>
<span id="more"></span>

<h2 id="3-链接脚本"><a href="#3-链接脚本" class="headerlink" title="3 链接脚本"></a>3 链接脚本</h2><p>每个链接都由<strong>链接脚本（linker script）</strong>控制。此脚本是用链接器命令语言编写的。</p>
<p>链接器脚本的主要目的是描述如何将输入文件中的<strong>段（sections）</strong>映射到输出文件，并<strong>控制输出文件的内存布局</strong>。大多数链接器脚本只做这些。但是，必要时，链接器脚本还可以使用下面描述的命令指示链接器执行许多其他操作。</p>
<p>链接器始终使用链接器脚本。如果您自己没有提供，链接器将使用编译到链接器可执行文件中的默认脚本。可以使用<code>--verbose</code>命令行选项显示默认链接器脚本。某些命令行选项（如<code>-r</code>或<code>-N</code>）将影响默认链接器脚本。</p>
<p>您可以使用<code>-T</code>命令行选项来提供自己的链接器脚本。执行此操作时，<strong>您提供的链接器脚本将替换默认链接器脚本</strong>。</p>
<p>您还可以通过将链接器脚本<strong>命名为链接器的输入文件</strong>来隐式使用链接器脚本，就像它们是要链接的文件一样。</p>
<h3 id="3-1-基本链接脚本概念"><a href="#3-1-基本链接脚本概念" class="headerlink" title="3.1 基本链接脚本概念"></a>3.1 基本链接脚本概念</h3><p>为了描述链接器脚本语言，我们需要定义一些基本概念和词汇表。</p>
<p>链接器将多个输入文件合并到单个输出文件中。输出文件和每个输入文件都采用称为对象文件格式的特殊数据格式。每个文件称为<strong>对象文件</strong>（object file）。输出文件通常称为可执行文件，但出于我们的目的，我们也将其称为对象文件。每个对象文件都有一个段列表。我们有时将输入文件中的一个段称为<strong>输入段</strong>（input section）；类似地，输出文件中的段也是<strong>输出段</strong>（output section）。</p>
<p>对象文件中的每个段都有一个<strong>名称</strong>和<strong>大小</strong>。大多数段还具有相关的数据块，称为<strong>段内容</strong>（section contents）。一个段可以标记为<strong>loadable</strong>，这意味着在运行输出文件时应将内容加载到存储器中。没有内容的段可能是可分配的（allocatable），这意味着内存中的区域应放在一边，但是没有任何内容应该加载（在某些情况下，该存储器必须归零）。既不可加载也不可分配的段通常包含某种调试信息。</p>
<p>每个可加载或分配的输出段都有两个地址。第一个是<strong>VMA（virtual memory address）</strong>，这是运行输出文件时段将具有的地址。第二个是<strong>LMA（load memory address）</strong>，该段将会从此地址被加载出来。在大多数情况下，两个地址将是相同的。它们可能不同的示例是将数据部分加载到ROM中后在程序启动时复制到RAM中（此技术通常用于初始化ROM中的全局变量）。在这种情况下，ROM地址将是LMA，RAM地址将是VMA。</p>
<p>通过使用带有<code>-h</code>选项的objdump程序，可以查看对象文件中的部分。每个对象文件还有一个符号列表，称为<strong>符号表</strong>（symbol table）。符号可以是已定义的，也可以是未定义的。每个符号都有一个名称，每个已经定义的符号都有一个地址，还有其他信息。如果您将一个 c 或 c + + 程序编译成一个对象文件，您将获得每个<strong>已经定义的函数</strong>以及<strong>全局或静态变量</strong>的<strong>已定义的符号</strong>。输入文件中引用的每个未定义的函数或全局变量都将成为未定义的符号。</p>
<p>您可以使用nm程序或使用带有<code>-t</code>选项的objdump程序查看对象文件中的符号。</p>
<h3 id="3-2-链接脚本格式"><a href="#3-2-链接脚本格式" class="headerlink" title="3.2 链接脚本格式"></a>3.2 链接脚本格式</h3><p>链接脚本是<strong>文本文件</strong>。</p>
<p>将链接器脚本作为一系列命令编写。每个命令要么是一个关键字（可能后跟参数），要么是一个符号赋值。可以使用分号分隔命令。<strong>空格通常被忽略。</strong></p>
<p>通常可以直接输入文件名或格式名等字符串。如果文件名包含一个字符，例如符合分隔文件名的逗号，则可以将文件名放在双引号中。无法在文件名中使用双引号字符。</p>
<p>您可以在链接器脚本中包含注释，就像在C中一样，由<code>/*</code>和<code>*/</code>分隔。与C语言一样，注释在语法上等同于空格。</p>
<h3 id="3-3简单链接器脚本示例"><a href="#3-3简单链接器脚本示例" class="headerlink" title="3.3简单链接器脚本示例"></a>3.3简单链接器脚本示例</h3><p>许多链接器脚本相当简单。</p>
<p>最简单的链接器脚本只有一个命令：<strong>SECTIONS</strong>。您可以使用<strong>SECTIONS</strong>命令来描述输出文件的内存布局。</p>
<p><strong>SECTIONS</strong>命令是一个强大的命令。这里我们将描述它的一个简单用法。假设您的程序只包含代码、初始化数据和未初始化数据。它们将分别位于<code>.text</code>、<code>.data</code>和<code>.bss</code>部分。让我们进一步假设这些是在输入文件中出现的唯一部分。</p>
<p>对于本例，假设代码应该加载到地址0x10000，数据应该从地址0x8000000开始。下面是一个链接器脚本，它将执行以下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS </span><br><span class="line">&#123;</span><br><span class="line">	. = 0x10000; </span><br><span class="line">	.text : &#123; *(.text) &#125; </span><br><span class="line">	. = 0x8000000; </span><br><span class="line">	.data : &#123; *(.data) &#125; </span><br><span class="line">	.bss : &#123; *(.bss) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<strong>SECTIONS</strong>命令作为关键字<strong>SECTIONS</strong>编写，然后是一系列符号赋值和用大括号括起来的输出段说明。</p>
<p>上例的“SECTIONS”命令内的第一行<strong>设置特殊符号“.”的值</strong>，该符号是<strong>位置计数器</strong>。如果未以其他方式指定输出段的地址（其他方式将在后面介绍），则将根据位置计数器的当前值设置地址。然后，<strong>位置计数器按输出部分的大小递增</strong>。在<strong>SECTIONS</strong>命令的开头，位置计数器的值为’0’。</p>
<p>第二行定义了一个输出段<code>.text</code>。冒号是必需的语法，目前可能会被忽略。在输出段名称后的大括号内，列出应放置在此输出段中的输入段的名称。<code>*</code>是与任何文件名匹配的通配符。表达式<code>*（.text）</code>表示所有输入文件中的所有<code>.text</code>输入段。</p>
<p>由于定义输出段<code>.text</code>时位置计数器为“0x10000”，因此链接器会将输出文件中<code>.text</code>段的地址设置为“0x10000”。</p>
<p>其余的行定义输出文件中的<code>.data</code>和<code>.bss</code>段。链接器将<code>.data</code>输出段放置在地址“0x8000000”处。链接器放置<code>.data</code>输出段后，位置计数器的值将为“0x8000000”加上<code>.data</code>输出段的大小。其效果是链接器将把<code>.bss</code>输出段放在内存中<code>.data</code>输出段之后。</p>
<p>链接器将通过必要时增加位置计数器的方式确保每个输出段具有所需的对齐方式。在此示例中，<code>.text</code>和<code>.data</code>段的指定地址可能会满足任何对齐约束，但链接器可能必须在<code>.data</code>和<code>.bss</code>段之间创建一个小间隙。</p>
<p>就这样！这是一个简单而完整的链接器脚本。</p>
<h3 id="3-4简单链接器脚本命令"><a href="#3-4简单链接器脚本命令" class="headerlink" title="3.4简单链接器脚本命令"></a>3.4简单链接器脚本命令</h3><p>在本段中，我们将介绍简单的链接器脚本命令。</p>
<h4 id="3-4-1设置入口点"><a href="#3-4-1设置入口点" class="headerlink" title="3.4.1设置入口点"></a>3.4.1设置入口点</h4><p>在程序中执行的第一条指令称为入口点。您可以使用ENTRY链接脚本命令设置入口点。参数是一个符号名：</p>
<p><code>ENTRY(symbol)</code></p>
<p>有几种方法可以设置入口点。链接器将通过按顺序尝试以下每个方法并在其中一个成功时停止来设置入口点：</p>
<ul>
<li>‘-e’输入命令行选项；</li>
<li>链接器脚本中的ENTRY（symbol）命令；</li>
<li>符号<code>start</code>的值（如果已定义的话）；</li>
<li>“.text”段第一个字节的地址（如果存在的话）；</li>
<li>地址0。</li>
</ul>
<h4 id="3-4-2处理文件的命令"><a href="#3-4-2处理文件的命令" class="headerlink" title="3.4.2处理文件的命令"></a>3.4.2处理文件的命令</h4><p>几个处理文件的链接器脚本命令。</p>
<ul>
<li><p><strong>INCLUDE filename</strong></p>
<p>在此处<strong>包含</strong>链接器脚本的文件名。将在当前目录以及使用’-L’选项指定的任何目录中搜索该文件。您可以嵌套调用以INCLUDE多达10个级别的深度。</p>
<p>您可以将INCLUDE指令放在<strong>顶层</strong>，在<strong>MEMORY</strong>或分<strong>SECTIONS</strong>命令中，或放在<strong>输出段描述</strong>中。</p>
</li>
<li><p><strong>INPUT(file, file, …)</strong> </p>
<p><strong>INPUT(file file …)</strong></p>
<p>INPUT命令指示链接器在链接中包含已命名文件，就像它们是在命令行中命名的一样。</p>
<p>例如，如果您希望在每次链接时包含’subr.o’，但又不想麻烦将其放在每个链接命令行上，那么您可以在链接器脚本中添加’INPUT（subr.o）’。</p>
<p>事实上，如果愿意，可以在链接器脚本中列出所有输入文件，然后只使用“-T”选项调用链接器。</p>
<p>如果配置了sysroot前缀，并且文件名以“/”字符开头，并且正在处理的脚本位于sysroot前缀内，则将在sysroot前缀中查找文件名。否则，链接器将尝试打开当前目录中的文件。如果未找到，链接器将通过存档库搜索路径进行搜索。</p>
<p>如果使用“INPUT（-lfile）”，ld将把名称转换为libfile.a，就像命令行参数’-l’一样。</p>
<p>在隐式链接器脚本中使用INPUT命令时，文件将包含在链接器脚本文件包含点处的链接中。这可能会影响存档搜索。</p>
</li>
<li><p><strong>GROUP(file, file, …)</strong> </p>
<p><strong>GROUP(file file …)</strong></p>
<p>GROUP命令与INPUT类似，只是命名的文件都应该是<strong>归档文件</strong>，并且重复搜索它们，直到没有创建新的未定义引用为止。</p>
</li>
<li><p><strong>AS_NEEDED(file, file, …)</strong> </p>
<p><strong>AS_NEEDED(file file …)</strong></p>
<p>此构造只能出现在其他文件名中的<strong>INPUT</strong>或<strong>GROUP</strong>命令中。列出的文件将被处理，就像它们直接出现在<strong>INPUT</strong>或<strong>GROUP</strong>命令中一样，ELF共享库除外，只有在实际需要时才会添加。此构造实质上为其中列出的所有文件启用了“–as needed”选项，并根据需要恢复以前的<code>‘--as-needed’</code>和<code>‘--no-as-needed’</code>设置。</p>
</li>
<li><p><strong>OUTPUT(filename)</strong></p>
<p>输出命令命名输出文件。在链接器脚本中使用输出（文件名）与在命令行中使用“-o文件名”完全相同。如果两者都使用，则命令行选项优先。</p>
<p>您可以使用OUTPUT命令为输出文件定义默认名称，而不是通常的默认名称“a.out”。</p>
</li>
<li><p><strong>SEARCH_DIR(path)</strong></p>
<p>SEARCH_DIR命令将path添加到ld查找归档库的路径列表中。使用SEARCH_DIR（path）与在命令行上使用’-L path’完全相同。如果两者都使用，则链接器将搜索两条路径。首先搜索使用命令行选项指定的路径。</p>
</li>
<li><p><strong>STARTUP(filename)</strong></p>
<p>STARTUP命令与INPUT命令类似，只是filename将成为要链接的第一个输入文件，就好像它是在命令行上首先指定的一样。在使用入口点始终是第一个文件开头的系统时，这可能很有用。</p>
</li>
</ul>
<hr>
<p>…</p>
<hr>
<h4 id="3-4-4为内存区域分配别名"><a href="#3-4-4为内存区域分配别名" class="headerlink" title="3.4.4为内存区域分配别名"></a>3.4.4为内存区域分配别名</h4><p>别名可以添加到使用<strong>MEMORY</strong>命令创建的现有内存区域中。每个名称最多对应一个内存区域。</p>
<p>​    <code>REGION_ALIAS(alias, region)</code></p>
<p><strong>REGION_ALIAS</strong>函数为内存区域<em>region</em>创建别名。这允许将输出段灵活地映射到内存区域。下面是一个例子。</p>
<p>假设我们有一个应用于各种内存存储设备的嵌入式系统。所有这些都具有通用，易失性存储器RAM，允许代码执行或数据存储。有些可能具有允许代码执行和只读数据访问的只读的非易失性存储器ROM。最后一个变体是一个只读的非易失性存储器ROM2，具有只读数据访问，没有代码执行能力。我们有四个输出段：</p>
<ul>
<li>.text         程序代码;</li>
<li>.rodata    只读已初始化数据;</li>
<li>.data        读写已初始化数据;</li>
<li>.bss          读写零初始化数据;</li>
</ul>
<p>目标是提供一个链接器命令文件，其中包含定义输出部分的系统独立部分和将输出部分映射到系统上可用内存区域的系统依赖部分。我们的嵌入式系统具有三种不同的内存设置A、B和C：</p>
<table>
<thead>
<tr>
<th align="center">Section</th>
<th align="center">Variant A</th>
<th align="center">Variant B</th>
<th align="center">Variant C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.text</td>
<td align="center">RAM</td>
<td align="center">ROM</td>
<td align="center">ROM</td>
</tr>
<tr>
<td align="center">.rodata</td>
<td align="center">RAM</td>
<td align="center">ROM</td>
<td align="center">ROM2</td>
</tr>
<tr>
<td align="center">.data</td>
<td align="center">RAM</td>
<td align="center">RAM/ROM</td>
<td align="center">RAM/ROM2</td>
</tr>
<tr>
<td align="center">.bss</td>
<td align="center">RAM</td>
<td align="center">RAM</td>
<td align="center">RAM</td>
</tr>
</tbody></table>
<p>符号RAM/ROM或RAM/ROM2表示该部分分别加载到区域ROM或ROM2中。请注意三种变体中<code>.data</code>段的加载地址均位于<code>.rodata</code>段之后。</p>
<p>下面是处理输出段的基本链接器脚本。它包含了描述内存布局的系统依赖文件<strong>linkcmds.memory</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INCLUDE linkcmds.memory</span><br><span class="line"></span><br><span class="line">SECTIONS &#123;</span><br><span class="line">    .text : &#123;</span><br><span class="line">            *(.text)</span><br><span class="line">        &#125; &gt; REGION_TEXT </span><br><span class="line">    .rodata : &#123;</span><br><span class="line">            *(.rodata) </span><br><span class="line">            rodata_end = .; </span><br><span class="line">        &#125; &gt; REGION_RODATA</span><br><span class="line">    .data : AT (rodata_end) &#123;</span><br><span class="line">            data_start = .; </span><br><span class="line">            *(.data)</span><br><span class="line">        &#125; &gt; REGION_DATA </span><br><span class="line">    data_size = SIZEOF(.data); </span><br><span class="line">    data_load_start = LOADADDR(.data); </span><br><span class="line">    .bss : &#123;</span><br><span class="line">            *(.bss) </span><br><span class="line">        &#125; &gt; REGION_BSS </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们需要三个不同的linkcmds.memory文件来定义内存区域和别名名称。以下是针对分别三种变体A、B和C的不同的<strong>linkcmds.memory</strong>的内容：</p>
<ul>
<li><p><strong>A</strong>    这种方式中所有东西全部进入到RAM中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEMORY &#123;</span><br><span class="line">    RAM : ORIGIN = 0, LENGTH = 4M </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">REGION_ALIAS(&quot;REGION_TEXT&quot;, RAM); </span><br><span class="line">REGION_ALIAS(&quot;REGION_RODATA&quot;, RAM); </span><br><span class="line">REGION_ALIAS(&quot;REGION_DATA&quot;, RAM); </span><br><span class="line">REGION_ALIAS(&quot;REGION_BSS&quot;, RAM);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>B</strong>    程序代码和只读数据进入ROM。读写数据进入RAM。初始化数据的镜像加载到ROM中，并将在系统启动期间复制到RAM中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEMORY &#123;</span><br><span class="line">    ROM : ORIGIN = 0, LENGTH = 3M </span><br><span class="line">    RAM : ORIGIN = 0x10000000, LENGTH = 1M</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">REGION_ALIAS(&quot;REGION_TEXT&quot;, ROM); </span><br><span class="line">REGION_ALIAS(&quot;REGION_RODATA&quot;, ROM); </span><br><span class="line">REGION_ALIAS(&quot;REGION_DATA&quot;, RAM); </span><br><span class="line">REGION_ALIAS(&quot;REGION_BSS&quot;, RAM);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>C</strong>    程序代码进入ROM。只读数据进入ROM 2。读写数据进入RAM。初始化数据的映像加载到ROM 2中，并在系统启动期间复制到RAM中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEMORY &#123;</span><br><span class="line">    ROM : ORIGIN = 0, LENGTH = 2M </span><br><span class="line">    ROM2 : ORIGIN = 0x10000000, LENGTH = 1M </span><br><span class="line">    RAM : ORIGIN = 0x20000000, LENGTH = 1M</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">REGION_ALIAS(&quot;REGION_TEXT&quot;, ROM); </span><br><span class="line">REGION_ALIAS(&quot;REGION_RODATA&quot;, ROM2); </span><br><span class="line">REGION_ALIAS(&quot;REGION_DATA&quot;, RAM); </span><br><span class="line">REGION_ALIAS(&quot;REGION_BSS&quot;, RAM);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果需要，可以编写公共系统初始化例程以将来自ROM或ROM2的.data部分复制到RAM中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> data_start []; </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> data_size []; </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> data_load_start [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_data</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data_start != data_load_start) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data_start, data_load_start, (<span class="keyword">size_t</span>) data_size); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>…</p>
<hr>
<h3 id="3-6段命令"><a href="#3-6段命令" class="headerlink" title="3.6段命令"></a>3.6段命令</h3><p><strong>SECTIONS</strong>命令告诉链接器如何将输入段映射到输出段，以及如何将输出段放置在内存中。</p>
<p>“SECTIONS”命令的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	sections-command </span><br><span class="line">	sections-command </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个区段命令可以是以下命令之一：</p>
<ul>
<li>一个ENTRY命令</li>
<li>符号赋值</li>
<li>输出部分描述</li>
<li>覆盖描述</li>
</ul>
<p>为了方便在这些命令中使用位置计数器，允许在SECTIONS命令中指定ENTRY命令和符号。这还可以使链接器脚本更容易理解，因为您可以在输出文件布局中有意义的位置使用这些命令。</p>
<p>输出部分描述和覆盖描述如下所述。</p>
<p>如果在链接器脚本中不使用<strong>SECTIONS</strong>命令，链接器将按照在输入文件中首先遇到的顺序，将每个输入段放入具有相同名称的输出段中。例如，如果第一个文件中存在所有输入段，则输出文件中段的顺序将与第一个输入文件中的顺序匹配。第一部分将位于地址0处。</p>
<h4 id="3-6-1输出段说明"><a href="#3-6-1输出段说明" class="headerlink" title="3.6.1输出段说明"></a>3.6.1输出段说明</h4><p>输出段的完整描述如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section [address] [(type)] : </span><br><span class="line">    [AT(lma)] </span><br><span class="line">    [ALIGN(section_align)] </span><br><span class="line">    [SUBALIGN(subsection_align)] </span><br><span class="line">    [constraint] &#123;</span><br><span class="line">        output-section-command </span><br><span class="line">        output-section-command </span><br><span class="line">        ...</span><br><span class="line">    &#125; [&gt;region] [AT&gt;lma_region] [:phdr :phdr ...][=fillexp]</span><br></pre></td></tr></table></figure>

<p>大多数输出段不使用大多数可选的段属性。</p>
<p>段周围的空格是<strong>必要的</strong>，以便段名称明确无误。冒号和大括号也是必需的。换行符和其他空白是可选的。</p>
<p>每个 output-section-command 可以是以下命令之一:</p>
<ul>
<li>一个符号赋值</li>
<li>输入部分描述</li>
<li>直接包含的数据值</li>
<li>一个特殊的输出段关键字</li>
</ul>
<h4 id="3-6-2输出段名称"><a href="#3-6-2输出段名称" class="headerlink" title="3.6.2输出段名称"></a>3.6.2输出段名称</h4><p>输出段的名称为段。段必须满足<strong>输出格式</strong>的约束。在仅支持有限数量段的格式中，例如a.out，名称必须是该格式所支持的名称之一（例如，a.out仅允许<code>.text</code>、<code>.data</code>或<code>.bss</code>）。如果输出格式支持任意数量的段，但带有数字而不是名称（与Oasys的情况相同），则应将名称作为带引号的数字字符串提供。段名可以由任何字符序列组成，但包含任何异常字符（如逗号）的名称必须加引号。</p>
<p>输出段名称“/DISCARD/”是特殊的；</p>
<h4 id="3-6-3输出段地址"><a href="#3-6-3输出段地址" class="headerlink" title="3.6.3输出段地址"></a>3.6.3输出段地址</h4><p>该地址是<strong>输出部分的VMA</strong>（虚拟内存地址）的表达式。如果不提供地址，链接器将根据<strong>region</strong>（如果存在）或位置计数器的当前值设置地址。</p>
<p>如果您提供<strong>address</strong>，则输出段的地址将精确设置为该地址。如果既不提供<strong>address</strong>也不提供<strong>region</strong>，则输出段的地址将设置为与输出段的对齐要求对齐的<strong>位置计数器的当前值</strong>。输出段的对齐要求是输出段中包含的任何输入段中最严格的对齐。</p>
<p>例如：</p>
<p><code>.text . : &#123; *(.text) &#125;</code></p>
<p>以及</p>
<p><code>.text : &#123; *(.text) &#125;</code></p>
<p>两者有微妙的不同。第一个将“.text”的输出段设置为位置计数器的当前值。第二个将其设置为与“.text”的输入段最严格对齐的位置计数器的当前值。</p>
<p>address可以是任意表达式；例如，如果要在0x10字段边界上对齐段，使段地址的最低四位为零，则可以执行以下操作：</p>
<p><code>.text ALIGN(0x10) : &#123; *(.text) &#125;</code></p>
<p>这是正确的，因为<strong>ALIGN</strong>将当前位置计数器向上对齐到指定的值。</p>
<p>指定段的<strong>address</strong>将更改位置计数器的值，前提是该段为非空。（忽略空段）。</p>
<h4 id="3-6-4输入段描述"><a href="#3-6-4输入段描述" class="headerlink" title="3.6.4输入段描述"></a>3.6.4输入段描述</h4><p>最常见的输出段命令是<strong>输入段描述</strong>。</p>
<p>输入段描述是最基本的链接器脚本操作。您使用输出段告诉链接器如何在内存中布局程序。您可以使用输入段描述来告诉链接器如何将输入文件映射到内存布局中。</p>
<h5 id="3-6-4-1输入段基础知识"><a href="#3-6-4-1输入段基础知识" class="headerlink" title="3.6.4.1输入段基础知识"></a>3.6.4.1输入段基础知识</h5><p>输入段描述由<strong>文件名</strong>（可选）和括号中的<strong>段名列表</strong>组成。</p>
<p>文件名和段名可能是通配符模式，我们将在下面进一步描述。</p>
<p>最常见的输入段描述是在输出段中包含具有特定名称的所有输入段。例如，要包含所有输入<code>.text</code>部分，您可以写：</p>
<p><code>*(.text)</code></p>
<p>此处的<code>*</code>是与任何文件名匹配的通配符。要排除与文件名通配符匹配的文件列表，可以使用<strong>EXCLUDE_FILE</strong>匹配除排除文件列表中指定的文件之外的所有文件。例如：</p>
<p><code>*(EXCLUDE_FILE (*crtend.o *otherfile.o) .ctors)</code></p>
<p>将导致除“crtend.o”以及”otherfile.o”之外的所有文件中的<code>.ctors</code>段被包含在内。</p>
<p>有两种方法可以包含多个部分：</p>
<p><code>*(.text .rdata)</code> </p>
<p><code>*(.text) *(.rdata)</code></p>
<p>这两者之间的区别在于输入段<code>.text</code>和<code>.rdata</code>将出现在输出段中的顺序。在第一个示例中，它们将混合在一起，出现的顺序与它们被链接器找到的顺序相同。在第二个例子中，所有的<code>.text</code>输入段将首先出现，然后是全部<code>.rdata</code>的输入段。</p>
<p>您可以<strong>指定文件名以包含特定文件中的段</strong>。如果您的一个或多个文件包含需要位于内存中特定位置的特殊数据，则可以执行此操作。例如：</p>
<p><code>data.o(.data)</code></p>
<p>您还可以在归档文件中指定文件，方法是编写与归档文件匹配的模式、冒号，然后编写与文件匹配的模式，<strong>冒号周围没有空格</strong>。</p>
<p>‘archive:file’</p>
<p>​    匹配存档中的文件</p>
<p>‘archive:’ </p>
<p>​    匹配整个档案<br>‘:file’ </p>
<p>​    匹配文件，但不匹配存档中的那个文件</p>
<p>‘archive’和‘file’中的一个或两个都可以包含shell通配符。在基于DOS的文件系统中，链接器将假定一个后跟冒号的字母是驱动器说明符，因此<code>c:myfile.o</code>是一个简单的文件规范，而不是位于名为“c”的存档中的<code>myfile.o</code>。<code>archive:file</code>的文件规范也可以在<strong>排除文件列表（EXCLUDE_FILE）</strong>中使用，但可能不会出现在其他链接脚本的上下文中。例如，不能通过在<strong>INPUT</strong>命令中使用“archive:file”从存档中提取文件。</p>
<p>如果您使用的文件名没有段列表，则输入文件中的所有段都将包含在输出段中。这是不常见的行为，但有时可能有用。例如：</p>
<p><code>data.o</code></p>
<p>当您使用的文件名不是“archive:file”说明符且不包含任何通配符时，链接器将首先查看您是否还在链接器命令行或<strong>INPUT</strong>命令中指定了文件名。如果没有，链接器将尝试将该文件作为输入文件打开，就像它出现在命令行上一样。请注意，这与<strong>INPUT</strong>命令不同，因为链接器不会在存档搜索路径中搜索文件。</p>
<h5 id="3-6-4-2输入段通配符模式"><a href="#3-6-4-2输入段通配符模式" class="headerlink" title="3.6.4.2输入段通配符模式"></a>3.6.4.2输入段通配符模式</h5><p>在输入段描述中，文件名、段名或两者同时可以是通配符模式。</p>
<p>在许多示例中看到的<code>*</code>文件名是文件名的<strong>简单通配符模式</strong>。通配符模式与unixshell使用的模式类似。</p>
<p><code>*</code>    匹配任意数量的字符</p>
<p><code>?</code>    匹配任何<strong>单个</strong>字符</p>
<p><code>[chars]</code>    匹配任何字符的单个实例；<code>-</code>字符可用于指定字符范围，如<code>[a-z]</code>中的字符，以匹配任何小写字母</p>
<p><code>\</code>    引用其后的字符</p>
<p>当文件名与通配符匹配时，通配符将不与<strong>用于在Unix上分隔目录名</strong>的<code>/</code>字符匹配。由单个<code>*</code>字符组成的模式是一个例外；它将始终匹配任何文件名，无论它是否包含<code>/</code>。在段名称中，通配符将与<code>/</code>字符匹配。</p>
<p>文件名通配符模式仅匹配在命令行或INPUT命令中显式指定的文件。链接器不会搜索目录以展开通配符。</p>
<p>如果文件名与多个通配符模式匹配，或者如果文件名显式显示并且也与通配符模式匹配，则链接器将使用链接器脚本中的第一个匹配项。例如，输入段描述的这个序列可能是错误的，因为<code>data.o</code>规则将不被使用：</p>
<p><code>.data : &#123; *(.data) &#125;</code></p>
<p><code>.data1 : &#123; data.o(.data) &#125;</code></p>
<p>通常，链接器将按照链接期间查找到的顺序放置与通配符匹配的文件和段。您可以使用<strong>SORT_BY_NAME</strong>关键字来更改此设置，该关键字出现在括号中通配符模式之前（例如，<code>SORT_by_NAME(.text*)</code>）。使用SORT_BY_NAME关键字时，链接器将按名称升序对文件或段进行排序，然后再将其放入输出文件中。</p>
<p><strong>SORT_BY_ALIGNMENT</strong>与<strong>SORT_BY_NAME</strong>非常相似。不同之处在于，<strong>SORT_BY_ALIGNMENT</strong>将按对齐方式将段按升序排序，然后再将其放入输出文件中。<strong>SORT</strong>是<strong>SORT_BY_NAME</strong>的别名。</p>
<p>当链接器脚本中存在嵌套的段排序命令时，段排序命令最多可以有<strong>1级嵌套</strong>。</p>
<ol>
<li><code>SORT_BY_NAME(SORT_BY_ALIGNMENT(通配符段模式))</code>。它将首先按名称对输入段进行排序，如果两个段具有相同的名称，则继续按对齐方式进行排序。</li>
<li><code>SORT_BY_ALIGNMENT(SORT_BY_NAME(通配符段模式))</code>。它将首先按对齐方式对输入部分进行排序，如果两个部分具有相同的对齐方式，则按名称对输入部分进行排序。</li>
<li><code>SORT_BY_NAME(SORT_BY_NAME(通配符段模式))</code>与<code>SORT_BY_NAME(通配符段模式)</code>处理相同。</li>
<li><code>SORT_BY_ALIGNMENT(SORT_BY_ALIGNMENT(通配符段模式))</code>与<code>SORT_BY_ALIGNMENT(通配符段模式)</code>处理相同。</li>
<li>所有其他嵌套段排序命令无效。</li>
</ol>
<p>当同时使用命令行段排序选项和链接器脚本段排序命令时，<strong>段排序命令始终优先于命令行选项</strong>。</p>
<p>如果链接器脚本中的段排序命令未嵌套，则命令行选项将使段排序命令被视为嵌套排序命令。</p>
<ol>
<li>使用“–sort-sections alignment”以及<code>SORT_BY_NAME(通配符段模式)</code>等同于<code>SORT_BY_NAME(SORT_BY_ALIGNMENT(通配符段模式))</code>。</li>
<li>使用“–sort-sections name”的<code>SORT_BY_ALIGNMENT(通配符段模式)</code>等同于<code>SORT_BY_ALIGNMENT(SORT_BY_NAME(通配符段模式))</code>。</li>
</ol>
<p>如果链接器脚本中的段排序命令是嵌套的，则<strong>将忽略命令行选项</strong>。</p>
<p>如果您对输入段的去向感到困惑，请使用“-M”链接器选项生成映射文件。映射文件精确地显示了如何将输入段映射到输出段。</p>
<p>此示例显示了如何使用通配符模式对文件进行分区。这个链接器</p>
<p>脚本指示链接器将所有输入文件中的<code>.text</code>段放置到<code>.text</code>中，并且将所有输入文件中的<code>.bss</code>段放入<code>.bss</code>。链接器将所有以<strong>大写字符开头</strong>的文件中的<code>.data</code>段放入<code>.DATA</code>；然后将剩余文件中的<code>.data</code>段放入到<code>.data</code>中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123; </span><br><span class="line">    .text : &#123; *(.text) &#125; </span><br><span class="line">    .DATA : &#123; [A-Z]*(.data) &#125; </span><br><span class="line">    .data : &#123; *(.data) &#125; </span><br><span class="line">    .bss : &#123; *(.bss) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-6-4-3公共符号的输入部分"><a href="#3-6-4-3公共符号的输入部分" class="headerlink" title="3.6.4.3公共符号的输入部分"></a>3.6.4.3公共符号的输入部分</h5><p>公共符号需要特殊的符号，因为在许多对象文件格式中，公共符号没有特定的输入部分。链接器将公共符号视为位于名为‘<strong>COMMON</strong>’的输入段中。</p>
<blockquote>
<p><strong>What are COMMON symbols?</strong></p>
<p>Common symbols are a feature that allow a programmer to ‘define’ several variables of the same name in different source files.  This is in contrast with the more popular way of doing, where you define a variable once in a source file, and reference it everywhere else in other source files, using extern.  When common symbols are used, the linker will merge all symbols of the same name into a single memory location, the size of which is the largest type of the individual common symbol definitions.  For example, if fileA.c defines an uninitialized 32-bit integer myint, and fileB.c defines an 8-bit char myint, then in the final executable, references to myint from both files will point to the same memory location (common location), and the linker will reserve 32 bits for that location.</p>
<p>引自<strong>Arun</strong>的文章：</p>
<p><a href="https://binarydodo.wordpress.com/2016/05/09/investigating-linking-with-common-symbols-in-elf/">Investigating linking with COMMON symbols in ELF</a></p>
</blockquote>
<p>您可以将文件名与“<strong>COMMON</strong>”段一起使用，就像使用任何其他输入部分一样。可以使用该特性将特定输入文件中的公共符号放置在一个分区中，而将其他输入文件中的公共符号放置在另一个分区中。</p>
<p><strong>在大多数情况下，输入文件中的常用符号将放在输出文件中的<code>.bss</code>段中</strong>。例如：</p>
<p><code>.bss &#123; *(.bss) *(COMMON) &#125;</code></p>
<p>某些对象文件格式具有多种类型的公共符号。例如，MIPS ELF对象文件格式区分标准公共符号和小型公共符号。在这种情况下，链接器将为其他类型的公共符号使用不同的特殊段名。在MIPS ELF的情况下，链接器对标准公共符号使用<code>COMMON</code>并用<code>.scommon</code>表示小型通用符号。这允许您将不同类型的公共符号映射到不同位置的内存中。</p>
<p>您有时会在旧的链接器脚本中看到<code>[COMMON]</code>。这种符号现在被认为是过时的。它相当于<code>*(COMMON)</code>。</p>
<h5 id="3-6-4-4输入段和垃圾收集"><a href="#3-6-4-4输入段和垃圾收集" class="headerlink" title="3.6.4.4输入段和垃圾收集"></a>3.6.4.4输入段和垃圾收集</h5><p>当使用链接时垃圾回收<code>(&#39;--gc-sections&#39;)</code>时，标记不应删除的段通常很有用。这是通过使用KEEP（）包围输入段的通配符项来实现的，如：</p>
<p><code>KEEP(*(.init))</code></p>
<p><code>KEEP(SORT_BY_NAME(*)(.ctors))</code></p>
<h5 id="3-6-4-5输入段示例"><a href="#3-6-4-5输入段示例" class="headerlink" title="3.6.4.5输入段示例"></a>3.6.4.5输入段示例</h5><p>下面的示例是一个完整的链接器脚本。它告诉链接器读取文件“all.o”中的所有段并将其放置在输出段<code>outputa</code>的开头，该段从位置“0x10000”开始。文件”foo.o”中的整个**输入段<code>.input1</code><strong>放在</strong>输出段<code>outputa</code><strong>中的上述段之后。”foo.o”文件的整个</strong>输入段<code>.input2</code><strong>放到</strong>输出段<code>outputb</code><strong>中，”foo1.o”文件的整个</strong>输入段<code>.input1</code>**紧随其后。其余所有文件中的输入段<code>.input1</code>和<code>.input2</code>均被写入输出段<code>outputc</code>中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123; </span><br><span class="line">    outputa 0x10000 : </span><br><span class="line">    	&#123;</span><br><span class="line">        all.o </span><br><span class="line">        foo.o (.input1) </span><br><span class="line">    	&#125;</span><br><span class="line">    outputb : </span><br><span class="line">    	&#123;</span><br><span class="line">        foo.o (.input2) </span><br><span class="line">        foo1.o (.input1) </span><br><span class="line">    	&#125;</span><br><span class="line">    outputc : </span><br><span class="line">    	&#123;</span><br><span class="line">        *(.input1) </span><br><span class="line">        *(.input2) </span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>…</p>
<hr>
<h4 id="3-6-8输出段属性"><a href="#3-6-8输出段属性" class="headerlink" title="3.6.8输出段属性"></a>3.6.8输出段属性</h4><p>我们在上面展示了输出段的完整描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section [address] [(type)] : </span><br><span class="line">    [AT(lma)] </span><br><span class="line">    [ALIGN(section_align)] </span><br><span class="line">    [SUBALIGN(subsection_align)] </span><br><span class="line">    [constraint] &#123;</span><br><span class="line">        output-section-command </span><br><span class="line">        output-section-command </span><br><span class="line">        ...</span><br><span class="line">	&#125; [&gt;region] [AT&gt;lma_region] [:phdr :phdr ...] [=fillexp]</span><br></pre></td></tr></table></figure>

<p>我们已经描述了section、address和output section命令。在本节中，我们将描述其余的段属性。</p>
<h5 id="3-6-8-1输出段类型"><a href="#3-6-8-1输出段类型" class="headerlink" title="3.6.8.1输出段类型"></a>3.6.8.1输出段类型</h5><p>每个输出段可以有一个类型。类型是括号中的关键字。定义了以下类型：</p>
<p><strong>NOLOAD</strong>    该段应标记为不可加载，以便在程序运行时不会将其加载到内存中。</p>
<p><strong>DSECT</strong> </p>
<p><strong>COPY</strong></p>
<p> <strong>INFO</strong></p>
<p><strong>OVERLAY</strong>    这些类型名支持向后兼容，很少使用。它们都具有相同的效果：<strong>该段应标记为不可分配</strong>，以便在程序运行时不会为该段分配内存。</p>
<p>链接器通常根据映射到输出段的输入段设置输出段的属性。可以通过使用段类型来替代此选项。例如，在下面的脚本示例中，<code>ROM</code>段位于内存位置“0”处，在程序运行时不需要加载。<code>ROM</code>段的内容将像往常一样出现在链接器输出文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123; </span><br><span class="line">	ROM 0 (NOLOAD) : &#123; ... &#125; </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-6-8-2输出段LMA"><a href="#3-6-8-2输出段LMA" class="headerlink" title="3.6.8.2输出段LMA"></a>3.6.8.2输出段LMA</h5><p>每个段都有一个<strong>虚拟地址</strong>（VMA）和一个<strong>加载地址</strong>（LMA）；输出段描述中可能出现的地址表达式设置了虚拟地址。</p>
<p>AT关键字后面的表达式lma指定段的<strong>加载地址</strong>。</p>
<p>或者，使用<code>AT&gt;lma_region</code>表达式，您可以为节的加载地址指定内存区域。请注意，如果该节尚未分配VMA，则链接器也将使用<em>lma_region</em>作为VMA区域。</p>
<p>如果既未为可分配节指定AT又未指定AT&gt;，则链接器将设置LMA，以便该节的VMA和LMA之间的差异与同一区域中的前一输出段相同。如果没有前面的输出段或该段不可分配，则链接器将LMA设置为等于VMA。</p>
<p>此功能旨在<strong>使ROM镜像的构建变得简单</strong>。例如，下面的链接器脚本创建了三个输出段：一个名为<code>.text</code>，从0x1000开始，一个称为<code>.mdata</code>，<strong>它被加载在<code>.text</code>段的末尾，即使其VMA为0x2000</strong>，还有一个<code>.bss</code>段用于在地址0x3000处保存未初始化的数据。符号_data用值0x2000定义，表示位置计数器保存的是VMA值，而不是LMA值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">.text 0x1000 : </span><br><span class="line">	&#123; *(.text) _etext = . ; &#125; </span><br><span class="line">.mdata 0x2000 : </span><br><span class="line">    AT ( ADDR (.text) + SIZEOF (.text) ) </span><br><span class="line">    &#123; _data = . ; *(.data); _edata = . ; &#125;</span><br><span class="line">.bss 0x3000 : </span><br><span class="line">	&#123; _bstart = . ; *(.bss) *(COMMON) ; _bend = . ;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与使用此链接器脚本生成的程序一起使用的运行时初始化代码将包括以下内容，以将初始化数据从ROM镜像复制到其运行时地址。<strong>请注意，此代码如何利用链接器脚本定义的符号。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern char _etext, _data, _edata, _bstart, _bend; </span><br><span class="line">char *src = &amp;_etext; </span><br><span class="line">char *dst = &amp;_data;</span><br><span class="line"></span><br><span class="line">/* ROM has data at end of text; copy it. */ </span><br><span class="line">while (dst &lt; &amp;_edata) &#123; </span><br><span class="line">	*dst++ = *src++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Zero bss */ </span><br><span class="line">for (dst = &amp;_bstart; dst&lt; &amp;_bend; dst++) </span><br><span class="line">	*dst = 0;</span><br></pre></td></tr></table></figure>

<h5 id="3-6-8-3强制输出对齐"><a href="#3-6-8-3强制输出对齐" class="headerlink" title="3.6.8.3强制输出对齐"></a>3.6.8.3强制输出对齐</h5><p>可以使用<strong>ALIGN</strong>增加输出段的对齐。</p>
<h5 id="3-6-8-4强制输入对齐"><a href="#3-6-8-4强制输入对齐" class="headerlink" title="3.6.8.4强制输入对齐"></a>3.6.8.4强制输入对齐</h5><p>可以使用<strong>SUBALIGN</strong>在输出段内强制输入段对齐。指定的值将覆盖由输入段（无论大小）给定的任何对齐方式。</p>
<h5 id="3-6-8-5输出段约束"><a href="#3-6-8-5输出段约束" class="headerlink" title="3.6.8.5输出段约束"></a>3.6.8.5输出段约束</h5><p>通过分别使用关键字<code>ONLY_IF_RO</code>和<code>ONLY_IF_RW</code>，可以指定仅当输出段的所有输入段都是只读的或其所有输入段都是读写的时才应创建输出段。</p>
<h5 id="3-6-8-6输出段区域"><a href="#3-6-8-6输出段区域" class="headerlink" title="3.6.8.6输出段区域"></a>3.6.8.6输出段区域</h5><p>您可以使用<code>&gt;region</code>将段分配给先前使用<code>MEMORY</code>命令定义的内存区域。</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEMORY &#123; rom : ORIGIN = 0x1000, LENGTH = 0x1000 &#125;</span><br><span class="line">SECTIONS &#123; ROM : &#123; *(.text) &#125; &gt;rom &#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-6-8-7输出段物理地址"><a href="#3-6-8-7输出段物理地址" class="headerlink" title="3.6.8.7输出段物理地址"></a>3.6.8.7输出段物理地址</h5><p>可以使用<code>:phdr</code>将段分配给先前定义的程序段。如果一个段被指定给一个或多个段，则所有后续分配的区段也将被指定给这些区段，除非它们使用显式<code>:phdr</code>修饰符。您可以使用<code>:NONE</code>告诉链接器根本不要将该段放入任何程序段中。</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHDRS &#123; text PT_LOAD ; &#125;</span><br><span class="line">SECTIONS &#123; .text : &#123; *(.text) &#125; :text &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>…</p>
<hr>
<h3 id="3-7内存命令"><a href="#3-7内存命令" class="headerlink" title="3.7内存命令"></a>3.7内存命令</h3><p>链接器的默认配置允许分配所有可用内存。您可以使用<strong>MEMORY</strong>命令覆盖该配置。</p>
<p><strong>MEMORY</strong>命令描述目标中内存块的<strong>位置</strong>和<strong>大小</strong>。您可以使用它来描述链接器可以使用哪些内存区域，以及必须避免哪些内存区域。然后可以将节分配给特定的内存区域。链接器将根据内存区域设置段地址，并警告区域过满。<strong>链接器不会随意移动段以适应可用区域。</strong></p>
<p>链接器脚本最多可以包含<strong>MEMORY</strong>命令的<strong>一次</strong>使用。但是，您可以根据需要在其中<strong>定义任意多的内存块</strong>。语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEMORY &#123;</span><br><span class="line">        name [(attr)] : ORIGIN = origin, LENGTH = len </span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>name是链接器脚本中用于引用区域的名称。区域名称<strong>在链接器脚本之外没有任何含义</strong>。区域名称存储在单独的名称空间中，<strong>不会与符号名、文件名或节名冲突</strong>。在<strong>MEMORY</strong>命令中，每个内存区域必须有一个不同的名称。但是，您可以使用第3.4.4节中的内容将后续的别名添加到现有内存区域。</p>
<p>attr字符串是一个可选的属性列表，用于指定是否为未在链接器脚本中显式映射的输入段使用特定内存区域。如第3.6节所述，如果您没有为某些输入段指定输出段，链接器将创建一个与输入段同名的输出段。如果您定义了区域属性，链接器将使用它们为它创建的输出部分选择内存区域。</p>
<p>attr字符串只能由以下字符组成：</p>
<p><code>R</code>    只读段</p>
<p><code>W</code>    读/写段</p>
<p><code>X</code>    可执行段</p>
<p><code>A</code>    可分配段</p>
<p><code>I</code>    已初始化段</p>
<p><code>L</code>    与<code>I</code>相同</p>
<p><code>!</code>    <strong>反转</strong>上述任何属性的意义</p>
<p>如果未映射的节与除<code>!</code>以外的任何列出的属性匹配，它将被放置在内存区域中。<code>!</code>属性反转此测试，以便仅当未映射的段与所列出的任何属性均不匹配时，才会将其放置在内存区域中。</p>
<p>origin是<strong>内存区域起始地址的数字表达式</strong>。表达式的计算结果必须为<strong>常量</strong>，并且不能包含任何符号。关键字<strong>ORIGIN</strong>可以缩写为org或o（但不能缩写为ORG）。</p>
<p>len是<strong>内存区域大小</strong>（以字节为单位）的表达式。与原始表达式一样，该表达式必须仅为数值表达式，且计算结果必须为常量。关键字<strong>LENGTH</strong>可以缩写为len或l。</p>
<p>在下面的示例中，我们指定有两个内存区域可供分配：一个从“0”开始分配256 KB，另一个从“0x40000000”开始分配4 MB。链接器将把未显式映射到内存区域且为只读或可执行的每个部分放入“rom”内存区域。链接器会将未显式映射到内存区域的其他部分放入“ram”内存区域。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEMORY &#123;</span><br><span class="line">    rom (rx) : ORIGIN = 0, LENGTH = 256K </span><br><span class="line">    ram (!rx) : org = 0x40000000, l = 4M</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当您定义内存区域后，可以通过使用<code>&gt;region</code>的输出段属性，指示链接器将特定的输出段放入该内存区域。例如，如果您有一个名为<code>mem</code>的内存区域，那么您将在输出段定义中使用<code>&gt;mem</code>。如果没有为输出段指定地址，链接器将把地址设置为内存区域内的下一个可用地址。如果定向到内存区域的组合输出段对于该区域来说太大，则链接器将发出错误消息。</p>
<p>可以通过<code>ORIGIN(memory)</code>和<code>LENGTH(memory)</code>函数访问表达式中内存的<strong>起点</strong>和<strong>长度</strong>：</p>
<p><code>_fstack = ORIGIN(ram) + LENGTH(ram) - 4;</code></p>
<hr>
<p>…</p>
<hr>
<h4 id="3-10-5-位置计数器"><a href="#3-10-5-位置计数器" class="headerlink" title="3.10.5 位置计数器"></a>3.10.5 位置计数器</h4><p>特殊链接器变量<strong>点</strong><code>.</code>始终包含当前输出位置的计数器。由于<code>.</code>始终引用输出段中的位置，故它只能出现在<strong>SECTIONS</strong>命令中的表达式中。<code>.</code>这个符号可以出现在表达式中<strong>允许使用普通符号的任何位置</strong>。</p>
<p>给<code>.</code>赋值。将导致位置计数器移动。这可用于在输出段中创建孔。<strong>位置计数器不能在输出段内向后移动</strong>，如果这样做会创建具有重叠LMA的区域，<strong>同理，也大概率不能在输出段外向后移动</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    output : &#123;</span><br><span class="line">        file1(.text) </span><br><span class="line">        . = . + 1000; </span><br><span class="line">        file2(.text) </span><br><span class="line">        . += 1000; </span><br><span class="line">        file3(.text)</span><br><span class="line">    &#125; = 0x12345678; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，源于<code>file1</code>文件的<code>.text</code>段会被放置于输出段<code>output</code>的起始位置。紧随其后的是1000字节的间隙。接着是源于<code>file2</code>文件的<code>.text</code>段，再后面是源于<code>file3</code>文件的<code>.text</code>段，二者之间同样有有1000字节的间隙。<code>=0x12345678</code>这种写法指定了要在间隙中写入的数据内容。</p>
<p>注：**<code>.</code>实际上是指从当前包含对象的起始处开始的字节偏移量<strong>。通常在起始地址为0的</strong>SECTIONS**语句中<code>.</code>可以用作绝对地址。但是如果在段描述中使用，它指的是从该节开始的字节偏移量，而不一定是绝对地址。因此，在这样的脚本中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x100 </span><br><span class="line">    .text: &#123; </span><br><span class="line">        *(.text) </span><br><span class="line">        . = 0x200</span><br><span class="line">    &#125; . = 0x500 </span><br><span class="line">    .data: &#123; </span><br><span class="line">        *(.data) </span><br><span class="line">        . += 0x600</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.text</code>段将被分配一个<strong>0x100的起始地址</strong>以及<strong>0x200字节的大小</strong>，即使该段中没有足够的数据来填充此区域。（如果数据太多，将产生一个错误，因为这将是一次向后移动的尝试）。<code>.data</code>段将从0x500开始，在**<code>.data</code>中的数据末尾<strong>和</strong><code>.data</code>输出段的结尾**之间将有额外的0x600字节的空间。</p>
<p>如果链接器需要放置孤立段，则将符号设置为输出段语句外部的位置计数器的值可能会导致意外值。例如，给出如下脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    start_of_text = . ; </span><br><span class="line">    .text: &#123; *(.text) &#125; </span><br><span class="line">    end_of_text = . ;</span><br><span class="line">    </span><br><span class="line">    start_of_data = . ; </span><br><span class="line">    .data: &#123; *(.data) &#125; </span><br><span class="line">    end_of_data = . ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果链接器需要放置一些输入段，例如：如果脚本中没有提到<code>.rodata</code>，它可能会选择将该段放在<code>.text</code>和<code>.data</code>两个部分之间。您可能认为链接器应该将<code>.rodata</code>放置在上述的脚本中的空白行上，但是空白行对于链接器没有特别的意义。此外，链接器不会将上述符号名称与其所在段相关联。相反，<strong>它假定所有赋值或其他语句都属于前一个输出段</strong>，但给<code>.</code>赋值的特殊情况除外。也就是说，链接器将按照如同下述脚本的方式来放置孤立的<code>.rodata</code>段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    start_of_text = . ; </span><br><span class="line">    .text: &#123; *(.text) &#125; </span><br><span class="line">    end_of_text = . ;</span><br><span class="line"></span><br><span class="line">    start_of_data = . ; </span><br><span class="line">    .rodata: &#123; *(.rodata) &#125; </span><br><span class="line">    .data: &#123; *(.data) &#125; </span><br><span class="line">    end_of_data = . ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这并不一定是脚本作者希望start_of_data所具有的值。影响孤立段放置的一种方法是<strong>将位置计数器分配给自身</strong>，因为链接器假定为<code>.</code>赋值是在设置下一个输出段的起始地址，故应与该段分组。所以你可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    start_of_text = . ; </span><br><span class="line">    .text: &#123; *(.text) &#125; </span><br><span class="line">    end_of_text = . ;</span><br><span class="line">    </span><br><span class="line">    . = . ;</span><br><span class="line">    start_of_data = . ; </span><br><span class="line">    .data: &#123; *(.data) &#125; </span><br><span class="line">    end_of_data = . ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，孤立段<code>.rodata</code>将放置在<em>end_of_text</em>和<em>start_of_data</em>之间。</p>
]]></content>
      <categories>
        <category>单片机</category>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
